Disassembly Listing for sylvatica
Generated From:
/home/opieters/PhD/gloxinia/src/sylvatica.X/dist/default/production/sylvatica.X.production.elf
06-Jun-2019 14:52:28

---  /home/opieters/PhD/gloxinia/src/sylvatica.X/sylvatica.c  -------------------------------------------
1:                 #include "sylvatica.h"
2:                 #include <uart.h>
3:                 #include <spi.h>
4:                 #include "filters.h"
5:                 #include "fir_coeffs.h"
6:                 #include <fir_common.h>
7:                 
8:                 #define SYLVATICA_ADC { \
9:                     .channel_select = ADC_CHANNEL_SELECT_MODE_AUTO,\
10:                    .conversion_clock_source = ADC_CONVERSION_CLOCK_SOURCE_INTERNAL,\
11:                    .trigger_select = ADC_TRIGGER_SELECT_MANUAL,\
12:                    .auto_trigger_rate = ADC_SAMPLE_RATE_AUTO_TRIGGER_500KSPS,\
13:                    .pin10_polarity = ADC_PIN10_POLARITY_SELECT_ACTIVE_LOW,\
14:                    .pin10_output = ADC_PIN10_OUTPUT_EOC,\
15:                    .pin10_io = ADC_PIN10_IO_SELECT_EOC_INT,\
16:                    .auto_nap = ADC_AUTO_NAP_POWERDOWN_DISABLE,\
17:                    .nap_powerdown = ADC_NAP_POWERDOWN_DISABLE,\
18:                    .deep_powerdown = ADC_DEEP_POWERDOWN_DISABLE,\
19:                    .tag_output = ADC_TAG_OUTPUT_DISABLE,\
20:                    .sw_reset = ADC_NORMAL_OPERATION,\
21:                    .channel = ADC_CH0,\
22:                    .sample_frequency = SYLVATICA_ADC_SAMPLE_FREQUENCY,\
23:                    .rx_callback = adc_rx_callback,\
24:                    .spi_module = SPI_MODULE_SELECTOR_3,\
25:                    .rst_pin = PIN_INIT(B, 15),\
26:                    .cs_pin = PIN_INIT(D, 3),\
27:                    .conv_pin = PIN_INIT(F, 3)} 
28:                
29:                #define SYLVATICA_PGA0 {      \
30:                    .channel = PGA_MUX_CH1,   \
31:                    .gain = PGA_GAIN_1,       \
32:                    .cs_pin = PIN_INIT(E, 3), \
33:                    .spi_message_handler = send_spi1_message,\
34:                    .status = PGA_STATUS_OFF}
35:                
36:                #define SYLVATICA_PGA1 {      \
37:                    .channel = PGA_MUX_CH1,   \
38:                    .gain = PGA_GAIN_1,       \
39:                    .cs_pin = PIN_INIT(E, 5), \
40:                    .spi_message_handler = send_spi1_message,\
41:                    .status = PGA_STATUS_OFF}
42:                
43:                #define SYLVATICA_PGA2 {      \
44:                    .channel = PGA_MUX_CH1,   \
45:                    .gain = PGA_GAIN_1,       \
46:                    .cs_pin = PIN_INIT(E, 6), \
47:                    .spi_message_handler = send_spi1_message,\
48:                    .status = PGA_STATUS_OFF}
49:                
50:                #define SYLVATICA_PGA3 {      \
51:                    .channel = PGA_MUX_CH1,   \
52:                    .gain = PGA_GAIN_1,       \
53:                    .cs_pin = PIN_INIT(E, 7), \
54:                    .spi_message_handler = send_spi1_message,\
55:                    .status = PGA_STATUS_OFF}
56:                
57:                #define SYLVATICA_PGA4 {      \
58:                    .channel = PGA_MUX_CH1,   \
59:                    .gain = PGA_GAIN_1,       \
60:                    .cs_pin = PIN_INIT(B, 11), \
61:                    .spi_message_handler = send_spi1_message,\
62:                    .status = PGA_STATUS_OFF}
63:                
64:                #define SYLVATICA_PGA5 {      \
65:                    .channel = PGA_MUX_CH1,   \
66:                    .gain = PGA_GAIN_1,       \
67:                    .cs_pin = PIN_INIT(B, 10), \
68:                    .spi_message_handler = send_spi1_message,\
69:                    .status = PGA_STATUS_OFF}
70:                
71:                #define SYLVATICA_PGA6 {      \
72:                    .channel = PGA_MUX_CH1,   \
73:                    .gain = PGA_GAIN_1,       \
74:                    .cs_pin = PIN_INIT(B, 9), \
75:                    .spi_message_handler = send_spi1_message,\
76:                    .status = PGA_STATUS_OFF}
77:                
78:                #define SYLVATICA_PGA7 {      \
79:                    .channel = PGA_MUX_CH1,   \
80:                    .gain = PGA_GAIN_1,       \
81:                    .cs_pin = PIN_INIT(B, 8), \
82:                    .spi_message_handler = send_spi1_message,\
83:                    .status = PGA_STATUS_OFF}
84:                
85:                #define SYLVATICA_I2C_CONFIG {\
86:                    .i2c_address = SYLVATICA_I2C_BASE_ADDRESS,\
87:                    .status = I2C_STATUS_SLAVE_ON,\
88:                    .mw_sr_cb = i2c_mw_sr_cb_sylvatica,\
89:                    .mr_sw_cb = i2c_mr_sw_cb_sylvatica,\
90:                    .scl_pin = PIN_INIT(G, 2),\
91:                    .sda_pin = PIN_INIT(G, 3)}
92:                
93:                static sylvatica_config_t config = {
94:                    .adc_config = SYLVATICA_ADC,
95:                    .pga_config = {
96:                        SYLVATICA_PGA0,
97:                        SYLVATICA_PGA1,
98:                        SYLVATICA_PGA2,
99:                        SYLVATICA_PGA3,
100:                       SYLVATICA_PGA4,
101:                       SYLVATICA_PGA5,
102:                       SYLVATICA_PGA6,
103:                       SYLVATICA_PGA7,
104:                   },
105:                   .channel_status = {
106:                       SYLVATICA_CHANNEL_DISABLED,
107:                       SYLVATICA_CHANNEL_DISABLED,
108:                       SYLVATICA_CHANNEL_DISABLED,
109:                       SYLVATICA_CHANNEL_DISABLED,
110:                       SYLVATICA_CHANNEL_DISABLED,
111:                       SYLVATICA_CHANNEL_DISABLED,
112:                       SYLVATICA_CHANNEL_DISABLED,
113:                       SYLVATICA_CHANNEL_DISABLED,
114:                   },
115:                   .i2c_config = SYLVATICA_I2C_CONFIG,
116:                   .address_selection0 = PIN_INIT(B, 1),
117:                   .address_selection1 = PIN_INIT(B, 0),
118:                   .blinky_pin = PIN_INIT(C, 13),
119:               };
120:               
121:               volatile uint8_t copy_buffer_selector = 0;
122:               uint8_t adc_buffer_selector = 0;
123:               volatile uint8_t start_filter_block0 = 0;
124:               uint8_t start_filter_block1 = 0, start_filter_block2 = 0, start_print_values = 0;
125:               
126:               uint16_t copy_buffers_a[SYLVATICA_N_CHANNELS][SYLVATICA_COPY_BUFFER_SIZE];
127:               uint16_t copy_buffers_b[SYLVATICA_N_CHANNELS][SYLVATICA_COPY_BUFFER_SIZE];
128:               fractional output_block0_buffers[SYLVATICA_N_CHANNELS][SYLVATICA_BLOCK1_INPUT_SIZE];
129:               fractional output_block1_buffers[SYLVATICA_N_CHANNELS][SYLVATICA_BLOCK2_INPUT_SIZE];
130:               fractional output_block2_buffers[SYLVATICA_N_CHANNELS][SYLVATICA_PRINT_VALUES_BUFFER_SIZE];
131:               
132:               uart_message_t print_messages[SYLVATICA_N_CHANNELS];
133:               
134:               #ifdef ENABLE_DEBUG
135:               extern char print_buffer[64];
136:               #endif
137:               
138:               void init_uart_messages(void){
0032F8  FA0002     LNK #0x2
139:                   uint16_t i;
140:                   
141:                   for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
0032FA  EB0000     CLR W0
0032FC  780F00     MOV W0, [W14]
0032FE  370015     BRA .L2
003328  E80F1E     INC [W14], [W14]
00332A  78001E     MOV [W14], W0
00332C  500FE7     SUB W0, #0x7, [W15]
00332E  36FFE8     BRA LEU, .L3
142:                       init_uart_message(&print_messages[i], 
003308  408100     ADD W1, W0, W2
00330E  780080     MOV W0, W1
003310  A09001     BSET W1, #9
003312  78001E     MOV [W14], W0
003314  B900EC     MULW.SU W0, #0xC, W0
003316  780180     MOV W0, W3
003318  246A00     MOV #0x46A0, W0
00331A  418000     ADD W3, W0, W0
00331C  B3C645     MOV.B #0x64, W5
00331E  780202     MOV W2, W4
003320  780181     MOV W1, W3
003322  B3C562     MOV.B #0x56, W2
003324  200071     MOV #0x7, W1
003326  070659     RCALL init_uart_message
143:                               uart_sensor_data_cmd,
144:                               0x56,
145:                               (2 << 8) | (i % SYLVATICA_N_CHANNELS),            
00330A  78009E     MOV [W14], W1
00330C  608067     AND W1, #0x7, W0
146:                               (uint8_t*) output_block2_buffers[i],
003300  243801     MOV #0x4380, W1
003302  78011E     MOV [W14], W2
003304  200640     MOV #0x64, W0
003306  B99080     MULW.SS W2, W0, W0
147:                               sizeof(fractional) * SYLVATICA_PRINT_VALUES_BUFFER_SIZE);
148:                   }
149:               }
003330  FA8000     ULNK
003332  060000     RETURN
150:               
151:               uint8_t i2c_get_address_sylvatica(sylvatica_config_t* config){
003334  FA0004     LNK #0x4
003336  980710     MOV W0, [W14+2]
152:                   uint16_t address = SYLVATICA_I2C_BASE_ADDRESS;
003338  200400     MOV #0x40, W0
00333A  780F00     MOV W0, [W14]
153:                   address = address 
00334A  600061     AND W0, #0x1, W0
00334C  400000     ADD W0, W0, W0
00334E  70009E     IOR W0, [W14], W1
00335E  600061     AND W0, #0x1, W0
003360  708F00     IOR W1, W0, [W14]
154:                           | (GET_BIT(config->address_selection1.port_r, config->address_selection1.n) << 1)
00333C  90001E     MOV [W14+2], W0
00333E  90B060     MOV [W0+236], W0
003340  780090     MOV [W0], W1
003342  90001E     MOV [W14+2], W0
003344  91F020     MOV.B [W0+242], W0
003346  FB8000     ZE W0, W0
003348  DE0800     LSR W1, W0, W0
155:                           | GET_BIT(config->address_selection0.port_r, config->address_selection0.n);
003350  90001E     MOV [W14+2], W0
003352  90B020     MOV [W0+228], W0
003354  780110     MOV [W0], W2
003356  90001E     MOV [W14+2], W0
003358  91E820     MOV.B [W0+234], W0
00335A  FB8000     ZE W0, W0
00335C  DE1000     LSR W2, W0, W0
156:                   return address;
003362  78001E     MOV [W14], W0
003364  784000     MOV.B W0, W0
157:               }
003366  FA8000     ULNK
003368  060000     RETURN
158:               
159:               void init_pins_sylvatica(void){
00336A  FA0000     LNK #0x0
160:                   _ODCG2 = 1; // configure I2C pins as open drain output
00336C  A84E66     BSET ODCG, #2
161:                   _ODCG3 = 1; // configure I2C pins as open drain output
00336E  A86E66     BSET ODCG, #3
162:                   _TRISG2 = 0;
003370  A94E60     BCLR TRISG, #2
163:                   _TRISG3 = 0;
003372  A96E60     BCLR TRISG, #3
164:                   
165:                   // SPI1 (for PGA)
166:                   _TRISE2 = 0; // SDO1
003374  A94E40     BCLR TRISE, #2
167:                   _TRISE4 = 0; // SCK1
003376  A98E40     BCLR TRISE, #4
168:                   _TRISE1 = 1; // SDI1
003378  A82E40     BSET TRISE, #1
169:                   
170:                   _RP82R = _RPOUT_SCK1;
00337A  803451     MOV RPOR5, W1
00337C  2FFC00     MOV #0xFFC0, W0
00337E  608000     AND W1, W0, W0
003380  B30060     IOR #0x6, W0
003382  883450     MOV W0, RPOR5
171:                   _RP84R = _RPOUT_SDO1;
003384  803451     MOV RPOR5, W1
003386  2C0FF0     MOV #0xC0FF, W0
003388  608080     AND W1, W0, W1
00338A  205000     MOV #0x500, W0
00338C  700001     IOR W0, W1, W0
00338E  883450     MOV W0, RPOR5
172:                   _SDI1R = 81;
003390  803641     MOV RPINR20, W1
003392  2FF800     MOV #0xFF80, W0
003394  608080     AND W1, W0, W1
003396  200510     MOV #0x51, W0
003398  700001     IOR W0, W1, W0
00339A  883640     MOV W0, RPINR20
173:                   
174:                   // SPI3 (for ADC)
175:                   _ANSB12 = 0; // SDI3
00339C  A98E1F     BCLR 0xE1F, #4
176:                   _ANSB13 = 0; // CS ADC
00339E  A9AE1F     BCLR 0xE1F, #5
177:                   _ANSB15 = 0; // RST ADC
0033A0  A9EE1F     BCLR 0xE1F, #7
178:                   
179:                   _TRISF5 = 0; // SDO3
0033A2  A9AE50     BCLR TRISF, #5
180:                   _TRISF4 = 0; // SCK3
0033A4  A98E50     BCLR TRISF, #4
181:                   _TRISB12 = 1; // SDI3
0033A6  A88E11     BSET 0xE11, #4
182:                   
183:                   _RP101R = _RPOUT_SDO3;
0033A8  803491     MOV RPOR9, W1
0033AA  2C0FF0     MOV #0xC0FF, W0
0033AC  608080     AND W1, W0, W1
0033AE  21F000     MOV #0x1F00, W0
0033B0  700001     IOR W0, W1, W0
0033B2  883490     MOV W0, RPOR9
184:                   _RP100R = _RPOUT_SCK3;
0033B4  803491     MOV RPOR9, W1
0033B6  2FFC00     MOV #0xFFC0, W0
0033B8  608000     AND W1, W0, W0
0033BA  A05000     BSET W0, #5
0033BC  883490     MOV W0, RPOR9
185:                   _SDI3R = 44;
0033BE  8036D1     MOV RPINR29, W1
0033C0  2FF800     MOV #0xFF80, W0
0033C2  608080     AND W1, W0, W1
0033C4  2002C0     MOV #0x2C, W0
0033C6  700001     IOR W0, W1, W0
0033C8  8836D0     MOV W0, RPINR29
186:                   
187:                   // connect RD3/RP67 to CS pin 
188:                   _TRISD3 = 0; // configure as output
0033CA  A96E30     BCLR TRISD, #3
189:                   _RP67R = _RPOUT_SS3;
0033CC  803411     MOV RPOR1, W1
0033CE  2C0FF0     MOV #0xC0FF, W0
0033D0  608080     AND W1, W0, W1
0033D2  221000     MOV #0x2100, W0
0033D4  700001     IOR W0, W1, W0
0033D6  883410     MOV W0, RPOR1
190:                   _SS3R = 67;
0033D8  8036E1     MOV RPINR30, W1
0033DA  2FF800     MOV #0xFF80, W0
0033DC  608080     AND W1, W0, W1
0033DE  200430     MOV #0x43, W0
0033E0  700001     IOR W0, W1, W0
0033E2  8836E0     MOV W0, RPINR30
191:                   
192:                   // input of ADC INT
193:                   // connect RPI35 to IC1 and set pin IO direction (RB3 as input)
194:                   _TRISB14 = 1; 
0033E4  A8CE11     BSET 0xE11, #6
195:                   _IC1R = 46;
0033E6  803571     MOV RPINR7, W1
0033E8  2FF800     MOV #0xFF80, W0
0033EA  608080     AND W1, W0, W1
0033EC  2002E0     MOV #0x2E, W0
0033EE  700001     IOR W0, W1, W0
0033F0  883570     MOV W0, RPINR7
196:                   _ANSB14 = 0;
0033F2  A9CE1F     BCLR 0xE1F, #6
197:                   
198:                   // nCONV signal to trigger ADC
199:                   _TRISF3 = 0; 
0033F4  A96E50     BCLR TRISF, #3
200:               }
0033F6  FA8000     ULNK
0033F8  060000     RETURN
201:               
202:               void init_adc_cs_pin(void){
0033FA  FA0000     LNK #0x0
203:                   // connect RD3/RP67 to CS pin 
204:                   _TRISD3 = 0; // configure as output
0033FC  A96E30     BCLR TRISD, #3
205:                   _RP67R = _RPOUT_OC16;
0033FE  803411     MOV RPOR1, W1
003400  2C0FF0     MOV #0xC0FF, W0
003402  608080     AND W1, W0, W1
003404  22C000     MOV #0x2C00, W0
003406  700001     IOR W0, W1, W0
003408  883410     MOV W0, RPOR1
206:                   
207:                   // nCONV signal to trigger ADC
208:                   _TRISF3 = 0;      
00340A  A96E50     BCLR TRISF, #3
209:                   _RP99R = _RPOUT_OC15; 
00340C  803481     MOV RPOR8, W1
00340E  2C0FF0     MOV #0xC0FF, W0
003410  608080     AND W1, W0, W1
003412  22B000     MOV #0x2B00, W0
003414  700001     IOR W0, W1, W0
003416  883480     MOV W0, RPOR8
210:               }
003418  FA8000     ULNK
00341A  060000     RETURN
211:               
212:               void init_sylvatica(void){
00341C  FA0002     LNK #0x2
213:                   uint16_t i;
214:                   
215:                   // read I2C slave address (sets slave address for communication with dicio)
216:                   config.i2c_config.i2c_address = i2c_get_address_sylvatica(&config);
00341E  249C80     MOV #0x49C8, W0
003420  07FF89     RCALL i2c_get_address_sylvatica
003422  FB8000     ZE W0, W0
003424  8A54A0     MOV W0, 0x4A94
217:                   
218:               #ifdef ENABLE_DEBUG
219:                   sprintf(print_buffer, "Initialised I2C slave address to 0x%x.", config.i2c_config.i2c_address);
003426  8254A0     MOV 0x4A94, W0
003428  781F80     MOV W0, [W15++]
00342A  2915E0     MOV #0x915E, W0
00342C  781F80     MOV W0, [W15++]
00342E  228400     MOV #0x2840, W0
003430  07E996     RCALL __sprintf_cdnopuxX
003432  5787E4     SUB W15, #0x4, W15
220:                   uart_print(print_buffer, strlen(print_buffer));
003434  228400     MOV #0x2840, W0
003436  07E986     RCALL _strlen
003438  780080     MOV W0, W1
00343A  228400     MOV #0x2840, W0
00343C  070521     RCALL uart_print
221:               #endif
222:                   
223:                   init_i2c1(&config.i2c_config);
00343E  24A940     MOV #0x4A94, W0
003440  07F552     RCALL init_i2c1
224:               #ifdef ENABLE_DEBUG
225:                   sprintf(print_buffer, "Initialised I2C.");
003442  200112     MOV #0x11, W2
003444  291851     MOV #0x9185, W1
003446  228400     MOV #0x2840, W0
003448  07E976     RCALL _memcpy
226:                   uart_print(print_buffer, strlen(print_buffer));
00344A  228400     MOV #0x2840, W0
00344C  07E97B     RCALL _strlen
00344E  780080     MOV W0, W1
003450  228400     MOV #0x2840, W0
003452  070516     RCALL uart_print
227:               #endif
228:                   
229:                   init_pins_sylvatica();
003454  07FF8A     RCALL init_pins_sylvatica
230:               #ifdef ENABLE_DEBUG
231:                   sprintf(print_buffer, "Initialised pins.");
003456  200122     MOV #0x12, W2
003458  291961     MOV #0x9196, W1
00345A  228400     MOV #0x2840, W0
00345C  07E96C     RCALL _memcpy
232:                   uart_print(print_buffer, strlen(print_buffer));
00345E  228400     MOV #0x2840, W0
003460  07E971     RCALL _strlen
003462  780080     MOV W0, W1
003464  228400     MOV #0x2840, W0
003466  07050C     RCALL uart_print
233:               #endif
234:                   
235:                   // TODO: check configuration
236:                   init_spi1();
003468  07F6F8     RCALL init_spi1
237:                   init_spi3();
00346A  07F718     RCALL init_spi3
238:               #ifdef ENABLE_DEBUG
239:                   sprintf(print_buffer, "Initialised SPI.");
00346C  200112     MOV #0x11, W2
00346E  291A81     MOV #0x91A8, W1
003470  228400     MOV #0x2840, W0
003472  07E961     RCALL _memcpy
240:                   uart_print(print_buffer, strlen(print_buffer));
003474  228400     MOV #0x2840, W0
003476  07E966     RCALL _strlen
003478  780080     MOV W0, W1
00347A  228400     MOV #0x2840, W0
00347C  070501     RCALL uart_print
241:               #endif
242:                   
243:                   for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
00347E  EB0000     CLR W0
003480  780F00     MOV W0, [W14]
003482  37000D     BRA .L8
00349C  E80F1E     INC [W14], [W14]
00349E  78001E     MOV [W14], W0
0034A0  500FE7     SUB W0, #0x7, [W15]
0034A2  36FFF0     BRA LEU, .L9
244:                       config.pga_config[i].status = PGA_STATUS_ON;
003484  78009E     MOV [W14], W1
003486  408064     ADD W1, #0x4, W0
003488  DD00C4     SL W0, #4, W1
00348A  249C80     MOV #0x49C8, W0
00348C  408000     ADD W1, W0, W0
00348E  200011     MOV #0x1, W1
003490  780801     MOV W1, [W0]
245:                       init_pga(&config.pga_config[i]);
003492  78001E     MOV [W14], W0
003494  DD00C4     SL W0, #4, W1
003496  24A040     MOV #0x4A04, W0
003498  408000     ADD W1, W0, W0
00349A  070601     RCALL init_pga
246:                   }
247:               #ifdef ENABLE_DEBUG
248:                   sprintf(print_buffer, "Initialised PGAs.");
0034A4  200122     MOV #0x12, W2
0034A6  291B91     MOV #0x91B9, W1
0034A8  228400     MOV #0x2840, W0
0034AA  07E945     RCALL _memcpy
249:                   uart_print(print_buffer, strlen(print_buffer));
0034AC  228400     MOV #0x2840, W0
0034AE  07E94A     RCALL _strlen
0034B0  780080     MOV W0, W1
0034B2  228400     MOV #0x2840, W0
0034B4  0704E5     RCALL uart_print
250:               #endif
251:                   
252:                   init_uart_messages();
0034B6  07FF20     RCALL init_uart_messages
253:               #ifdef ENABLE_DEBUG
254:                   sprintf(print_buffer, "Initialised UART messages.");
0034B8  2001B2     MOV #0x1B, W2
0034BA  291CB1     MOV #0x91CB, W1
0034BC  228400     MOV #0x2840, W0
0034BE  07E93B     RCALL _memcpy
255:                   uart_print(print_buffer, strlen(print_buffer));
0034C0  228400     MOV #0x2840, W0
0034C2  07E940     RCALL _strlen
0034C4  780080     MOV W0, W1
0034C6  228400     MOV #0x2840, W0
0034C8  0704DB     RCALL uart_print
256:               #endif
257:                   
258:                   // configure channel 7 and 6 as inputs
259:                   //update_sylvatica_channel(7, SYLVATICA_CHANNEL_ENABLED, &config);
260:                   //update_sylvatica_channel(6, SYLVATICA_CHANNEL_ENABLED, &config);
261:                   
262:                   init_blinky(&config.blinky_pin, 1);
0034CA  200011     MOV #0x1, W1
0034CC  24ABC0     MOV #0x4ABC, W0
0034CE  07067C     RCALL init_blinky
263:               #ifdef ENABLE_DEBUG
264:                   sprintf(print_buffer, "Initialised blinky.");
0034D0  200142     MOV #0x14, W2
0034D2  291E61     MOV #0x91E6, W1
0034D4  228400     MOV #0x2840, W0
0034D6  07E92F     RCALL _memcpy
265:                   uart_print(print_buffer, strlen(print_buffer));
0034D8  228400     MOV #0x2840, W0
0034DA  07E934     RCALL _strlen
0034DC  780080     MOV W0, W1
0034DE  228400     MOV #0x2840, W0
0034E0  0704CF     RCALL uart_print
266:               #endif
267:                   
268:                   init_filters();
0034E2  070717     RCALL init_filters
269:               #ifdef ENABLE_DEBUG
270:                   sprintf(print_buffer, "Initialised filters.");
0034E4  200152     MOV #0x15, W2
0034E6  291FA1     MOV #0x91FA, W1
0034E8  228400     MOV #0x2840, W0
0034EA  07E925     RCALL _memcpy
271:                   uart_print(print_buffer, strlen(print_buffer));
0034EC  228400     MOV #0x2840, W0
0034EE  07E92A     RCALL _strlen
0034F0  780080     MOV W0, W1
0034F2  228400     MOV #0x2840, W0
0034F4  0704C5     RCALL uart_print
272:               #endif
273:                   
274:                   init_adc(&config.adc_config);
0034F6  249C80     MOV #0x49C8, W0
0034F8  07FC19     RCALL init_adc
275:                       
276:               #ifdef ENABLE_DEBUG
277:                   sprintf(print_buffer, "Initialised ADC.");
0034FA  200112     MOV #0x11, W2
0034FC  2920F1     MOV #0x920F, W1
0034FE  228400     MOV #0x2840, W0
003500  07E91A     RCALL _memcpy
278:                   uart_print(print_buffer, strlen(print_buffer));
003502  228400     MOV #0x2840, W0
003504  07E91F     RCALL _strlen
003506  780080     MOV W0, W1
003508  228400     MOV #0x2840, W0
00350A  0704BA     RCALL uart_print
279:               #endif
280:                   
281:                   init_adc_cs_pin();
00350C  07FF76     RCALL init_adc_cs_pin
282:                   
283:                   adc_start(&config.adc_config);
00350E  249C80     MOV #0x49C8, W0
003510  07FE90     RCALL adc_start
284:               #ifdef ENABLE_DEBUG
285:                   sprintf(print_buffer, "Configured ADC.");
003512  200102     MOV #0x10, W2
003514  292201     MOV #0x9220, W1
003516  228400     MOV #0x2840, W0
003518  07E90E     RCALL _memcpy
286:                   uart_print(print_buffer, strlen(print_buffer));
00351A  228400     MOV #0x2840, W0
00351C  07E913     RCALL _strlen
00351E  780080     MOV W0, W1
003520  228400     MOV #0x2840, W0
003522  0704AE     RCALL uart_print
287:               #endif
288:               }
003524  FA8000     ULNK
003526  060000     RETURN
289:               
290:               void update_sylvatica_channel(uint8_t channel_n, sylvatica_channel_status_t status, sylvatica_config_t* config){
003528  FA0008     LNK #0x8
00352A  984720     MOV.B W0, [W14+2]
00352C  980721     MOV W1, [W14+4]
00352E  980732     MOV W2, [W14+6]
291:                   uint16_t i = 0;
003530  EB0000     CLR W0
003532  780F00     MOV W0, [W14]
292:                   
293:                   if(channel_n >= SYLVATICA_N_CHANNELS){
003534  90402E     MOV.B [W14+2], W0
003536  504FE7     SUB.B W0, #0x7, [W15]
003538  3E0039     BRA GTU, .L17
294:                       // incorrect channel number,do not do anything
295:                       return;
0035AC  000000     NOP
296:                   }
297:                   if(status == SYLVATICA_CHANNEL_ENABLED){
00353A  90002E     MOV [W14+4], W0
00353C  E00000     CP0 W0
00353E  3A0009     BRA NZ, .L13
298:                       // update PGA status
299:                       config->pga_config[channel_n].status = PGA_STATUS_ON;
003540  90402E     MOV.B [W14+2], W0
003542  FB8000     ZE W0, W0
003544  9000BE     MOV [W14+6], W1
003546  400064     ADD W0, #0x4, W0
003548  DD0044     SL W0, #4, W0
00354A  408000     ADD W1, W0, W0
00354C  200011     MOV #0x1, W1
00354E  780801     MOV W1, [W0]
003550  370008     BRA .L14
300:                   } else {
301:                       // update PGA status
302:                       config->pga_config[channel_n].status = PGA_STATUS_OFF;
003552  90402E     MOV.B [W14+2], W0
003554  FB8000     ZE W0, W0
003556  9000BE     MOV [W14+6], W1
003558  400064     ADD W0, #0x4, W0
00355A  DD0044     SL W0, #4, W0
00355C  408000     ADD W1, W0, W0
00355E  EB0080     CLR W1
003560  780801     MOV W1, [W0]
303:                   }
304:                   
305:                   // update PGA status
306:                   update_pga_status(&config->pga_config[channel_n]);
003562  90003E     MOV [W14+6], W0
003564  2003C1     MOV #0x3C, W1
003566  408080     ADD W1, W0, W1
003568  90402E     MOV.B [W14+2], W0
00356A  FB8000     ZE W0, W0
00356C  DD0044     SL W0, #4, W0
00356E  408000     ADD W1, W0, W0
003570  0705C3     RCALL update_pga_status
307:                   
308:                   // update internal status field
309:                   config->channel_status[channel_n] = status;
003572  90402E     MOV.B [W14+2], W0
003574  FB8000     ZE W0, W0
003576  9000BE     MOV [W14+6], W1
003578  B005E0     ADD #0x5E, W0
00357A  400000     ADD W0, W0, W0
00357C  408000     ADD W1, W0, W0
00357E  9000AE     MOV [W14+4], W1
003580  780801     MOV W1, [W0]
310:                   
311:                   // find which channel is last active one
312:                   i = SYLVATICA_N_CHANNELS-1;
003582  200070     MOV #0x7, W0
003584  780F00     MOV W0, [W14]
313:                   while((i >= 0) && (config->channel_status[i] == SYLVATICA_CHANNEL_ENABLED)){
003586  370001     BRA .L15
00358A  9000BE     MOV [W14+6], W1
00358C  2005E2     MOV #0x5E, W2
00358E  41001E     ADD W2, [W14], W0
003590  400000     ADD W0, W0, W0
003592  408000     ADD W1, W0, W0
003594  780010     MOV [W0], W0
003596  E00000     CP0 W0
003598  32FFF7     BRA Z, .L16
314:                       i--;
003588  E90F1E     DEC [W14], [W14]
315:                   }
316:                   
317:                   // configure ADC channel sample mode
318:                   config->adc_config.trigger_select = ADC_TRIGGER_SELECT_AUTO;
00359A  90003E     MOV [W14+6], W0
00359C  EB0080     CLR W1
00359E  980021     MOV W1, [W0+4]
319:                   config->adc_config.channel = i+1; // 0 corresponds to channel NONE
0035A0  E8009E     INC [W14], W1
0035A2  90003E     MOV [W14+6], W0
0035A4  980841     MOV W1, [W0+24]
320:                   
321:                   update_adc(&config->adc_config);
0035A6  90003E     MOV [W14+6], W0
0035A8  07FE02     RCALL update_adc
0035AA  370001     BRA .L10
322:               }
0035AE  FA8000     ULNK
0035B0  060000     RETURN
323:               
324:               uint16_t counter = 0;
325:               void loop_sylvatica(void){    
0035B2  FA0000     LNK #0x0
0035B4  370001     BRA .L26
326:                   while(1){
327:                       
328:                       if(start_filter_block0){
0035B8  BFD04A     MOV.B start_filter_block0, WREG
0035BA  E00400     CP0.B W0
0035BC  32004A     BRA Z, .L19
329:                           process_filter_block0(); 
0035BE  0700DD     RCALL process_filter_block0
330:                           
331:                           if((counter == 0x100) || (counter==0x101)){
0035C0  808271     MOV counter, W1
0035C2  201000     MOV #0x100, W0
0035C4  508F80     SUB W1, W0, [W15]
0035C6  320004     BRA Z, .L20
0035C8  808271     MOV counter, W1
0035CA  201010     MOV #0x101, W0
0035CC  508F80     SUB W1, W0, [W15]
0035CE  3A0038     BRA NZ, .L21
332:                               if(copy_buffer_selector == 0){
0035D0  BFD048     MOV.B copy_buffer_selector, WREG
0035D2  E00400     CP0.B W0
0035D4  3A001B     BRA NZ, .L22
333:                                   sprintf(print_buffer, "b %04x %04x %04x %04x %04x %04x %04x %04x", 
0035D6  819F77     MOV 0x33EE, W7
0035D8  819F66     MOV 0x33EC, W6
0035DA  819F55     MOV 0x33EA, W5
0035DC  819F44     MOV 0x33E8, W4
0035DE  819F33     MOV 0x33E6, W3
0035E0  819F22     MOV 0x33E4, W2
0035E2  819F11     MOV 0x33E2, W1
0035E4  819F00     MOV copy_buffers_b, W0
0035E6  781F87     MOV W7, [W15++]
0035E8  781F86     MOV W6, [W15++]
0035EA  781F85     MOV W5, [W15++]
0035EC  781F84     MOV W4, [W15++]
0035EE  781F83     MOV W3, [W15++]
0035F0  781F82     MOV W2, [W15++]
0035F2  781F81     MOV W1, [W15++]
0035F4  781F80     MOV W0, [W15++]
0035F6  292300     MOV #0x9230, W0
0035F8  781F80     MOV W0, [W15++]
0035FA  228400     MOV #0x2840, W0
0035FC  07E8B0     RCALL __sprintf_cdnopuxX
0035FE  5787F2     SUB W15, #0x12, W15
334:                                           copy_buffers_b[0][0],
335:                                           copy_buffers_b[0][1],
336:                                           copy_buffers_b[0][2],
337:                                           copy_buffers_b[0][3],
338:                                           copy_buffers_b[0][4],
339:                                           copy_buffers_b[0][5],
340:                                           copy_buffers_b[0][6],
341:                                           copy_buffers_b[0][7]);
342:                                   uart_print(print_buffer, strlen(print_buffer));
003600  228400     MOV #0x2840, W0
003602  07E8A0     RCALL _strlen
003604  780080     MOV W0, W1
003606  228400     MOV #0x2840, W0
003608  07043B     RCALL uart_print
00360A  37001A     BRA .L21
343:                               } else {
344:                                   sprintf(print_buffer, "a %04x %04x %04x %04x %04x %04x %04x %04x",
00360C  816D77     MOV 0x2DAE, W7
00360E  816D66     MOV 0x2DAC, W6
003610  816D55     MOV 0x2DAA, W5
003612  816D44     MOV 0x2DA8, W4
003614  816D33     MOV .LE127, W3
003616  816D22     MOV 0x2DA4, W2
003618  816D11     MOV 0x2DA2, W1
00361A  816D00     MOV copy_buffers_a, W0
00361C  781F87     MOV W7, [W15++]
00361E  781F86     MOV W6, [W15++]
003620  781F85     MOV W5, [W15++]
003622  781F84     MOV W4, [W15++]
003624  781F83     MOV W3, [W15++]
003626  781F82     MOV W2, [W15++]
003628  781F81     MOV W1, [W15++]
00362A  781F80     MOV W0, [W15++]
00362C  2925A0     MOV #0x925A, W0
00362E  781F80     MOV W0, [W15++]
003630  228400     MOV #0x2840, W0
003632  07E895     RCALL __sprintf_cdnopuxX
003634  5787F2     SUB W15, #0x12, W15
345:                                           copy_buffers_a[0][0],
346:                                           copy_buffers_a[0][1],
347:                                           copy_buffers_a[0][2],
348:                                           copy_buffers_a[0][3],
349:                                           copy_buffers_a[0][4],
350:                                           copy_buffers_a[0][5],
351:                                           copy_buffers_a[0][6],
352:                                           copy_buffers_a[0][7]);
353:                                   uart_print(print_buffer, strlen(print_buffer));
003636  228400     MOV #0x2840, W0
003638  07E885     RCALL _strlen
00363A  780080     MOV W0, W1
00363C  228400     MOV #0x2840, W0
00363E  070420     RCALL uart_print
354:                               }
355:                           }
356:                           counter = (counter+1) % 0x101;
003640  808270     MOV counter, W0
003642  E80100     INC W0, W2
003644  2FF010     MOV #0xFF01, W0
003646  B81000     MUL.UU W2, W0, W0
003648  DE0848     LSR W1, #8, W0
00364A  201011     MOV #0x101, W1
00364C  B98081     MULW.SS W0, W1, W0
00364E  510000     SUB W2, W0, W0
003650  888270     MOV W0, counter
357:                       }
358:                       
359:                       if(start_filter_block1){
003652  BFD04B     MOV.B start_filter_block1, WREG
003654  E00400     CP0.B W0
003656  320001     BRA Z, .L23
360:                           process_filter_block1();
003658  0700D2     RCALL process_filter_block1
361:                       }
362:                       
363:                       if(start_filter_block2){
00365A  BFD04C     MOV.B start_filter_block2, WREG
00365C  E00400     CP0.B W0
00365E  320001     BRA Z, .L24
364:                           process_filter_block2();
003660  0700FB     RCALL process_filter_block2
365:                           
366:               
367:                       }
368:                       
369:                       if(start_print_values){
003662  BFD04D     MOV.B start_print_values, WREG
003664  E00400     CP0.B W0
003666  32FFA7     BRA Z, .L27
370:                           print_values_uart();
003668  070124     RCALL print_values_uart
371:                       }
372:                   }
0035B6  000000     NOP
00366A  37FFA6     BRA .L26
373:               }
374:               
375:               
376:               void i2c_mw_sr_cb_sylvatica(i2c_message_t* m){
00366C  FA0002     LNK #0x2
00366E  780F00     MOV W0, [W14]
377:                   
378:               }
003670  FA8000     ULNK
003672  060000     RETURN
379:               
380:               void i2c_mr_sw_cb_sylvatica(i2c_message_t* m){
003674  FA0002     LNK #0x2
003676  780F00     MOV W0, [W14]
381:                   
382:               }
003678  FA8000     ULNK
00367A  060000     RETURN
383:               
384:               void adc_rx_callback(void){
00367C  FA0002     LNK #0x2
385:                   uint16_t i;
386:                   static uint16_t copy_counter = 0;
387:                   
388:                   //eds_read = DSRPAG;
389:                   if (adc_buffer_selector == 0) {
00367E  BFD049     MOV.B adc_buffer_selector, WREG
003680  E00400     CP0.B W0
003682  3A0035     BRA NZ, .L31
390:                       if(copy_buffer_selector == 0){
003684  BFD048     MOV.B copy_buffer_selector, WREG
003686  E00400     CP0.B W0
003688  3A0019     BRA NZ, .L32
391:                           for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
00368A  EB0000     CLR W0
00368C  780F00     MOV W0, [W14]
00368E  370012     BRA .L33
0036B2  E80F1E     INC [W14], [W14]
0036B4  78001E     MOV [W14], W0
0036B6  500FE7     SUB W0, #0x7, [W15]
0036B8  36FFEB     BRA LEU, .L34
0036BA  37004D     BRA .L35
392:                               copy_adc_data(ADC_BUFFER_LENGTH / SYLVATICA_N_CHANNELS, (fractional*) &copy_buffers_a[i][copy_counter], (fractional*) &adc_rx_buffer_a[i]);
003690  2D9C01     MOV #0xD9C0, W1
003692  78001E     MOV [W14], W0
003694  400000     ADD W0, W0, W0
003696  408080     ADD W1, W0, W1
003698  22DA02     MOV #0x2DA0, W2
00369A  78019E     MOV [W14], W3
00369C  200640     MOV #0x64, W0
00369E  B99880     MULW.SS W3, W0, W0
0036A0  780180     MOV W0, W3
0036A2  8082B0     MOV copy_counter, W0
0036A4  418000     ADD W3, W0, W0
0036A6  400000     ADD W0, W0, W0
0036A8  410000     ADD W2, W0, W0
0036AA  780101     MOV W1, W2
0036AC  780080     MOV W0, W1
0036AE  200190     MOV #0x19, W0
0036B0  070623     RCALL _copy_adc_data
393:                           }
394:                       } else {
395:                           for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
0036BC  EB0000     CLR W0
0036BE  780F00     MOV W0, [W14]
0036C0  370012     BRA .L36
0036E4  E80F1E     INC [W14], [W14]
0036E6  78001E     MOV [W14], W0
0036E8  500FE7     SUB W0, #0x7, [W15]
0036EA  36FFEB     BRA LEU, .L37
0036EC  370034     BRA .L35
396:                               copy_adc_data(ADC_BUFFER_LENGTH / SYLVATICA_N_CHANNELS, (fractional*) &copy_buffers_b[i][copy_counter], (fractional*) &adc_rx_buffer_a[i]);
0036C2  2D9C01     MOV #0xD9C0, W1
0036C4  78001E     MOV [W14], W0
0036C6  400000     ADD W0, W0, W0
0036C8  408080     ADD W1, W0, W1
0036CA  233E02     MOV #0x33E0, W2
0036CC  78019E     MOV [W14], W3
0036CE  200640     MOV #0x64, W0
0036D0  B99880     MULW.SS W3, W0, W0
0036D2  780180     MOV W0, W3
0036D4  8082B0     MOV copy_counter, W0
0036D6  418000     ADD W3, W0, W0
0036D8  400000     ADD W0, W0, W0
0036DA  410000     ADD W2, W0, W0
0036DC  780101     MOV W1, W2
0036DE  780080     MOV W0, W1
0036E0  200190     MOV #0x19, W0
0036E2  07060A     RCALL _copy_adc_data
397:                           }
398:                       }
399:                       //adc_buffer = adc_rx_buffer_a;
400:                       //DSRPAG = __builtin_edspage(adc_rx_buffer_a);
401:                   } else {
402:                       if(copy_buffer_selector == 0){
0036EE  BFD048     MOV.B copy_buffer_selector, WREG
0036F0  E00400     CP0.B W0
0036F2  3A0019     BRA NZ, .L38
403:                           for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
0036F4  EB0000     CLR W0
0036F6  780F00     MOV W0, [W14]
0036F8  370012     BRA .L39
00371C  E80F1E     INC [W14], [W14]
00371E  78001E     MOV [W14], W0
003720  500FE7     SUB W0, #0x7, [W15]
003722  36FFEB     BRA LEU, .L40
003724  370018     BRA .L35
404:                               copy_adc_data(ADC_BUFFER_LENGTH / SYLVATICA_N_CHANNELS, (fractional*) &copy_buffers_a[i][copy_counter], (fractional*) &adc_rx_buffer_b[i]);
0036FA  2D8301     MOV #0xD830, W1
0036FC  78001E     MOV [W14], W0
0036FE  400000     ADD W0, W0, W0
003700  408080     ADD W1, W0, W1
003702  22DA02     MOV #0x2DA0, W2
003704  78019E     MOV [W14], W3
003706  200640     MOV #0x64, W0
003708  B99880     MULW.SS W3, W0, W0
00370A  780180     MOV W0, W3
00370C  8082B0     MOV copy_counter, W0
00370E  418000     ADD W3, W0, W0
003710  400000     ADD W0, W0, W0
003712  410000     ADD W2, W0, W0
003714  780101     MOV W1, W2
003716  780080     MOV W0, W1
003718  200190     MOV #0x19, W0
00371A  0705EE     RCALL _copy_adc_data
405:                           }
406:                       } else {
407:                           for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
003726  EB0000     CLR W0
003728  780F00     MOV W0, [W14]
00372A  370012     BRA .L41
00374E  E80F1E     INC [W14], [W14]
003750  78001E     MOV [W14], W0
003752  500FE7     SUB W0, #0x7, [W15]
003754  36FFEB     BRA LEU, .L42
408:                               copy_adc_data(ADC_BUFFER_LENGTH / SYLVATICA_N_CHANNELS, (fractional*) &copy_buffers_b[i][copy_counter], (fractional*) &adc_rx_buffer_b[i]);
00372C  2D8301     MOV #0xD830, W1
00372E  78001E     MOV [W14], W0
003730  400000     ADD W0, W0, W0
003732  408080     ADD W1, W0, W1
003734  233E02     MOV #0x33E0, W2
003736  78019E     MOV [W14], W3
003738  200640     MOV #0x64, W0
00373A  B99880     MULW.SS W3, W0, W0
00373C  780180     MOV W0, W3
00373E  8082B0     MOV copy_counter, W0
003740  418000     ADD W3, W0, W0
003742  400000     ADD W0, W0, W0
003744  410000     ADD W2, W0, W0
003746  780101     MOV W1, W2
003748  780080     MOV W0, W1
00374A  200190     MOV #0x19, W0
00374C  0705D5     RCALL _copy_adc_data
409:                           }
410:                       }
411:                       //adc_buffer = adc_rx_buffer_b;
412:                       //DSRPAG = __builtin_edspage(adc_rx_buffer_b);
413:                   }
414:                   copy_counter += ADC_BUFFER_LENGTH / SYLVATICA_N_CHANNELS;
003756  8082B0     MOV copy_counter, W0
003758  400079     ADD W0, #0x19, W0
00375A  8882B0     MOV W0, copy_counter
415:                   
416:                   // copy samples
417:                   /*if(copy_buffer_selector == 0) {
418:                       for(i = 0; i < ADC_BUFFER_LENGTH; i += SYLVATICA_N_CHANNELS){
419:                           for(j = 0; j < SYLVATICA_N_CHANNELS; j++){
420:                               copy_buffers_a[j][copy_counter] = adc_buffer[i+j];
421:                           }
422:                           copy_counter++;
423:                       } 
424:                   } else {
425:                       for(i = 0; i < ADC_BUFFER_LENGTH; i += SYLVATICA_N_CHANNELS){
426:                           for(j = 0; j < SYLVATICA_N_CHANNELS; j++){
427:                               copy_buffers_b[j][copy_counter] = adc_buffer[i+j];
428:                           }
429:                           copy_counter++;
430:                       } 
431:                   }
432:                   DSRPAG = eds_read;*/
433:                   
434:                   if(copy_counter == SYLVATICA_COPY_BUFFER_SIZE){
00375C  8082B1     MOV copy_counter, W1
00375E  200640     MOV #0x64, W0
003760  508F80     SUB W1, W0, [W15]
003762  3A0006     BRA NZ, .L43
435:                       start_filter_block0 = 1;
003764  B3C010     MOV.B #0x1, W0
003766  B7F04A     MOV.B WREG, start_filter_block0
436:                       copy_buffer_selector ^= 1;
003768  BFD048     MOV.B copy_buffer_selector, WREG
00376A  A20400     BTG.B W0, #0
00376C  B7F048     MOV.B WREG, copy_buffer_selector
437:                       copy_counter = 0;
00376E  EF3056     CLR copy_counter
438:                   }
439:                   
440:                   adc_buffer_selector ^= 1;
003770  BFD049     MOV.B adc_buffer_selector, WREG
003772  A20400     BTG.B W0, #0
003774  B7F049     MOV.B WREG, adc_buffer_selector
441:               }
003776  FA8000     ULNK
003778  060000     RETURN
442:               
443:               void process_filter_block0(void){
00377A  FA00CA     LNK #0xCA
444:                   uint8_t i;
445:                   static uint16_t block0_counter = 0;
446:                   fractional sample_buffer[SYLVATICA_COPY_BUFFER_SIZE];
447:                   
448:                   start_filter_block0 = 0;
00377C  EF704A     CLR.B start_filter_block0
449:                   
450:                   for(i = 0; i < SYLVATICA_N_CHANNELS; i++){   
00377E  EB4000     CLR.B W0
003780  784F00     MOV.B W0, [W14]
003782  37002E     BRA .L45
0037DE  E84F1E     INC.B [W14], [W14]
0037E0  78401E     MOV.B [W14], W0
0037E2  504FE7     SUB.B W0, #0x7, [W15]
0037E4  36FFCF     BRA LEU, .L48
451:                       if(copy_buffer_selector == 0){
003784  BFD048     MOV.B copy_buffer_selector, WREG
003786  E00400     CP0.B W0
003788  3A000B     BRA NZ, .L46
452:                           covert_uint_to_fract(SYLVATICA_COPY_BUFFER_SIZE, copy_buffers_b[i], sample_buffer);
00378A  233E01     MOV #0x33E0, W1
00378C  FB811E     ZE [W14], W2
00378E  200C80     MOV #0xC8, W0
003790  B99080     MULW.SS W2, W0, W0
003792  408000     ADD W1, W0, W0
003794  E8808E     INC2 W14, W1
003796  780101     MOV W1, W2
003798  780080     MOV W0, W1
00379A  200640     MOV #0x64, W0
00379C  0705A8     RCALL _covert_uint_to_fract
00379E  37000A     BRA .L47
453:                       } else {
454:                           covert_uint_to_fract(SYLVATICA_COPY_BUFFER_SIZE, copy_buffers_a[i], sample_buffer);
0037A0  22DA01     MOV #0x2DA0, W1
0037A2  FB811E     ZE [W14], W2
0037A4  200C80     MOV #0xC8, W0
0037A6  B99080     MULW.SS W2, W0, W0
0037A8  408000     ADD W1, W0, W0
0037AA  E8808E     INC2 W14, W1
0037AC  780101     MOV W1, W2
0037AE  780080     MOV W0, W1
0037B0  200640     MOV #0x64, W0
0037B2  07059D     RCALL _covert_uint_to_fract
455:                       }
456:                           
457:                       fir_compressed(SYLVATICA_COPY_BUFFER_SIZE / DECIMATION_FACTOR_F0, 
0037B4  FB801E     ZE [W14], W0
0037BA  210760     MOV #0x1076, W0
0037BC  408100     ADD W1, W0, W2
0037CE  408000     ADD W1, W0, W0
0037D0  E8808E     INC2 W14, W1
0037D2  2000A4     MOV #0xA, W4
0037D4  780182     MOV W2, W3
0037D6  780101     MOV W1, W2
0037D8  780080     MOV W0, W1
0037DA  2000A0     MOV #0xA, W0
0037DC  070550     RCALL .Letext0, .LFE4, _fir_compressed
458:                               &output_block0_buffers[i][block0_counter], 
0037BE  23A201     MOV #0x3A20, W1
0037C0  FB819E     ZE [W14], W3
0037C2  200640     MOV #0x64, W0
0037C4  B99880     MULW.SS W3, W0, W0
0037C6  780180     MOV W0, W3
0037C8  8082A0     MOV block0_counter, W0
0037CA  418000     ADD W3, W0, W0
0037CC  400000     ADD W0, W0, W0
459:                               sample_buffer, 
460:                               &filters_0[i], 
0037B6  B900EE     MULW.SU W0, #0xE, W0
0037B8  780080     MOV W0, W1
461:                               DECIMATION_FACTOR_F0);
462:                   }
463:                   block0_counter += SYLVATICA_COPY_BUFFER_SIZE / DECIMATION_FACTOR_F0;
0037E6  8082A0     MOV block0_counter, W0
0037E8  40006A     ADD W0, #0xA, W0
0037EA  8882A0     MOV W0, block0_counter
464:                   if(block0_counter == SYLVATICA_BLOCK1_INPUT_SIZE){
0037EC  8082A1     MOV block0_counter, W1
0037EE  200640     MOV #0x64, W0
0037F0  508F80     SUB W1, W0, [W15]
0037F2  3A0003     BRA NZ, .L44
465:                       start_filter_block1 = 1;
0037F4  B3C010     MOV.B #0x1, W0
0037F6  B7F04B     MOV.B WREG, start_filter_block1
466:                       block0_counter = 0;
0037F8  EF3054     CLR block0_counter
467:                   }
468:               }
0037FA  FA8000     ULNK
0037FC  060000     RETURN
469:               
470:               void process_filter_block1(void){
0037FE  FA0002     LNK #0x2
471:                   uint8_t i;
472:                   static uint16_t block1_counter = 0;
473:                   
474:                   start_filter_block1 = 0;
003800  EF704B     CLR.B start_filter_block1
475:                   
476:                   for(i = 0; i < SYLVATICA_N_CHANNELS; i++){   
003802  EB4000     CLR.B W0
003804  784F00     MOV.B W0, [W14]
003806  370019     BRA .L51
003838  E84F1E     INC.B [W14], [W14]
00383A  78401E     MOV.B [W14], W0
00383C  504FE7     SUB.B W0, #0x7, [W15]
00383E  36FFE4     BRA LEU, .L52
477:                           
478:                       fir_compressed(SYLVATICA_BLOCK1_INPUT_SIZE / DECIMATION_FACTOR_F1, 
003808  FB801E     ZE [W14], W0
00380E  210E60     MOV #0x10E6, W0
003810  408100     ADD W1, W0, W2
003814  FB819E     ZE [W14], W3
00381A  408080     ADD W1, W0, W1
00382A  418000     ADD W3, W0, W0
00382C  2000A4     MOV #0xA, W4
00382E  780182     MOV W2, W3
003830  780101     MOV W1, W2
003832  780080     MOV W0, W1
003834  2000A0     MOV #0xA, W0
003836  070523     RCALL .Letext0, .LFE4, _fir_compressed
479:                               &output_block1_buffers[i][block1_counter], 
00381C  240603     MOV #0x4060, W3
00381E  FB821E     ZE [W14], W4
003820  200320     MOV #0x32, W0
003822  B9A280     MULW.SS W4, W0, W4
003824  808290     MOV block1_counter, W0
003826  420000     ADD W4, W0, W0
003828  400000     ADD W0, W0, W0
480:                               output_block0_buffers[i], 
003812  23A201     MOV #0x3A20, W1
003816  200C80     MOV #0xC8, W0
003818  B99880     MULW.SS W3, W0, W0
481:                               &filters_1[i], 
00380A  B900EE     MULW.SU W0, #0xE, W0
00380C  780080     MOV W0, W1
482:                               DECIMATION_FACTOR_F1);
483:                   }
484:                   block1_counter += SYLVATICA_BLOCK1_INPUT_SIZE / DECIMATION_FACTOR_F1;
003840  808290     MOV block1_counter, W0
003842  40006A     ADD W0, #0xA, W0
003844  888290     MOV W0, block1_counter
485:                   if(block1_counter == SYLVATICA_BLOCK2_INPUT_SIZE){
003846  808291     MOV block1_counter, W1
003848  200320     MOV #0x32, W0
00384A  508F80     SUB W1, W0, [W15]
00384C  3A0003     BRA NZ, .L50
486:                       start_filter_block2 = 1;
00384E  B3C010     MOV.B #0x1, W0
003850  B7F04C     MOV.B WREG, start_filter_block2
487:                       block1_counter = 0;
003852  EF3052     CLR block1_counter
488:                   }
489:               }
003854  FA8000     ULNK
003856  060000     RETURN
490:               
491:               void process_filter_block2(void){
003858  FA0002     LNK #0x2
492:                   uint8_t i;
493:                   static uint16_t block2_counter = 0;
494:                   
495:                   start_filter_block2 = 0;
00385A  EF704C     CLR.B start_filter_block2
496:                   
497:                   for(i = 0; i < SYLVATICA_N_CHANNELS; i++){   
00385C  EB4000     CLR.B W0
00385E  784F00     MOV.B W0, [W14]
003860  370019     BRA .L55
003892  E84F1E     INC.B [W14], [W14]
003894  78401E     MOV.B [W14], W0
003896  504FE7     SUB.B W0, #0x7, [W15]
003898  36FFE4     BRA LEU, .L56
498:                       fir_compressed(SYLVATICA_BLOCK2_INPUT_SIZE / DECIMATION_FACTOR_F2, 
003862  FB801E     ZE [W14], W0
003868  211560     MOV #0x1156, W0
00386A  408100     ADD W1, W0, W2
00386E  FB819E     ZE [W14], W3
003874  408080     ADD W1, W0, W1
003884  418000     ADD W3, W0, W0
003886  200014     MOV #0x1, W4
003888  780182     MOV W2, W3
00388A  780101     MOV W1, W2
00388C  780080     MOV W0, W1
00388E  200320     MOV #0x32, W0
003890  0704F6     RCALL .Letext0, .LFE4, _fir_compressed
499:                               &output_block2_buffers[i][block2_counter], 
003876  243803     MOV #0x4380, W3
003878  FB821E     ZE [W14], W4
00387A  200320     MOV #0x32, W0
00387C  B9A280     MULW.SS W4, W0, W4
00387E  808280     MOV block2_counter, W0
003880  420000     ADD W4, W0, W0
003882  400000     ADD W0, W0, W0
500:                               output_block1_buffers[i], 
00386C  240601     MOV #0x4060, W1
003870  200640     MOV #0x64, W0
003872  B99880     MULW.SS W3, W0, W0
501:                               &filters_2[i], 
003864  B900EE     MULW.SU W0, #0xE, W0
003866  780080     MOV W0, W1
502:                               DECIMATION_FACTOR_F2);
503:                   }
504:                   block2_counter += SYLVATICA_BLOCK2_INPUT_SIZE / DECIMATION_FACTOR_F2;
00389A  808280     MOV block2_counter, W0
00389C  B00320     ADD #0x32, W0
00389E  888280     MOV W0, block2_counter
505:                   if(block2_counter == SYLVATICA_PRINT_VALUES_BUFFER_SIZE){
0038A0  808281     MOV block2_counter, W1
0038A2  200320     MOV #0x32, W0
0038A4  508F80     SUB W1, W0, [W15]
0038A6  3A0003     BRA NZ, .L54
506:                       block2_counter = 0;
0038A8  EF3050     CLR block2_counter
507:                       start_print_values = 1;
0038AA  B3C010     MOV.B #0x1, W0
0038AC  B7F04D     MOV.B WREG, start_print_values
508:                   }
509:               }
0038AE  FA8000     ULNK
0038B0  060000     RETURN
510:               
511:               void print_values_uart(){
0038B2  FA0002     LNK #0x2
512:                   uint16_t i;
513:                   
514:                   start_print_values = 0;
0038B4  EF704D     CLR.B start_print_values
515:                   
516:                   for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
0038B6  EB0000     CLR W0
0038B8  780F00     MOV W0, [W14]
0038BA  370007     BRA .L59
0038C8  E80F1E     INC [W14], [W14]
0038CA  78001E     MOV [W14], W0
0038CC  500FE7     SUB W0, #0x7, [W15]
0038CE  36FFF6     BRA LEU, .L60
517:                       queue_uart_message(&print_messages[i]);
0038BC  78001E     MOV [W14], W0
0038BE  B900EC     MULW.SU W0, #0xC, W0
0038C0  780080     MOV W0, W1
0038C2  246A00     MOV #0x46A0, W0
0038C4  408000     ADD W1, W0, W0
0038C6  070326     RCALL queue_uart_message
518:                   }
519:               }
0038D0  FA8000     ULNK
0038D2  060000     RETURN
---  /home/opieters/PhD/gloxinia/src/sylvatica.X/main.c  ------------------------------------------------
1:                 #include <xc.h>
2:                 #include <uart.h>
3:                 #include "sylvatica.h"
4:                 
5:                 #ifdef ENABLE_DEBUG
6:                 #include <stdio.h>
7:                 #include <string.h>
8:                 #endif
9:                 
10:                #pragma config GWRP = OFF                       // General Segment Write-Protect bit (General Segment may be written)
11:                #pragma config GSS = OFF                        // General Segment Code-Protect bit (General Segment Code protect is disabled)
12:                #pragma config GSSK = OFF                       // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)
13:                
14:                // FOSCSEL
15:                #pragma config FNOSC = FRC                      // Initial Oscillator Source Selection Bits (Internal Fast RC (FRC))
16:                #pragma config IESO = OFF                       // Two-speed Oscillator Start-up Enable bit (Start up with user-selected oscillator source)
17:                
18:                // FOSC
19:                #pragma config POSCMD = XT                    // Primary Oscillator Mode Select bits (Primary Oscillator disabled)
20:                #pragma config OSCIOFNC = OFF                   // OSC2 Pin Function bit (OSC2 is clock output)
21:                #pragma config IOL1WAY = OFF                    // Peripheral pin select configuration (Allow multiple reconfigurations)
22:                #pragma config FCKSM = CSECMD                   // Clock Switching Mode bits (Clock switching is enabled,Fail-safe Clock Monitor is disabled)
23:                
24:                // FWDT
25:                #pragma config WDTPOST = PS32768                // Watchdog Timer Postscaler Bits (1:32,768)
26:                #pragma config WDTPRE = PR128                   // Watchdog Timer Prescaler bit (1:128)
27:                #pragma config PLLKEN = ON                      // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
28:                #pragma config WINDIS = OFF                     // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
29:                #pragma config FWDTEN = OFF                     // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)
30:                
31:                // FPOR
32:                #pragma config FPWRT = PWR128                   // Power-on Reset Timer Value Select bits (128ms)
33:                #pragma config BOREN = ON                       // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
34:                #pragma config ALTI2C1 = OFF                    // Alternate I2C pins for I2C1 (ASDA1/ASCK1 pins are selected as the I/O pins for I2C1)
35:                
36:                // FICD
37:                #pragma config ICS = PGD1                       // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
38:                #pragma config RSTPRI = PF                      // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
39:                #pragma config JTAGEN = OFF                     // JTAG Enable bit (JTAG is disabled)
40:                
41:                // FAS
42:                #pragma config AWRP = OFF                       // Auxiliary Segment Write-protect bit (Auxiliary program memory is not write-protected)
43:                #pragma config APL = OFF                        // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
44:                #pragma config APLK = OFF                       // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)
45:                
46:                #ifdef ENABLE_DEBUG
47:                char print_buffer[64];
48:                #endif
49:                
50:                int main(void) {
00439E  FA0000     LNK #0x0
51:                    // configure operating frequency
52:                    // system clock frequency = 64MHz
53:                    // due to 8MHz*64/(2*2)
54:                    // F_PLLI = F_IN / PPLPRE
55:                    // F_SYS = F_PPLI * PLLFBD
56:                    // F_OSC = F_SYS / PLLPOST -> crystal oscillation frequency
57:                    // F_P = F_CY = F_OSC / 2 -> operating frequency
58:                    // F_SYS OK since in range of 120 < F_SYS < 340
59:                    // F_PPLI OK since in range of 0.8 < F_PPLI < 8
60:                    PLLFBD = 62;                                // M=64
0043A0  2003E0     MOV #0x3E, W0
0043A2  883A30     MOV W0, PLLFBD
61:                    CLKDIVbits.PLLPOST = 0b00;                     // N1=2
0043A4  803A21     MOV CLKDIV, W1
0043A6  2FF3F0     MOV #0xFF3F, W0
0043A8  608000     AND W1, W0, W0
0043AA  883A20     MOV W0, CLKDIV
62:                    CLKDIVbits.PLLPRE = 0;                      // N2=2
0043AC  803A21     MOV CLKDIV, W1
0043AE  2FFE00     MOV #0xFFE0, W0
0043B0  608000     AND W1, W0, W0
0043B2  883A20     MOV W0, CLKDIV
63:                    //OSCTUN = 0;                                 // Tune FRC oscillator, if FRC is used
64:                
65:                    // Disable Watch Dog Timer
66:                    RCONbits.SWDTEN = 0;
0043B4  A9A740     BCLR RCON, #5
67:                
68:                    // Clock switch to incorporate PLL
69:                    __builtin_write_OSCCONH( 0x03 );            // Initiate Clock Switch to
0043B6  200032     MOV #0x3, W2
0043B8  200780     MOV #0x78, W0
0043BA  2009A1     MOV #0x9A, W1
0043BC  207433     MOV #0x743, W3
0043BE  784980     MOV.B W0, [W3]
0043C0  784981     MOV.B W1, [W3]
0043C2  784982     MOV.B W2, [W3]
70:                
71:                    // FRC with PLL (NOSC=0b001)
72:                    __builtin_write_OSCCONL( OSCCON || 0x01 );  // Start clock switching
0043C4  803A10     MOV OSCCON, W0
0043C6  200012     MOV #0x1, W2
0043C8  200460     MOV #0x46, W0
0043CA  200571     MOV #0x57, W1
0043CC  207423     MOV #0x742, W3
0043CE  784980     MOV.B W0, [W3]
0043D0  784981     MOV.B W1, [W3]
0043D2  784982     MOV.B W2, [W3]
73:                    while( OSCCONbits.COSC != 0b011 );
0043D4  000000     NOP
0043D6  803A11     MOV OSCCON, W1
0043D8  270000     MOV #0x7000, W0
0043DA  608080     AND W1, W0, W1
0043DC  230000     MOV #0x3000, W0
0043DE  508F80     SUB W1, W0, [W15]
0043E0  3AFFFA     BRA NZ, .L2
74:                
75:                    // Wait for Clock switch to occur
76:                    // Wait for PLL to lock
77:                    while( OSCCONbits.LOCK != 1 );
0043E2  000000     NOP
0043E4  803A11     MOV OSCCON, W1
0043E6  200200     MOV #0x20, W0
0043E8  608000     AND W1, W0, W0
0043EA  E00000     CP0 W0
0043EC  32FFFB     BRA Z, .L3
78:                
79:                    // UART serial communication (debug + print interface)
80:                #ifdef ENABLE_DEBUG
81:                    configure_serial(500000);
0043EE  2A1200     MOV #0xA120, W0
0043F0  200071     MOV #0x7, W1
0043F2  07FC81     RCALL configure_serial
82:                    
83:                    sprintf(print_buffer, "Configured UART.");
0043F4  200112     MOV #0x11, W2
0043F6  292C41     MOV #0x92C4, W1
0043F8  228400     MOV #0x2840, W0
0043FA  07E19D     RCALL _memcpy
84:                    uart_print(print_buffer, strlen(print_buffer));
0043FC  228400     MOV #0x2840, W0
0043FE  07E1A2     RCALL _strlen
004400  780080     MOV W0, W1
004402  228400     MOV #0x2840, W0
004404  07FD3D     RCALL uart_print
85:                
86:                #endif
87:                    
88:                    init_sylvatica();
004406  07F80A     RCALL init_sylvatica
89:                    
90:                    loop_sylvatica();
004408  07F8D4     RCALL loop_sylvatica
91:                    
92:                    return 0;
00440A  EB0000     CLR W0
93:                }
00440C  FA8000     ULNK
00440E  060000     RETURN
---  /home/opieters/PhD/gloxinia/src/sylvatica.X/filters.c  ---------------------------------------------
1:                 #include <dsp.h>
2:                 #include "filters.h"
3:                 #include "fir_coeffs.h"
4:                 
5:                 FIRStruct filters_0[SYLVATICA_N_CHANNELS];
6:                 FIRStruct filters_1[SYLVATICA_N_CHANNELS];
7:                 FIRStruct filters_2[SYLVATICA_N_CHANNELS];
8:                 
9:                 fractional __attribute__((space(xmemory), aligned(128),  eds)) delay_buffers_0[SYLVATICA_N_CHANNELS][N_FIR_COEFFS0];
10:                fractional __attribute__((space(xmemory), aligned(512),  eds)) delay_buffers_1[SYLVATICA_N_CHANNELS][N_FIR_COEFFS1];
11:                fractional __attribute__((space(xmemory), aligned(512),  eds)) delay_buffers_2[SYLVATICA_N_CHANNELS][N_FIR_COEFFS2];
12:                
13:                void init_filters(void){
004312  FA0002     LNK #0x2
14:                    uint16_t i;
15:                    
16:                    for(i = 0; i < SYLVATICA_N_CHANNELS; i++){
004314  EB0000     CLR W0
004316  780F00     MOV W0, [W14]
004318  37003D     BRA .L2
004392  E80F1E     INC [W14], [W14]
004394  78001E     MOV [W14], W0
004396  500FE7     SUB W0, #0x7, [W15]
004398  36FFC0     BRA LEU, .L3
17:                        FIRStructInit(&filters_0[i],  
004322  408080     ADD W1, W0, W1
004324  78001E     MOV [W14], W0
004326  B901EE     MULW.SU W0, #0xE, W2
004328  210760     MOV #0x1076, W0
00432A  410000     ADD W2, W0, W0
00432C  780201     MOV W1, W4
00432E  2FF003     MOV #0xFF00, W3
004330  2D2002     MOV #0xD200, W2
004332  200321     MOV #0x32, W1
004334  07E1D8     RCALL _FIRStructInit
18:                            N_FIR_COEFFS0,
19:                            fir_coeffs_0,
20:                            COEFFS_IN_DATA,
21:                            delay_buffers_0[i]);
00431A  228801     MOV #0x2880, W1
00431C  78011E     MOV [W14], W2
00431E  200640     MOV #0x64, W0
004320  B99080     MULW.SS W2, W0, W0
22:                        
23:                        FIRDelayInit(&filters_0[i]);
004336  78001E     MOV [W14], W0
004338  B900EE     MULW.SU W0, #0xE, W0
00433A  780080     MOV W0, W1
00433C  210760     MOV #0x1076, W0
00433E  408000     ADD W1, W0, W0
004340  07E1DF     RCALL _FIRDelayInit
24:                        
25:                        FIRStructInit(&filters_1[i],  
00434A  408080     ADD W1, W0, W1
00434C  78001E     MOV [W14], W0
00434E  B901EE     MULW.SU W0, #0xE, W2
004350  210E60     MOV #0x10E6, W0
004352  410000     ADD W2, W0, W0
004354  780201     MOV W1, W4
004356  2FF003     MOV #0xFF00, W3
004358  2D3002     MOV #0xD300, W2
00435A  200641     MOV #0x64, W1
00435C  07E1C4     RCALL _FIRStructInit
26:                            N_FIR_COEFFS1,
27:                            fir_coeffs_1,
28:                            COEFFS_IN_DATA,
29:                            delay_buffers_1[i]);
004342  222001     MOV #0x2200, W1
004344  78011E     MOV [W14], W2
004346  200C80     MOV #0xC8, W0
004348  B99080     MULW.SS W2, W0, W0
30:                        
31:                        FIRDelayInit(&filters_1[i]);
00435E  78001E     MOV [W14], W0
004360  B900EE     MULW.SU W0, #0xE, W0
004362  780080     MOV W0, W1
004364  210E60     MOV #0x10E6, W0
004366  408000     ADD W1, W0, W0
004368  07E1CB     RCALL _FIRDelayInit
32:                        
33:                        FIRStructInit(&filters_2[i],  
004372  408080     ADD W1, W0, W1
004374  78001E     MOV [W14], W0
004376  B901EE     MULW.SU W0, #0xE, W2
004378  211560     MOV #0x1156, W0
00437A  410000     ADD W2, W0, W0
00437C  780201     MOV W1, W4
00437E  2FF003     MOV #0xFF00, W3
004380  2D4002     MOV #0xD400, W2
004382  200FA1     MOV #0xFA, W1
004384  07E1B0     RCALL _FIRStructInit
34:                            N_FIR_COEFFS2,
35:                            fir_coeffs_2,
36:                            COEFFS_IN_DATA,
37:                            delay_buffers_2[i]);
00436A  212001     MOV #0x1200, W1
00436C  78011E     MOV [W14], W2
00436E  201F40     MOV #0x1F4, W0
004370  B99080     MULW.SS W2, W0, W0
38:                        
39:                        FIRDelayInit(&filters_2[i]);
004386  78001E     MOV [W14], W0
004388  B900EE     MULW.SU W0, #0xE, W0
00438A  780080     MOV W0, W1
00438C  211560     MOV #0x1156, W0
00438E  408000     ADD W1, W0, W0
004390  07E1B7     RCALL _FIRDelayInit
40:                    }
41:                }
00439A  FA8000     ULNK
00439C  060000     RETURN
---  /home/opieters/PhD/gloxinia/src/lib/utilities.c  ---------------------------------------------------
1:                 /*
2:                  * File:   utilities.c
3:                  * Author: opieters
4:                  *
5:                  * Created on September 19, 2018, 3:30 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include <utilities.h>
11:                
12:                volatile uint8_t continue_startup = 0;
13:                
14:                char print_buffer[PRINT_BUFFER_LENGTH];
15:                
16:                static pin_t blinky_pin;
17:                
18:                static int coefficient = 20;
19:                void function2() 
20:                {
00417C  FA0000     LNK #0x0
21:                    coefficient++;
00417E  808380     MOV 0x1070, W0
004180  E80000     INC W0, W0
004182  888380     MOV W0, 0x1070
22:                }
004184  FA8000     ULNK
004186  060000     RETURN
23:                
24:                void delay_us(uint16_t delay){ //delay x us
004188  FA0002     LNK #0x2
00418A  780F00     MOV W0, [W14]
25:                    while(delay--) {
00418C  370002     BRA .L3
004192  78001E     MOV [W14], W0
004194  A7F000     BTSC W0, #15
004196  EA0000     NEG W0, W0
004198  EA0000     NEG W0, W0
00419A  DE004F     LSR W0, #15, W0
00419C  784000     MOV.B W0, W0
00419E  E90F1E     DEC [W14], [W14]
0041A0  E00400     CP0.B W0
0041A2  3AFFF5     BRA NZ, .L4
26:                        __asm__ volatile ("repeat #63");
00418E  09003F     REPEAT #0x3F
27:                        __asm__ volatile ("nop");
004190  000000     NOP
28:                    }
29:                }
0041A4  FA8000     ULNK
0041A6  060000     RETURN
30:                
31:                void delay_ms(uint16_t delay){
0041A8  FA0002     LNK #0x2
0041AA  780F00     MOV W0, [W14]
32:                    while(delay--) {
0041AC  370002     BRA .L6
0041B2  78001E     MOV [W14], W0
0041B4  A7F000     BTSC W0, #15
0041B6  EA0000     NEG W0, W0
0041B8  EA0000     NEG W0, W0
0041BA  DE004F     LSR W0, #15, W0
0041BC  784000     MOV.B W0, W0
0041BE  E90F1E     DEC [W14], [W14]
0041C0  E00400     CP0.B W0
0041C2  3AFFF5     BRA NZ, .L7
33:                        delay_us(1000);
0041AE  203E80     MOV #0x3E8, W0
0041B0  07FFEB     RCALL delay_us
34:                    }
35:                }
0041C4  FA8000     ULNK
0041C6  060000     RETURN
36:                
37:                void init_blinky(pin_t* pin, short timer_on){
0041C8  FA0004     LNK #0x4
0041CA  780F00     MOV W0, [W14]
0041CC  980711     MOV W1, [W14+2]
38:                    
39:                    blinky_pin = *pin;
0041CE  210640     MOV #0x1064, W0
0041D0  78009E     MOV [W14], W1
0041D2  780211     MOV [W1], W4
0041D4  900291     MOV [W1+2], W5
0041D6  900321     MOV [W1+4], W6
0041D8  9003B1     MOV [W1+6], W7
0041DA  BE9804     MOV.D W4, [W0++]
0041DC  BE9006     MOV.D W6, [W0--]
40:                    
41:                    CLEAR_BIT(blinky_pin.tris_r, blinky_pin.n);
0041DE  210640     MOV #0x1064, W0
0041E0  900110     MOV [W0+2], W2
0041E2  210640     MOV #0x1064, W0
0041E4  900010     MOV [W0+2], W0
0041E6  780190     MOV [W0], W3
0041E8  210640     MOV #0x1064, W0
0041EA  904060     MOV.B [W0+6], W0
0041EC  FB8200     ZE W0, W4
0041EE  200010     MOV #0x1, W0
0041F0  200001     MOV #0x0, W1
0041F2  780284     MOV W4, W5
0041F4  E90285     DEC W5, W5
0041F6  330003     BRA N, .LE98
0041F8  400000     ADD W0, W0, W0
0041FA  488081     ADDC W1, W1, W1
0041FC  37FFFB     BRA .LB98
0041FE  780000     MOV W0, W0
004200  EA8000     COM W0, W0
004202  618000     AND W3, W0, W0
004204  780900     MOV W0, [W2]
42:                    CLEAR_BIT(blinky_pin.port_r, blinky_pin.n);
004206  210640     MOV #0x1064, W0
004208  780110     MOV [W0], W2
00420A  210640     MOV #0x1064, W0
00420C  780010     MOV [W0], W0
00420E  780190     MOV [W0], W3
004210  210640     MOV #0x1064, W0
004212  904060     MOV.B [W0+6], W0
004214  FB8200     ZE W0, W4
004216  200010     MOV #0x1, W0
004218  200001     MOV #0x0, W1
00421A  780304     MOV W4, W6
00421C  E90306     DEC W6, W6
00421E  330003     BRA N, .LE113
004220  400000     ADD W0, W0, W0
004222  488081     ADDC W1, W1, W1
004224  37FFFB     BRA .LB113
004226  780000     MOV W0, W0
004228  EA8000     COM W0, W0
00422A  618000     AND W3, W0, W0
00422C  780900     MOV W0, [W2]
43:                    
44:                    if(timer_on == 1){
00422E  90001E     MOV [W14+2], W0
004230  500FE1     SUB W0, #0x1, [W15]
004232  3A000D     BRA NZ, .L8
45:                        T1CONbits.TON = 0; 
004234  A9E105     BCLR 0x105, #7
46:                
47:                        T1CONbits.TCS = 0; // use internal instruction cycle as clock source
004236  A92104     BCLR T1CON, #1
48:                        T1CONbits.TGATE = 0; // disable gated timer
004238  A9C104     BCLR T1CON, #6
49:                        T1CONbits.TCKPS = 0b11; // prescaler 1:256
00423A  800821     MOV T1CON, W1
00423C  200300     MOV #0x30, W0
00423E  700001     IOR W0, W1, W0
004240  880820     MOV W0, T1CON
50:                        TMR1 = 0; // clear timer register
004242  EF2100     CLR TMR1
51:                
52:                        PR1 = 0xFFFF;
004244  EB8000     SETM W0
004246  880810     MOV W0, PR1
53:                
54:                        _T1IF = 0; // clear interrupt flag
004248  A96800     BCLR IFS0, #3
55:                        _T1IE = 1; // enable interrupt
00424A  A86820     BSET IEC0, #3
56:                
57:                        T1CONbits.TON = 1;
00424C  A8E105     BSET 0x105, #7
58:                    }
59:                }
00424E  FA8000     ULNK
004250  060000     RETURN
60:                
61:                void toggle_led(void){
004252  FA0000     LNK #0x0
62:                    TOGGLE_BIT(blinky_pin.lat_r, blinky_pin.n);
004254  210640     MOV #0x1064, W0
004256  900120     MOV [W0+4], W2
004258  210640     MOV #0x1064, W0
00425A  900020     MOV [W0+4], W0
00425C  780190     MOV [W0], W3
00425E  210640     MOV #0x1064, W0
004260  904060     MOV.B [W0+6], W0
004262  FB8200     ZE W0, W4
004264  200010     MOV #0x1, W0
004266  200001     MOV #0x0, W1
004268  780284     MOV W4, W5
00426A  E90285     DEC W5, W5
00426C  330003     BRA N, .LE159
00426E  400000     ADD W0, W0, W0
004270  488081     ADDC W1, W1, W1
004272  37FFFB     BRA .LB159
004274  780000     MOV W0, W0
004276  698000     XOR W3, W0, W0
004278  780900     MOV W0, [W2]
63:                }
00427A  FA8000     ULNK
00427C  060000     RETURN
64:                
65:                void __attribute__ ( (__interrupt__, no_auto_psv) ) _T1Interrupt( void ){
00049E  BE9F80     MOV.D W0, [W15++]
0004A0  BE9F82     MOV.D W2, [W15++]
0004A2  BE9F84     MOV.D W4, [W15++]
0004A4  FA0000     LNK #0x0
66:                    TOGGLE_BIT(blinky_pin.lat_r, blinky_pin.n);
0004A6  210640     MOV #0x1064, W0
0004A8  900120     MOV [W0+4], W2
0004AA  210640     MOV #0x1064, W0
0004AC  900020     MOV [W0+4], W0
0004AE  780190     MOV [W0], W3
0004B0  210640     MOV #0x1064, W0
0004B2  904060     MOV.B [W0+6], W0
0004B4  FB8200     ZE W0, W4
0004B6  200010     MOV #0x1, W0
0004B8  200001     MOV #0x0, W1
0004BA  780284     MOV W4, W5
0004BC  E90285     DEC W5, W5
0004BE  330003     BRA N, .LE188
0004C0  400000     ADD W0, W0, W0
0004C2  488081     ADDC W1, W1, W1
0004C4  37FFFB     BRA .LB188
0004C6  780000     MOV W0, W0
0004C8  698000     XOR W3, W0, W0
0004CA  780900     MOV W0, [W2]
67:                    _T1IF = 0;
0004CC  A96800     BCLR IFS0, #3
68:                }
0004CE  FA8000     ULNK
0004D0  BE024F     MOV.D [--W15], W4
0004D2  BE014F     MOV.D [--W15], W2
0004D4  BE004F     MOV.D [--W15], W0
0004D6  064000     RETFIE
---  /home/opieters/PhD/gloxinia/src/lib/uart.c  --------------------------------------------------------
1:                 #include <uart.h>
2:                 #include <stdint.h>
3:                 //#include <can.h>
4:                 
5:                 //#include <sensors.h>
6:                 #include <utilities.h>
7:                 //#include <sample.h>
8:                 
9:                 #ifdef HW_C_DICIO_REV2
10:                #include <address.h>
11:                #endif
12:                
13:                
14:                // *****************************************************************************
15:                // *****************************************************************************
16:                // Section: File Scope or Global Constants
17:                // *****************************************************************************
18:                // *****************************************************************************
19:                
20:                #define UART_RX_BUFFER_SIZE 4
21:                
22:                volatile uint8_t n_uart_rx_messages = 0;
23:                volatile uint8_t uart_rx_read_idx = 0;  // current or previous read index
24:                
25:                uart_message_t uart_rx_queue[UART_RX_BUFFER_SIZE];
26:                
27:                uart_message_t* uart_queue[UART_MESSAGE_BUFFER_LENGTH];
28:                uint8_t uart_rx_buffer[UART_RX_BUFFER_SIZE][UART_BUFFER_LENGTH] __attribute__( (space(xmemory)) );
29:                
30:                
31:                
32:                volatile uint8_t n_uart_messages = 0;
33:                volatile uint8_t uart_queue_idx = 0;
34:                volatile uint8_t uart_queue_valid = 0;
35:                volatile uint8_t uart_ongoing = 0;
36:                
37:                
38:                uint8_t uart_dma_message_data[128];
39:                
40:                volatile uint8_t uart_rx_state = 0;
41:                volatile uint8_t uart_rx_idx = 0;
42:                
43:                uart_message_t uart_print_message;
44:                uint8_t uart_print_message_data[128];
45:                uart_message_t uart_command_message;
46:                uint8_t uart_command_message_data[UART_MESSAGE_BUFFER_LENGTH];
47:                
48:                uint8_t uart_id = 0;
49:                
50:                void configure_serial( uint32_t baudrate ) { 
003CF6  FA0006     LNK #0x6
003CF8  980710     MOV W0, [W14+2]
003CFA  980721     MOV W1, [W14+4]
51:                
52:                #ifdef ENABLE_DEBUG
53:                    unsigned int i;
54:                #endif
55:                    
56:                    uart_command_message.status = uart_message_sent;
003CFC  200020     MOV #0x2, W0
003CFE  8A4A30     MOV W0, 0x4946
57:                    uart_print_message.status = uart_message_sent;
003D00  200020     MOV #0x2, W0
003D02  8A45D0     MOV W0, 0x48BA
58:                    
59:                #ifdef ENABLE_DEBUG
60:                    U2MODEbits.STSEL = 0;   // 1-stop bit
003D04  A90230     BCLR U2MODE, #0
61:                    U2MODEbits.PDSEL = 0;   // No Parity, 8-data bits
003D06  801181     MOV U2MODE, W1
003D08  2FFF90     MOV #0xFFF9, W0
003D0A  608000     AND W1, W0, W0
003D0C  881180     MOV W0, U2MODE
62:                    U2MODEbits.ABAUD = 0;   // Autobaud Disabled
003D0E  A9A230     BCLR U2MODE, #5
63:                    U2MODEbits.BRGH = 0; // 16x mode (16 clock cycles per data bit)
003D10  A96230     BCLR U2MODE, #3
64:                    U2MODEbits.RTSMD = 0;    // DTE-DTE mode
003D12  A96231     BCLR 0x231, #3
65:                    U2MODEbits.URXINV = 0;
003D14  A98230     BCLR U2MODE, #4
66:                    U2BRG = ( (FCY / baudrate) / 16 ) - 1;         // BAUD Rate Setting for 9600
003D16  90011E     MOV [W14+2], W2
003D18  9001AE     MOV [W14+4], W3
003D1A  209000     MOV #0x900, W0
003D1C  2003D1     MOV #0x3D, W1
003D1E  07E4FB     RCALL ___udivsi3
003D20  780000     MOV W0, W0
003D22  E90000     DEC W0, W0
003D24  8811C0     MOV W0, U2BRG
67:                    
68:                    
69:                    #ifdef HW_C_PLANALTA_REV1
70:                    U2MODEbits.UEN   = 0b00; // do not use flow control
71:                    #else
72:                    U2MODEbits.UEN   = 0b10; // use flow control: nU2CTS as input, nU2RTS as output
003D26  801181     MOV U2MODE, W1
003D28  2FCFF0     MOV #0xFCFF, W0
003D2A  608000     AND W1, W0, W0
003D2C  A09000     BSET W0, #9
003D2E  881180     MOV W0, U2MODE
73:                    #endif
74:                    
75:                    //  Configure UART for DMA transfers
76:                    U2STAbits.UTXISEL0 = 0; // Interrupt after one Tx character is transmitted
003D30  A9A233     BCLR 0x233, #5
77:                    U2STAbits.UTXISEL1 = 0;
003D32  A9E233     BCLR 0x233, #7
78:                    U2STAbits.URXISEL = 0;  // Interrupt after one RX character is received
003D34  801191     MOV U2STA, W1
003D36  2FF3F0     MOV #0xFF3F, W0
003D38  608000     AND W1, W0, W0
003D3A  881190     MOV W0, U2STA
79:                    U2STAbits.TXINV = 0;
003D3C  A9C233     BCLR 0x233, #6
80:                    
81:                    //  Enable UART Rx and Tx
82:                    U2MODEbits.UARTEN = 1;  // Enable UART
003D3E  A8E231     BSET 0x231, #7
83:                    U2STAbits.UTXEN = 1;    // Enable UART Tx
003D40  A84233     BSET 0x233, #2
84:                    
85:                    //configure pins
86:                    //RPINR19 = 0b0011000; // connect UART2 RX to pin RPI24
87:                #ifdef HW_C_BURCHELLII_REV1
88:                    _U2RXR = 83;                    // connect U2RX to RPI83
89:                    _RP84R = _RPOUT_U2TX;  // connect RP36 to UART2 TX
90:                    _U2CTSR = 97;                   // connect U2CTS to RPI97
91:                    _RP80R = _RPOUT_U2RTS; // connect PR80 to UART2 RTS       
92:                #elif defined(HW_C_DICIO_REV2)
93:                    _TRISB4 = 1;
94:                    _TRISG8 = 0;
95:                    _RP120R = _RPOUT_U2TX;   //RF5 as U2TX
96:                    _U2RXR = 36;           //RF4 as U2RX
97:                #elif defined(HW_C_SYLVATICA_REV1)
98:                    _U2RXR = 74;                    // connect U2RX to RPI74
003D42  803631     MOV RPINR19, W1
003D44  2FF800     MOV #0xFF80, W0
003D46  608080     AND W1, W0, W1
003D48  2004A0     MOV #0x4A, W0
003D4A  700001     IOR W0, W1, W0
003D4C  883630     MOV W0, RPINR19
99:                    _RP102R = _RPOUT_U2TX;  // connect RP102 to UART2 TX
003D4E  8034A1     MOV RPOR10, W1
003D50  2FFC00     MOV #0xFFC0, W0
003D52  608000     AND W1, W0, W0
003D54  B30030     IOR #0x3, W0
003D56  8834A0     MOV W0, RPOR10
100:                   _U2CTSR = 73;                   // connect U2CTS to RPI73
003D58  803631     MOV RPINR19, W1
003D5A  280FF0     MOV #0x80FF, W0
003D5C  608080     AND W1, W0, W1
003D5E  249000     MOV #0x4900, W0
003D60  700001     IOR W0, W1, W0
003D62  883630     MOV W0, RPINR19
101:                   _RP98R = _RPOUT_U2RTS; // connect PR98 to UART2 RTS    
003D64  803481     MOV RPOR8, W1
003D66  2FFC00     MOV #0xFFC0, W0
003D68  608000     AND W1, W0, W0
003D6A  A02000     BSET W0, #2
003D6C  883480     MOV W0, RPOR8
102:               #elif defined(HW_C_PLANALTA_REV1)
103:                   _U2RXR = 83;                    // connect U2RX to RPI74
104:                   _RP82R = _RPOUT_U2TX;  // connect RP102 to UART2 TX 
105:               #else
106:               #error "Hardware configuration not supported."
107:               #endif
108:                   
109:                   // clear error bit, do not enable error interrupt
110:                   _U2EIF = 0;
003D6E  A94808     BCLR IFS4, #2
111:                   _U2EIE = 0;
003D70  A94828     BCLR IEC4, #2
112:                   
113:                   // only enable RX interrupt
114:                   _U2RXIE = 1;
003D72  A8C823     BSET 0x823, #6
115:                   _U2TXIE = 0;
003D74  A9E823     BCLR 0x823, #7
116:                   
117:                   // enable UART RX and TX
118:                   U2MODEbits.UARTEN = 1;  // Enable UART
003D76  A8E231     BSET 0x231, #7
119:                   U2STAbits.UTXEN = 1;    // Enable UART Tx
003D78  A84233     BSET 0x233, #2
120:                   
121:                   // wait for at least one baud period to continue
122:                   delay_us(2 * (FCY / baudrate));
003D7A  90011E     MOV [W14+2], W2
003D7C  9001AE     MOV [W14+4], W3
003D7E  290000     MOV #0x9000, W0
003D80  203D01     MOV #0x3D0, W1
003D82  07E4C9     RCALL ___udivsi3
003D84  780000     MOV W0, W0
003D86  400000     ADD W0, W0, W0
003D88  0701FF     RCALL delay_us
123:                   
124:                   DMA14CONbits.DIR = 1; // RAM-to-Peripheral
003D8A  A8ABE1     BSET 0xBE1, #5
125:                   DMA14CONbits.SIZE = 1; // byte transfer mode
003D8C  A8CBE1     BSET 0xBE1, #6
126:                   DMA14CONbits.MODE = 0b01; // One-Shot, Ping-Pong modes disabled
003D8E  805F01     MOV DMA14CON, W1
003D90  2FFFC0     MOV #0xFFFC, W0
003D92  608000     AND W1, W0, W0
003D94  A00000     BSET W0, #0
003D96  885F00     MOV W0, DMA14CON
127:                   DMA14CNT = 0;              // number of  DMA requests
003D98  EF2BEE     CLR DMA14CNT
128:                   DMA14REQ = 0x001F;         // Select UART2 transmitter
003D9A  2001F0     MOV #0x1F, W0
003D9C  885F10     MOV W0, DMA14REQ
129:                   DMA14PAD = (volatile unsigned int) &U2TXREG;
003D9E  202340     MOV #0x234, W0
003DA0  885F60     MOV W0, DMA14PAD
130:                   _DMA14IF = 0;      // Clear DMA Interrupt Flag
003DA2  A98810     BCLR IFS8, #4
131:                   _DMA14IE = 1;      // Enable DMA interrupt
003DA4  A88830     BSET IEC8, #4
132:                   
133:                   DMA14STAL = (uint16_t) uart_dma_message_data;
003DA6  248300     MOV #0x4830, W0
003DA8  885F20     MOV W0, DMA14STAL
134:                   DMA14STAH = 0x0;
003DAA  EF2BE6     CLR DMA14STAH
135:                   
136:               #ifdef __LOG__
137:                   sprintf(print_buffer, "Initialised UART module.");
138:                   uart_print(print_buffer, strlen(print_buffer));
139:               #endif
140:                   for(i = 0; i < UART_RX_BUFFER_SIZE; i++){
003DAC  EB0000     CLR W0
003DAE  780F00     MOV W0, [W14]
003DB0  370011     BRA .L2
003DD2  E80F1E     INC [W14], [W14]
003DD4  78001E     MOV [W14], W0
003DD6  500FE3     SUB W0, #0x3, [W15]
003DD8  36FFEC     BRA LEU, .L3
141:                       uart_rx_queue[i].status = uart_message_none;
003DB2  78001E     MOV [W14], W0
003DB4  B900EC     MULW.SU W0, #0xC, W0
003DB6  780080     MOV W0, W1
003DB8  2470A0     MOV #0x470A, W0
003DBA  408000     ADD W1, W0, W0
003DBC  200041     MOV #0x4, W1
003DBE  780801     MOV W1, [W0]
142:                       uart_rx_queue[i].data = uart_rx_buffer[i];
003DC0  22BA01     MOV #0x2BA0, W1
003DC2  78001E     MOV [W14], W0
003DC4  DD0047     SL W0, #7, W0
003DC6  408080     ADD W1, W0, W1
003DC8  78001E     MOV [W14], W0
003DCA  B901EC     MULW.SU W0, #0xC, W2
003DCC  247080     MOV #0x4708, W0
003DCE  410000     ADD W2, W0, W0
003DD0  780801     MOV W1, [W0]
143:                   }
144:                   
145:               #endif
146:                   
147:                   
148:                   init_uart_message(&uart_print_message, 
003DDA  BFD060     MOV.B uart_id, WREG
003DDC  EB4280     CLR.B W5
003DDE  248BC4     MOV #0x48BC, W4
003DE0  EB0180     CLR W3
003DE2  784100     MOV.B W0, W2
003DE4  200061     MOV #0x6, W1
003DE6  248B00     MOV #0x48B0, W0
003DE8  0700F8     RCALL init_uart_message
149:                           uart_text_message_cmd,
150:                           uart_id,
151:                           0,            
152:                           uart_print_message_data,
153:                           0);
154:               }
003DEA  FA8000     ULNK
003DEC  060000     RETURN
155:               
156:               
157:               void __attribute__ ( (interrupt, no_auto_psv) ) _U2ErrInterrupt( void )
158:               {
00032A  FA0000     LNK #0x0
159:                   _U2EIF = 0;                 // Clear the UART2 Error Interrupt Flag
00032C  A94808     BCLR IFS4, #2
160:               }
00032E  FA8000     ULNK
000330  064000     RETFIE
161:               
162:               void __attribute__ ( (interrupt, no_auto_psv) ) _U2RXInterrupt( void ) {
000332  BE9F80     MOV.D W0, [W15++]
000334  BE9F88     MOV.D W8, [W15++]
000336  FA0000     LNK #0x0
163:                   
164:                   register uint8_t rx_value = U2RXREG;
000338  8011B0     MOV U2RXREG, W0
00033A  784480     MOV.B W0, W9
165:                   register uart_message_t* m = &(uart_rx_queue[(n_uart_rx_messages+uart_rx_read_idx) % UART_RX_BUFFER_SIZE]); // TODO: more efficient?
00033C  BFD058     MOV.B n_uart_rx_messages, WREG
00033E  FB8080     ZE W0, W1
000340  BFD059     MOV.B uart_rx_read_idx, WREG
000342  FB8000     ZE W0, W0
000344  408000     ADD W1, W0, W0
000346  600063     AND W0, #0x3, W0
000348  B900EC     MULW.SU W0, #0xC, W0
00034A  780080     MOV W0, W1
00034C  247000     MOV #0x4700, W0
00034E  408400     ADD W1, W0, W8
166:                   
167:                   if((n_uart_rx_messages == UART_RX_BUFFER_SIZE) && m->status != uart_message_none){
000350  BFD058     MOV.B n_uart_rx_messages, WREG
000352  504FE4     SUB.B W0, #0x4, [W15]
000354  3A0004     BRA NZ, .L6
000356  900058     MOV [W8+10], W0
000358  500FE4     SUB W0, #0x4, [W15]
00035A  320001     BRA Z, .L6
168:                       _U2RXIF = 0;
00035C  A9C803     BCLR 0x803, #6
169:                   }
170:                   
171:                   
172:               
173:                   switch(uart_rx_state){
00035E  BFD05E     MOV.B uart_rx_state, WREG
000360  FB8000     ZE W0, W0
000362  500FE3     SUB W0, #0x3, [W15]
000364  32002B     BRA Z, .L11
000366  500FE3     SUB W0, #0x3, [W15]
000368  3C0007     BRA GT, .L16
00036A  500FE1     SUB W0, #0x1, [W15]
00036C  320013     BRA Z, .L9
00036E  500FE1     SUB W0, #0x1, [W15]
000370  3C0021     BRA GT, .L10
000372  E00000     CP0 W0
000374  32000A     BRA Z, .L8
000376  37005D     BRA .L7
000378  500FE5     SUB W0, #0x5, [W15]
00037A  32002D     BRA Z, .L13
00037C  500FE5     SUB W0, #0x5, [W15]
00037E  350023     BRA LT, .L12
000380  500FE6     SUB W0, #0x6, [W15]
000382  320033     BRA Z, .L14
000384  500FE7     SUB W0, #0x7, [W15]
000386  320046     BRA Z, .L15
000388  370054     BRA .L7
174:                       case 0:
175:                           if(rx_value==UART_CMD_START){
00038A  54CFE1     SUB.B W9, #0x1, [W15]
00038C  3A0054     BRA NZ, .L28
176:                               uart_rx_state = 1;
00038E  B3C010     MOV.B #0x1, W0
000390  B7F05E     MOV.B WREG, uart_rx_state
177:                           }
178:                           break;
000392  370054     BRA .L18
000436  000000     NOP
000438  370001     BRA .L18
179:                       case 1:
180:                           m->command = rx_value;
000394  FB8009     ZE W9, W0
000396  780C00     MOV W0, [W8]
181:                           m->status = uart_message_transferring;
000398  200010     MOV #0x1, W0
00039A  980450     MOV W0, [W8+10]
182:                           
183:                           if(rx_value < n_serial_cmd) {
00039C  54CFF2     SUB.B W9, #0x12, [W15]
00039E  3E0003     BRA GTU, .L19
184:                               uart_rx_state = 2;
0003A0  B3C020     MOV.B #0x2, W0
0003A2  B7F05E     MOV.B WREG, uart_rx_state
185:                           } else {
186:                               uart_rx_state = 0;
0003A6  EF705E     CLR.B uart_rx_state
187:                               m->status = uart_message_error;
0003A8  200030     MOV #0x3, W0
0003AA  980450     MOV W0, [W8+10]
188:                               n_uart_rx_messages++;
0003AC  BFD058     MOV.B n_uart_rx_messages, WREG
0003AE  E84000     INC.B W0, W0
0003B0  B7F058     MOV.B WREG, n_uart_rx_messages
189:                           }
190:                           
191:                           break;
0003A4  37004B     BRA .L18
0003B2  370044     BRA .L18
192:                       case 2:
193:                           m->id = rx_value;
0003B4  984429     MOV.B W9, [W8+2]
194:                           uart_rx_state = 3;
0003B6  B3C030     MOV.B #0x3, W0
0003B8  B7F05E     MOV.B WREG, uart_rx_state
195:                           
196:                           break;
0003BA  370040     BRA .L18
197:                       case 3:
198:                           m->extended_id = rx_value;
0003BC  FB8009     ZE W9, W0
0003BE  980420     MOV W0, [W8+4]
199:                           uart_rx_state = 4;
0003C0  B3C040     MOV.B #0x4, W0
0003C2  B7F05E     MOV.B WREG, uart_rx_state
200:                           
201:                           break;
0003C4  37003B     BRA .L18
202:                       case 4:
203:                           m->extended_id = (m->extended_id << 8) + rx_value;
0003C6  900028     MOV [W8+4], W0
0003C8  DD00C8     SL W0, #8, W1
0003CA  FB8009     ZE W9, W0
0003CC  408000     ADD W1, W0, W0
0003CE  980420     MOV W0, [W8+4]
204:                           uart_rx_state = 5;
0003D0  B3C050     MOV.B #0x5, W0
0003D2  B7F05E     MOV.B WREG, uart_rx_state
205:                           break;
0003D4  370033     BRA .L18
206:                       case 5:
207:                           m->length = rx_value;
0003D6  984469     MOV.B W9, [W8+6]
208:                           if(rx_value > 0){
0003D8  E00409     CP0.B W9
0003DA  320004     BRA Z, .L21
209:                               uart_rx_state = 6;
0003DC  B3C060     MOV.B #0x6, W0
0003DE  B7F05E     MOV.B WREG, uart_rx_state
210:                               uart_rx_idx = 0;
0003E0  EF705F     CLR.B uart_rx_idx
211:                           } else {
212:                               uart_rx_state = 7;
0003E4  B3C070     MOV.B #0x7, W0
0003E6  B7F05E     MOV.B WREG, uart_rx_state
213:                           }
214:                           
215:                           break;
0003E2  37002C     BRA .L18
0003E8  370029     BRA .L18
216:                       case 6:
217:                           // only write data until buffer is full
218:                           if(uart_rx_idx < UART_BUFFER_LENGTH){
0003EA  BFD05F     MOV.B uart_rx_idx, WREG
0003EC  E00400     CP0.B W0
0003EE  350006     BRA LT, .L23
219:                               m->data[uart_rx_idx] = rx_value;
0003F0  9000C8     MOV [W8+8], W1
0003F2  BFD05F     MOV.B uart_rx_idx, WREG
0003F4  FB8000     ZE W0, W0
0003F6  408000     ADD W1, W0, W0
0003F8  784809     MOV.B W9, [W0]
0003FA  370002     BRA .L24
220:                           } else {
221:                               // continue reading data, but indicate error occurred
222:                               m->status = uart_message_error;
0003FC  200030     MOV #0x3, W0
0003FE  980450     MOV W0, [W8+10]
223:                           }
224:                           
225:                           uart_rx_idx++;
000400  BFD05F     MOV.B uart_rx_idx, WREG
000402  E84000     INC.B W0, W0
000404  B7F05F     MOV.B WREG, uart_rx_idx
226:                           
227:                           if(uart_rx_idx == m->length){
000406  9040E8     MOV.B [W8+6], W1
000408  BFD05F     MOV.B uart_rx_idx, WREG
00040A  50CF80     SUB.B W1, W0, [W15]
00040C  3A0016     BRA NZ, .L29
228:                               uart_rx_state = 7;
00040E  B3C070     MOV.B #0x7, W0
000410  B7F05E     MOV.B WREG, uart_rx_state
229:                           }
230:                           
231:                           break;
000412  370014     BRA .L18
00043A  000000     NOP
232:                       case 7:
233:                           if(rx_value == UART_CMD_STOP){
000414  54CFE4     SUB.B W9, #0x4, [W15]
000416  3A0006     BRA NZ, .L26
234:                               if(m->status != uart_message_error){
000418  900058     MOV [W8+10], W0
00041A  500FE3     SUB W0, #0x3, [W15]
00041C  320005     BRA Z, .L27
235:                                   m->status = uart_message_received;
00041E  200050     MOV #0x5, W0
000420  980450     MOV W0, [W8+10]
000422  370002     BRA .L27
236:                               }
237:                           } else {
238:                               m->status = uart_message_error;
000424  200030     MOV #0x3, W0
000426  980450     MOV W0, [W8+10]
239:                           }
240:                           
241:                           n_uart_rx_messages++;
000428  BFD058     MOV.B n_uart_rx_messages, WREG
00042A  E84000     INC.B W0, W0
00042C  B7F058     MOV.B WREG, n_uart_rx_messages
242:                           uart_rx_state = 0;
00042E  EF705E     CLR.B uart_rx_state
243:               
244:                           break;
000430  370005     BRA .L18
245:                       default:
246:                           uart_rx_state = 0;
000432  EF705E     CLR.B uart_rx_state
000434  370003     BRA .L18
247:                   }
248:                   _U2RXIF = 0;
00043C  A9C803     BCLR 0x803, #6
249:               }
00043E  FA8000     ULNK
000440  BE044F     MOV.D [--W15], W8
000442  BE004F     MOV.D [--W15], W0
000444  064000     RETFIE
250:               
251:               void __attribute__ ( (interrupt, no_auto_psv) ) _U2TXInterrupt( void ) {
000446  FA0000     LNK #0x0
252:                   _U2TXIF = 0;
000448  A9E803     BCLR 0x803, #7
253:               }
00044A  FA8000     ULNK
00044C  064000     RETFIE
254:               
255:               inline void process_uart_rx_command(){
003DEE  FA0000     LNK #0x0
256:                   /*can_message_t can_m;
257:                   uint8_t can_data[8];
258:                   uart_rx_message_t m = uart_rx_queue[uart_rx_read_idx];
259:                   
260:                   uart_rx_read_idx = (uart_rx_read_idx + 1) % UART_RX_BUFFER_SIZE;
261:                   
262:                   if(m.status != uart_message_received){
263:                       n_uart_rx_messages--;
264:                       return;
265:                       // TODO: handle errors over here
266:                   }
267:                   
268:                   can_m.identifier = controller_address | CAN_CHANNEL_STATUS;
269:                   can_m.extended_frame = 0;
270:                   can_m.remote_frame = 0;
271:                   can_m.data = can_data;
272:                   
273:                   switch(m.command){
274:                       case uart_start_measurement_cmd:
275:                           can_m.data_length = 1;
276:                           can_data[0] = can_info_cmd_start_measurement;
277:                           send_can_message_any_channel(&can_m);
278:                           delay_ms(1);
279:               #ifdef __LOG__
280:                           sprintf(print_buffer, "Sampling...");
281:                           uart_print(print_buffer, strlen(print_buffer));
282:               #endif
283:                           //start_sampling();
284:                           break;
285:                       case uart_stop_measurement_cmd:
286:                           //stop_sampling();
287:                           delay_us(100);
288:                           
289:                           can_m.data_length = 1;
290:                           can_data[0] = can_info_cmd_stop_measurement;
291:                           send_can_message_any_channel(&can_m);
292:                           break;
293:                       case uart_activate_sensor_cmd:
294:                           can_m.data_length = 2;
295:                           can_data[0] = can_info_cmd_sensor_status;
296:                           can_data[1] = 1;
297:                           send_can_message_any_channel(&can_m);
298:                           break;
299:                       case uart_deactivate_sensor_cmd:
300:                           can_m.data_length = 2;
301:                           can_data[0] = can_info_cmd_sensor_status;
302:                           can_data[1] = 0;
303:                           send_can_message_any_channel(&can_m);
304:                           break;
305:                       case uart_reset_node_cmd:
306:                           if(m.length == 1){
307:                               if(m.data[0] == controller_address){
308:                                   asm ("RESET");
309:                               } else {
310:                                   can_m.data_length = 2;
311:                                   can_data[0] = can_info_cmd_reset;
312:                                   can_data[1] = m.data[0];
313:                                   send_can_message_any_channel(&can_m);
314:                               }
315:                           }
316:                           break;
317:                       case uart_reset_system_cmd:   
318:               #ifdef __LOG__
319:                           sprintf(print_buffer, "Resetting system...");
320:                           uart_print(print_buffer, strlen(print_buffer));
321:               #endif
322:                           // send reset message to other nodes
323:                           can_m.data_length = 1;
324:                           can_data[0] = can_info_cmd_reset;
325:                           while(send_can_message_any_channel(&can_m) != CAN_NO_ERROR);
326:                           
327:                           while(C1TR01CONbits.TXREQ0 == 1);
328:                           while(C1TR01CONbits.TXREQ1 == 1);
329:                           while(C1TR23CONbits.TXREQ2 == 1);
330:                           while(C1TR23CONbits.TXREQ3 == 1);
331:                           while(C1TR45CONbits.TXREQ4 == 1);
332:                           while(C1TR45CONbits.TXREQ5 == 1);
333:                           while(C1TR67CONbits.TXREQ6 == 1);
334:                           while(C1TR67CONbits.TXREQ7 == 1);
335:                           
336:                           delay_us(100);
337:                           
338:                           asm ("RESET");
339:                           
340:                           break;
341:                       case uart_text_message_cmd:
342:                           // this message can only be sent to the computer
343:                           break;
344:                       case uart_sensor_data_cmd:
345:                           // this message can only be sent to the computer
346:                           break;
347:                       case uart_sensor_status_cmd:
348:                           // this message can only be sent to the computer
349:                           break;
350:                       case uart_measurement_period_cmd:
351:                           if(m.length == 5){
352:                               uint8_t prescaler, i;
353:                               uint32_t timer_period = 0;
354:                                   
355:                               for(i = 0; i < 4; i++){
356:                                   timer_period = (timer_period << 8) | m.data[i];
357:                               }
358:                               prescaler = m.data[4] & 0b11;
359:                               
360:                               // TODO: add support for measurement period alterations
361:                               //set_sample_period(timer_period, prescaler);
362:                           }
363:                           break;
364:                       case uart_error_message_cmd:
365:                           // this message can only be sent to the computer
366:                           break;
367:                       case uart_loopback_message_cmd:
368:                           tx_uart_command(uart_loopback_message_cmd, 0, 0, m.data, m.length);
369:                           break;
370:                       case uart_hello_message_cmd:
371:               #ifdef __LOG__
372:                           sprintf(print_buffer, "Broadcasting hello message...");
373:                           uart_print(print_buffer, strlen(print_buffer));
374:               #endif
375:                           
376:                           // prepare data contents
377:                           can_m.data_length = 1;
378:                           can_data[0] = can_info_cmd_hello;
379:                           
380:                           // broadcast over bus
381:                           send_can_message_any_channel(&can_m);
382:                           break;
383:                       case uart_init_sampling_cmd:
384:               #ifdef __LOG__
385:                           sprintf(print_buffer, "Initialising sampling event.");
386:                           uart_print(print_buffer, strlen(print_buffer));
387:               #endif
388:                           //init_sampling();
389:                           break;
390:                       case uart_init_sensors_cmd:
391:                           can_m.data_length = 1;
392:                           can_data[0] = can_info_cmd_init_sensors;
393:                           
394:                           send_can_message_any_channel(&can_m);
395:                           break;
396:                       case uart_lia_gain_setting:
397:                           can_m.data_length = 4;
398:                           can_data[0] = can_info_lia_gain_setting;
399:                           can_data[1] = m.data[0];
400:                           can_data[2] = m.data[1];
401:                           can_data[3] = m.data[2];
402:                           
403:                           send_can_message_any_channel(&can_m);
404:                           break;
405:                       default:
406:                           break;
407:                   }
408:                   
409:                   m.status = uart_message_none;
410:                   
411:                   n_uart_rx_messages--;*/
412:               }
003DF0  FA8000     ULNK
003DF2  060000     RETURN
413:               
414:               inline void tx_uart_command(serial_cmd_t command, uint8_t address, uint16_t extended_id, uint8_t* data, uint8_t data_length){
003DF4  FA000C     LNK #0xC
003DF6  980710     MOV W0, [W14+2]
003DF8  984741     MOV.B W1, [W14+4]
003DFA  980732     MOV W2, [W14+6]
003DFC  980743     MOV W3, [W14+8]
003DFE  984F24     MOV.B W4, [W14+10]
415:               #ifdef ENABLE_DEBUG
416:                   uint16_t i;
417:                   
418:                   while(uart_command_message.status != uart_message_sent);
003E00  000000     NOP
003E02  824A30     MOV 0x4946, W0
003E04  500FE2     SUB W0, #0x2, [W15]
003E06  3AFFFD     BRA NZ, .L33
419:                   
420:                   uart_command_message_data[0] = UART_CMD_START;
003E08  249480     MOV #0x4948, W0
003E0A  B3C011     MOV.B #0x1, W1
003E0C  784801     MOV.B W1, [W0]
421:                   uart_command_message_data[1] = command;
003E0E  90001E     MOV [W14+2], W0
003E10  784080     MOV.B W0, W1
003E12  249490     MOV #0x4949, W0
003E14  784801     MOV.B W1, [W0]
422:                   uart_command_message_data[2] = (uint8_t) address;
003E16  2494A0     MOV #0x494A, W0
003E18  9040CE     MOV.B [W14+4], W1
003E1A  784801     MOV.B W1, [W0]
423:                   uart_command_message_data[3] = (uint8_t) (extended_id >> 8);
003E1C  90003E     MOV [W14+6], W0
003E1E  DE0048     LSR W0, #8, W0
003E20  784080     MOV.B W0, W1
003E22  2494B0     MOV #0x494B, W0
003E24  784801     MOV.B W1, [W0]
424:                   uart_command_message_data[4] = (uint8_t) extended_id;
003E26  90003E     MOV [W14+6], W0
003E28  784080     MOV.B W0, W1
003E2A  2494C0     MOV #0x494C, W0
003E2C  784801     MOV.B W1, [W0]
425:                   uart_command_message_data[5] = (uint8_t) data_length;
003E2E  2494D0     MOV #0x494D, W0
003E30  9048AE     MOV.B [W14+10], W1
003E32  784801     MOV.B W1, [W0]
426:                   for(i = 0; i < data_length; i++){
003E34  EB0000     CLR W0
003E36  780F00     MOV W0, [W14]
003E38  370009     BRA .L34
003E4A  E80F1E     INC [W14], [W14]
003E4C  90482E     MOV.B [W14+10], W0
003E4E  FB8000     ZE W0, W0
003E50  500F9E     SUB W0, [W14], [W15]
003E52  3EFFF3     BRA GTU, .L35
427:                       uart_command_message_data[i + 6] = (uint8_t) data[i];
003E3A  78009E     MOV [W14], W1
003E3C  408066     ADD W1, #0x6, W0
003E3E  9000CE     MOV [W14+8], W1
003E40  40809E     ADD W1, [W14], W1
003E42  784091     MOV.B [W1], W1
003E44  249482     MOV #0x4948, W2
003E46  410000     ADD W2, W0, W0
003E48  784801     MOV.B W1, [W0]
428:                   }
429:                   uart_command_message_data[data_length + 6] = UART_CMD_STOP;
003E54  90482E     MOV.B [W14+10], W0
003E56  FB8000     ZE W0, W0
003E58  400066     ADD W0, #0x6, W0
003E5A  249481     MOV #0x4948, W1
003E5C  408000     ADD W1, W0, W0
003E5E  B3C041     MOV.B #0x4, W1
003E60  784801     MOV.B W1, [W0]
430:                   uart_command_message.length = data_length + 6 + 1;
003E62  90482E     MOV.B [W14+10], W0
003E64  4040E7     ADD.B W0, #0x7, W1
003E66  249420     MOV #0x4942, W0
003E68  784801     MOV.B W1, [W0]
431:                   uart_command_message.data = uart_command_message_data;
003E6A  249480     MOV #0x4948, W0
003E6C  8A4A20     MOV W0, 0x4944
432:                   
433:                   // TODO: this function!!!
434:                   //queue_uart_raw_message(&uart_command_message);
435:                   
436:               #endif
437:               }
003E6E  FA8000     ULNK
003E70  060000     RETURN
438:               
439:               void uart_wait(){
003E72  FA0000     LNK #0x0
440:               #ifdef ENABLE_DEBUG
441:                   while(uart_print_message.status != uart_message_sent);
003E74  000000     NOP
003E76  8245D0     MOV 0x48BA, W0
003E78  500FE2     SUB W0, #0x2, [W15]
003E7A  3AFFFD     BRA NZ, .L37
442:               #endif
443:               }
003E7C  FA8000     ULNK
003E7E  060000     RETURN
444:               
445:               void uart_print(const char* message, uint16_t length){
003E80  FA0006     LNK #0x6
003E82  980710     MOV W0, [W14+2]
003E84  980721     MOV W1, [W14+4]
446:               #ifdef ENABLE_DEBUG
447:                   
448:                   uint16_t i;
449:                   
450:                   while(uart_print_message.status != uart_message_sent);
003E86  000000     NOP
003E88  8245D0     MOV 0x48BA, W0
003E8A  500FE2     SUB W0, #0x2, [W15]
003E8C  3AFFFD     BRA NZ, .L39
451:                   
452:                   uart_print_message.length = length;
003E8E  90002E     MOV [W14+4], W0
003E90  784080     MOV.B W0, W1
003E92  248B60     MOV #0x48B6, W0
003E94  784801     MOV.B W1, [W0]
453:                   for(i = 0; i < length; i++){
003E96  EB0000     CLR W0
003E98  780F00     MOV W0, [W14]
003E9A  370007     BRA .L40
003EA8  E80F1E     INC [W14], [W14]
003EAA  90002E     MOV [W14+4], W0
003EAC  78009E     MOV [W14], W1
003EAE  508F80     SUB W1, W0, [W15]
003EB0  39FFF5     BRA NC, .L41
454:                       uart_print_message.data[i] = message[i];
003E9C  8245C0     MOV 0x48B8, W0
003E9E  40001E     ADD W0, [W14], W0
003EA0  90009E     MOV [W14+2], W1
003EA2  40809E     ADD W1, [W14], W1
003EA4  784091     MOV.B [W1], W1
003EA6  784801     MOV.B W1, [W0]
455:                   }
456:                  
457:                   queue_uart_message(&uart_print_message);
003EB2  248B00     MOV #0x48B0, W0
003EB4  07002F     RCALL queue_uart_message
458:                   
459:                   while(uart_print_message.status != uart_message_sent);
003EB6  000000     NOP
003EB8  8245D0     MOV 0x48BA, W0
003EBA  500FE2     SUB W0, #0x2, [W15]
003EBC  3AFFFD     BRA NZ, .L42
460:               #endif
461:               }
003EBE  FA8000     ULNK
003EC0  060000     RETURN
462:               
463:               void process_uart_queue(void){
003EC2  FA0002     LNK #0x2
464:                   uart_message_t* m;
465:                   
466:                   if((uart_ongoing == 0) && (uart_queue_idx != uart_queue_valid)){
003EC4  BFD05D     MOV.B uart_ongoing, WREG
003EC6  E00400     CP0.B W0
003EC8  3A0023     BRA NZ, .L43
003ECA  2105B1     MOV #0x105B, W1
003ECC  784091     MOV.B [W1], W1
003ECE  BFD05C     MOV.B uart_queue_valid, WREG
003ED0  50CF80     SUB.B W1, W0, [W15]
003ED2  32001E     BRA Z, .L43
467:                       // copy to actual message to transmit
468:                       
469:                       uart_ongoing = 1;
003ED4  B3C010     MOV.B #0x1, W0
003ED6  B7F05D     MOV.B WREG, uart_ongoing
470:                       
471:                       // start transmission of message
472:                       m = uart_queue[uart_queue_valid];
003ED8  BFD05C     MOV.B uart_queue_valid, WREG
003EDA  FB8000     ZE W0, W0
003EDC  400080     ADD W0, W0, W1
003EDE  247300     MOV #0x4730, W0
003EE0  408000     ADD W1, W0, W0
003EE2  780F10     MOV [W0], [W14]
473:                       
474:                       uart_parse_to_buffer(uart_dma_message_data, m);
003EE4  78009E     MOV [W14], W1
003EE6  248300     MOV #0x4830, W0
003EE8  070039     RCALL uart_parse_to_buffer
475:                   
476:                       while(U2STAbits.TRMT == 0);
003EEA  000000     NOP
003EEC  801191     MOV U2STA, W1
003EEE  201000     MOV #0x100, W0
003EF0  608000     AND W1, W0, W0
003EF2  E00000     CP0 W0
003EF4  32FFFB     BRA Z, .L45
477:               
478:                       m->status = uart_message_transferring;
003EF6  78001E     MOV [W14], W0
003EF8  200011     MOV #0x1, W1
003EFA  980051     MOV W1, [W0+10]
479:                       DMA14STAL = (uint16_t) uart_dma_message_data;
003EFC  248300     MOV #0x4830, W0
003EFE  885F20     MOV W0, DMA14STAL
480:                       DMA14STAH = 0x0;
003F00  EF2BE6     CLR DMA14STAH
481:                       DMA14CNT = UART_HEADER_SIZE + (m->length) - 1;
003F02  78001E     MOV [W14], W0
003F04  904060     MOV.B [W0+6], W0
003F06  FB8000     ZE W0, W0
003F08  400066     ADD W0, #0x6, W0
003F0A  885F70     MOV W0, DMA14CNT
482:                       
483:                       // start transfer 
484:                       DMA14CONbits.CHEN = 1;
003F0C  A8EBE1     BSET 0xBE1, #7
485:                       DMA14REQbits.FORCE = 1;
003F0E  A8EBE3     BSET 0xBE3, #7
486:                   }
487:               }
003F10  FA8000     ULNK
003F12  060000     RETURN
488:               
489:               void queue_uart_message(uart_message_t* m){
003F14  FA0002     LNK #0x2
003F16  780F00     MOV W0, [W14]
490:                   // wait for space in the queue
491:                   while(n_uart_messages == UART_MESSAGE_BUFFER_LENGTH);
003F18  000000     NOP
003F1A  2105A1     MOV #0x105A, W1
003F1C  784091     MOV.B [W1], W1
003F1E  B3C800     MOV.B #0x80, W0
003F20  50CF80     SUB.B W1, W0, [W15]
003F22  32FFFB     BRA Z, .L47
492:                   
493:                   // queue message
494:                   m->status = uart_message_queued;
003F24  78001E     MOV [W14], W0
003F26  EB0080     CLR W1
003F28  980051     MOV W1, [W0+10]
495:                   uart_queue[uart_queue_idx] = m;
003F2A  BFD05B     MOV.B uart_queue_idx, WREG
003F2C  FB8000     ZE W0, W0
003F2E  400080     ADD W0, W0, W1
003F30  247300     MOV #0x4730, W0
003F32  408000     ADD W1, W0, W0
003F34  78081E     MOV [W14], [W0]
496:                   uart_queue_idx = (uart_queue_idx + 1) % UART_MESSAGE_BUFFER_LENGTH;
003F36  BFD05B     MOV.B uart_queue_idx, WREG
003F38  FB8000     ZE W0, W0
003F3A  E80080     INC W0, W1
003F3C  2807F0     MOV #0x807F, W0
003F3E  608000     AND W1, W0, W0
003F40  E00000     CP0 W0
003F42  3D0004     BRA GE, .L48
003F44  E90000     DEC W0, W0
003F46  2FF801     MOV #0xFF80, W1
003F48  708000     IOR W1, W0, W0
003F4A  E80000     INC W0, W0
003F4C  784000     MOV.B W0, W0
003F4E  B7F05B     MOV.B WREG, uart_queue_idx
497:                   n_uart_messages++;
003F50  BFD05A     MOV.B n_uart_messages, WREG
003F52  E84000     INC.B W0, W0
003F54  B7F05A     MOV.B WREG, n_uart_messages
498:                   
499:                   process_uart_queue();
003F56  07FFB5     RCALL process_uart_queue
500:               }
003F58  FA8000     ULNK
003F5A  060000     RETURN
501:               
502:               
503:               void __attribute__((__interrupt__,no_auto_psv)) _DMA14Interrupt(void){
00044E  F80036     PUSH RCOUNT
000450  BE9F80     MOV.D W0, [W15++]
000452  BE9F82     MOV.D W2, [W15++]
000454  BE9F84     MOV.D W4, [W15++]
000456  BE9F86     MOV.D W6, [W15++]
000458  FA0000     LNK #0x0
504:                   // finish the current transfer
505:                   uart_queue[uart_queue_valid]->status = uart_message_sent;
00045A  BFD05C     MOV.B uart_queue_valid, WREG
00045C  FB8000     ZE W0, W0
00045E  400080     ADD W0, W0, W1
000460  247300     MOV #0x4730, W0
000462  408000     ADD W1, W0, W0
000464  780010     MOV [W0], W0
000466  200021     MOV #0x2, W1
000468  980051     MOV W1, [W0+10]
506:                   uart_queue_valid = (uart_queue_valid + 1) % UART_MESSAGE_BUFFER_LENGTH;
00046A  BFD05C     MOV.B uart_queue_valid, WREG
00046C  FB8000     ZE W0, W0
00046E  E80080     INC W0, W1
000470  2807F0     MOV #0x807F, W0
000472  608000     AND W1, W0, W0
000474  E00000     CP0 W0
000476  3D0004     BRA GE, .L50
000478  E90000     DEC W0, W0
00047A  2FF801     MOV #0xFF80, W1
00047C  708000     IOR W1, W0, W0
00047E  E80000     INC W0, W0
000480  784000     MOV.B W0, W0
000482  B7F05C     MOV.B WREG, uart_queue_valid
507:                   n_uart_messages--;    
000484  BFD05A     MOV.B n_uart_messages, WREG
000486  E94000     DEC.B W0, W0
000488  B7F05A     MOV.B WREG, n_uart_messages
508:                   
509:                   // check if another message is available
510:                   uart_ongoing = 0;
00048A  EF705D     CLR.B uart_ongoing
511:                   process_uart_queue();
00048C  071D1A     RCALL process_uart_queue
512:                   
513:                   _DMA14IF = 0;   // Clear the DMA0 Interrupt Flag
00048E  A98810     BCLR IFS8, #4
514:               }
000490  FA8000     ULNK
000492  BE034F     MOV.D [--W15], W6
000494  BE024F     MOV.D [--W15], W4
000496  BE014F     MOV.D [--W15], W2
000498  BE004F     MOV.D [--W15], W0
00049A  F90036     POP RCOUNT
00049C  064000     RETFIE
515:               
516:               
517:               
518:               
519:               
520:               void uart_parse_to_buffer(uint8_t* data, uart_message_t* m){
003F5C  FA0006     LNK #0x6
003F5E  980710     MOV W0, [W14+2]
003F60  980721     MOV W1, [W14+4]
521:                   uint16_t i;
522:                   
523:                   data[0] = UART_CMD_START;
003F62  90001E     MOV [W14+2], W0
003F64  B3C011     MOV.B #0x1, W1
003F66  784801     MOV.B W1, [W0]
524:                   data[1] = (uint16_t) m->command;
003F68  90001E     MOV [W14+2], W0
003F6A  E80000     INC W0, W0
003F6C  9000AE     MOV [W14+4], W1
003F6E  780091     MOV [W1], W1
003F70  784081     MOV.B W1, W1
003F72  784801     MOV.B W1, [W0]
525:                   data[2] = m->id;
003F74  90001E     MOV [W14+2], W0
003F76  E88000     INC2 W0, W0
003F78  9000AE     MOV [W14+4], W1
003F7A  9040A1     MOV.B [W1+2], W1
003F7C  784801     MOV.B W1, [W0]
526:                   data[3] = (uint8_t) (m->extended_id >> 8);
003F7E  90001E     MOV [W14+2], W0
003F80  400063     ADD W0, #0x3, W0
003F82  9000AE     MOV [W14+4], W1
003F84  9000A1     MOV [W1+4], W1
003F86  DE08C8     LSR W1, #8, W1
003F88  784081     MOV.B W1, W1
003F8A  784801     MOV.B W1, [W0]
527:                   data[4] = (uint8_t) m->extended_id;
003F8C  90001E     MOV [W14+2], W0
003F8E  400064     ADD W0, #0x4, W0
003F90  9000AE     MOV [W14+4], W1
003F92  9000A1     MOV [W1+4], W1
003F94  784081     MOV.B W1, W1
003F96  784801     MOV.B W1, [W0]
528:                   data[5] = (uint8_t) m->length;
003F98  90001E     MOV [W14+2], W0
003F9A  400065     ADD W0, #0x5, W0
003F9C  9000AE     MOV [W14+4], W1
003F9E  9040E1     MOV.B [W1+6], W1
003FA0  784801     MOV.B W1, [W0]
529:                   for(i = 0; i < m->length; i++){
003FA2  EB0000     CLR W0
003FA4  780F00     MOV W0, [W14]
003FA6  37000A     BRA .L52
003FBA  E80F1E     INC [W14], [W14]
003FBC  90002E     MOV [W14+4], W0
003FBE  904060     MOV.B [W0+6], W0
003FC0  FB8000     ZE W0, W0
003FC2  500F9E     SUB W0, [W14], [W15]
003FC4  3EFFF1     BRA GTU, .L53
530:                       data[6+i] = m->data[i];
003FA8  78009E     MOV [W14], W1
003FAA  408066     ADD W1, #0x6, W0
003FAC  90009E     MOV [W14+2], W1
003FAE  408000     ADD W1, W0, W0
003FB0  9000AE     MOV [W14+4], W1
003FB2  9000C1     MOV [W1+8], W1
003FB4  40809E     ADD W1, [W14], W1
003FB6  784091     MOV.B [W1], W1
003FB8  784801     MOV.B W1, [W0]
531:                   }
532:                   data[6+m->length] = UART_CMD_STOP;
003FC6  90002E     MOV [W14+4], W0
003FC8  904060     MOV.B [W0+6], W0
003FCA  FB8000     ZE W0, W0
003FCC  400066     ADD W0, #0x6, W0
003FCE  90009E     MOV [W14+2], W1
003FD0  408000     ADD W1, W0, W0
003FD2  B3C041     MOV.B #0x4, W1
003FD4  784801     MOV.B W1, [W0]
533:               }
003FD6  FA8000     ULNK
003FD8  060000     RETURN
534:               
535:               void init_uart_message(uart_message_t* m, 
536:                       serial_cmd_t command,
537:                       uint8_t id,
538:                       uint16_t extended_id,            
539:                       uint8_t* data,
540:                       uint8_t length){
003FDA  FA000C     LNK #0xC
003FDC  780F00     MOV W0, [W14]
003FDE  980711     MOV W1, [W14+2]
003FE0  984742     MOV.B W2, [W14+4]
003FE2  980733     MOV W3, [W14+6]
003FE4  980744     MOV W4, [W14+8]
003FE6  984F25     MOV.B W5, [W14+10]
541:                   m->command = command;
003FE8  78001E     MOV [W14], W0
003FEA  90009E     MOV [W14+2], W1
003FEC  780801     MOV W1, [W0]
542:                   m->data = data;
003FEE  78001E     MOV [W14], W0
003FF0  9000CE     MOV [W14+8], W1
003FF2  980041     MOV W1, [W0+8]
543:                   m->id = id;
003FF4  78001E     MOV [W14], W0
003FF6  9040CE     MOV.B [W14+4], W1
003FF8  984021     MOV.B W1, [W0+2]
544:                   m->extended_id = extended_id;
003FFA  78001E     MOV [W14], W0
003FFC  9000BE     MOV [W14+6], W1
003FFE  980021     MOV W1, [W0+4]
545:                   m->length = length;
004000  78001E     MOV [W14], W0
004002  9048AE     MOV.B [W14+10], W1
004004  984061     MOV.B W1, [W0+6]
546:               }
004006  FA8000     ULNK
004008  060000     RETURN
---  /home/opieters/PhD/gloxinia/src/lib/spi.c  ---------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <spi.h>
3:                 #include <utilities.h>
4:                 #include <uart.h>
5:                 
6:                 uint8_t spi_transfer_done = 1;
7:                 uint8_t spi_transfer_status = 0;
8:                 
9:                 void init_spi1(void){
00225A  FA0000     LNK #0x0
10:                #ifdef __DEBUG__
11:                    sprintf(print_buffer, "Initialising SPI 1.");
12:                    uart_print(print_buffer, strlen(print_buffer));
13:                #endif
14:                    
15:                #ifdef HW_C_BURCHELLII_REV1
16:                    _SDI1R = 67;          // connect U2RX to RPI83
17:                    _SCK1R = 65;          // connect RP36 to UART2 TX
18:                    _SS1R = 98;           // connect U2CTS to RPI97
19:                    _RP66R = _RPOUT_SDO1; // connect PR80 to UART2 RTS 
20:                #elif defined(HW_C_DICIO_REV2) 
21:                    _TRISB14 = 1; // SDI1 pin is input
22:                    _TRISF3 = 0;  // SDO1 pin is output
23:                    _TRISF6 = 0;  // SCK1 pin is output
24:                    
25:                    // configure peripheral connections
26:                    _SDI1R = 45;                  // connect SDI1 to RPI45
27:                    _RP99R = _RPOUT_SDO1;   // connect RP99 to SDO1
28:                    _RP102R = _RPOUT_SCK1;
29:                #elif defined(HW_C_SYLVATICA_REV1)
30:                #else
31:                #error "Hardware configuration not supported."
32:                #endif
33:                    
34:                    _SPI1IF = 0; // clear interrupt flag
00225C  A94801     BCLR 0x801, #2
35:                    _SPI1IE = 0; // disable SPI interrupt
00225E  A94821     BCLR 0x821, #2
36:                    
37:                    // SPI1CON1 Register Settings
38:                    SPI1CON1bits.MODE16 = 1;  // communication is word-wide (16 bits)
002260  A84243     BSET 0x243, #2
39:                    SPI1CON1bits.MSTEN = 1;   // Master mode enabled
002262  A8A242     BSET SPI1CON1, #5
40:                    SPI1CON1bits.DISSCK = 0;  // internal serial clock enabled
002264  A98243     BCLR 0x243, #4
41:                    SPI1CON1bits.DISSDO = 0;  // SDO1 pin is controlled by module
002266  A96243     BCLR 0x243, #3
42:                    SPI1CON1bits.CKP = 0;     // idle state for clock is low level
002268  A9C242     BCLR SPI1CON1, #6
43:                    SPI1CON1bits.CKE = 1;
00226A  A80243     BSET 0x243, #0
44:                    SPI1CON1bits.SSEN = 0;    // slave select pin is controlled by software
00226C  A9E242     BCLR SPI1CON1, #7
45:                    SPI1CON1bits.PPRE = 0b01;
00226E  801211     MOV SPI1CON1, W1
002270  2FFFC0     MOV #0xFFFC, W0
002272  608000     AND W1, W0, W0
002274  A00000     BSET W0, #0
002276  881210     MOV W0, SPI1CON1
46:                    delay_ms(100);
002278  200640     MOV #0x64, W0
00227A  070F96     RCALL delay_ms
47:                    SPI1CON1bits.SPRE = 0b111; //0b111;
00227C  801210     MOV SPI1CON1, W0
00227E  B301C0     IOR #0x1C, W0
002280  881210     MOV W0, SPI1CON1
48:                    
49:                    // SPI1CON2 Register Settings
50:                    /*SPI1CON2bits.FRMEN = 0;   // framed mode enabled
51:                    SPI1CON2bits.FRMPOL = 1;  // pulse is high
52:                    SPI1CON2bits.SPIFSD = 0;
53:                    SPI1CON2bits.FRMDLY = 0;
54:                    SPI1CON2bits.SPIBEN = 0;*/
55:                   
56:                    //SPI1STATbits.SPISIDL = 0; // continue module operation in Idle mode
57:                    SPI1STATbits.SPIBEC = 0;  // buffer Length = 1 Word
002282  801201     MOV SPI1STAT, W1
002284  2F8FF0     MOV #0xF8FF, W0
002286  608000     AND W1, W0, W0
002288  881200     MOV W0, SPI1STAT
58:                    SPI1STATbits.SPIROV = 0;  // no Receive Overflow has occurred
00228A  A9C240     BCLR SPI1STAT, #6
59:                    SPI1STATbits.SPIEN = 1;   // enable SPI module
00228C  A8E241     BSET 0x241, #7
60:                    
61:                    _SPI1IF = 0; // clear interrupt flag
00228E  A94801     BCLR 0x801, #2
62:                    _SPI1IE = 1; // enable SPI interrupt
002290  A84821     BSET 0x821, #2
63:                    
64:                    spi_transfer_status = 0;
002292  EF706C     CLR.B spi_transfer_status
65:                    spi_transfer_done = 1;
002294  B3C010     MOV.B #0x1, W0
002296  B7F074     MOV.B WREG, 0x1074
66:                }
002298  FA8000     ULNK
00229A  060000     RETURN
67:                
68:                void init_spi3(void){
00229C  FA0000     LNK #0x0
69:                    _SPI3IF = 0; // clear interrupt flag
00229E  A9680B     BCLR 0x80B, #3
70:                    _SPI3IE = 0; // disable SPI interrupt
0022A0  A9682B     BCLR 0x82B, #3
71:                    
72:                    // SPI1CON1 Register Settings
73:                    SPI3CON1bits.MODE16 = 1;  // communication is word-wide (16 bits)
0022A2  A842A3     BSET 0x2A3, #2
74:                    SPI3CON1bits.MSTEN = 1;   // Master mode enabled
0022A4  A8A2A2     BSET SPI3CON1, #5
75:                    SPI3CON1bits.DISSCK = 0;  // internal serial clock enabled
0022A6  A982A3     BCLR 0x2A3, #4
76:                    SPI3CON1bits.DISSDO = 0;  // SDO1 pin is controlled by module
0022A8  A962A3     BCLR 0x2A3, #3
77:                    SPI3CON1bits.SMP = 0;     // data is sampled at centre of conversion (falling edge)
0022AA  A922A3     BCLR 0x2A3, #1
78:                    SPI3CON1bits.CKP = 0;     // idle state for clock is low level
0022AC  A9C2A2     BCLR SPI3CON1, #6
79:                    SPI3CON1bits.CKE = 0;     // data changes on transition from idle to active state (rising edge here)
0022AE  A902A3     BCLR 0x2A3, #0
80:                    SPI3CON1bits.SSEN = 0;    // slave select pin is controlled by software
0022B0  A9E2A2     BCLR SPI3CON1, #7
81:                    SPI3CON1bits.PPRE = 0b00;
0022B2  801511     MOV SPI3CON1, W1
0022B4  2FFFC0     MOV #0xFFFC, W0
0022B6  608000     AND W1, W0, W0
0022B8  881510     MOV W0, SPI3CON1
82:                    delay_ms(100);
0022BA  200640     MOV #0x64, W0
0022BC  070F75     RCALL delay_ms
83:                    SPI3CON1bits.SPRE = 0b100; //0b111;
0022BE  801511     MOV SPI3CON1, W1
0022C0  2FFE30     MOV #0xFFE3, W0
0022C2  608000     AND W1, W0, W0
0022C4  A04000     BSET W0, #4
0022C6  881510     MOV W0, SPI3CON1
84:                    
85:                   
86:                    //SPI1STATbits.SPISIDL = 0; // continue module operation in Idle mode
87:                    SPI3STATbits.SPIBEC = 0;  // buffer Length = 1 Word
0022C8  801501     MOV SPI3STAT, W1
0022CA  2F8FF0     MOV #0xF8FF, W0
0022CC  608000     AND W1, W0, W0
0022CE  881500     MOV W0, SPI3STAT
88:                    SPI3STATbits.SPIROV = 0;  // no Receive Overflow has occurred
0022D0  A9C2A0     BCLR SPI3STAT, #6
89:                    SPI3STATbits.SPIEN = 1;   // enable SPI module
0022D2  A8E2A1     BSET 0x2A1, #7
90:                    
91:                    _SPI3IF = 0; // clear interrupt flag
0022D4  A9680B     BCLR 0x80B, #3
92:                    _SPI3IE = 1; // enable SPI interrupt
0022D6  A8682B     BSET 0x82B, #3
93:                    
94:                    spi_transfer_status = 0;
0022D8  EF706C     CLR.B spi_transfer_status
95:                    spi_transfer_done = 1;
0022DA  B3C010     MOV.B #0x1, W0
0022DC  B7F074     MOV.B WREG, 0x1074
96:                }
0022DE  FA8000     ULNK
0022E0  060000     RETURN
97:                
98:                
99:                void init_spi2(void){
0022E2  FA0000     LNK #0x0
100:               #ifdef HW_C_BURCHELLII_REV1
101:                   _TRISG6 = 0; // SCK2 is output
102:                   _TRISG7 = 1; // SDI2 is input
103:                   _TRISG8 = 0; // SDO2 is output
104:                   
105:                   _ANSG6 = 0;
106:                   _ANSG7 = 0;
107:                   _ANSG8 = 0;
108:               #elif defined(HW_C_DICIO_REV2)
109:                   // TODO
110:               #else 
111:               
112:               #endif
113:                   
114:                   _SPI2IF = 0; // clear interrupt flag
0022E4  A92804     BCLR IFS2, #1
115:                   _SPI2IE = 0; // disable SPI interrupt
0022E6  A92824     BCLR IEC2, #1
116:                   
117:                   // SPI2CON1 Register Settings
118:                   SPI2CON1bits.MODE16 = 1;  // communication is word-wide (16 bits)
0022E8  A84263     BSET 0x263, #2
119:                   SPI2CON1bits.MSTEN = 1;   // Master mode enabled
0022EA  A8A262     BSET SPI2CON1, #5
120:                   SPI2CON1bits.DISSCK = 0;  // internal serial clock enabled
0022EC  A98263     BCLR 0x263, #4
121:                   SPI2CON1bits.DISSDO = 0;  // SDO1 pin is controlled by module
0022EE  A96263     BCLR 0x263, #3
122:                   SPI2CON1bits.CKP = 0;     // idle state for clock is low level
0022F0  A9C262     BCLR SPI2CON1, #6
123:                   SPI2CON1bits.CKE = 1;     // data is shifted out on active to idle transition
0022F2  A80263     BSET 0x263, #0
124:                   SPI2CON1bits.SSEN = 0;    // slave select pin is controlled by software
0022F4  A9E262     BCLR SPI2CON1, #7
125:                   SPI2CON1bits.PPRE = 0b11;
0022F6  801310     MOV SPI2CON1, W0
0022F8  B30030     IOR #0x3, W0
0022FA  881310     MOV W0, SPI2CON1
126:                   delay_us(100);
0022FC  200640     MOV #0x64, W0
0022FE  070F44     RCALL delay_us
127:                   SPI2CON1bits.SPRE = 0b000;
002300  801311     MOV SPI2CON1, W1
002302  2FFE30     MOV #0xFFE3, W0
002304  608000     AND W1, W0, W0
002306  881310     MOV W0, SPI2CON1
128:                   
129:                   SPI2STATbits.SPIBEC = 0;  // buffer Length = 1 Word
002308  801301     MOV SPI2STAT, W1
00230A  2F8FF0     MOV #0xF8FF, W0
00230C  608000     AND W1, W0, W0
00230E  881300     MOV W0, SPI2STAT
130:                   SPI2STATbits.SPIROV = 0;  // no Receive Overflow has occurred
002310  A9C260     BCLR SPI2STAT, #6
131:                   SPI2STATbits.SPIEN = 1;   // enable SPI module
002312  A8E261     BSET 0x261, #7
132:                   //SPI2STATbits.SISEL = 0b101; // interrupt when last data bit is transmitted
133:                   
134:                   _SPI2IF = 0; // clear interrupt flag
002314  A92804     BCLR IFS2, #1
135:                   _SPI2IE = 0; // enable SPI interrupt
002316  A92824     BCLR IEC2, #1
136:                   
137:                   spi_transfer_status = 0;
002318  EF706C     CLR.B spi_transfer_status
138:                   spi_transfer_done = 1;
00231A  B3C010     MOV.B #0x1, W0
00231C  B7F074     MOV.B WREG, 0x1074
139:               }
00231E  FA8000     ULNK
002320  060000     RETURN
140:               
141:               void __attribute__((__interrupt__, no_auto_psv)) _SPI1Interrupt(void){
000518  781F80     MOV W0, [W15++]
00051A  FA0000     LNK #0x0
142:                   spi_transfer_done = 1;
00051C  B3C010     MOV.B #0x1, W0
00051E  B7F074     MOV.B WREG, 0x1074
143:                   _SPI1IF = 0;
000520  A94801     BCLR 0x801, #2
144:               }
000522  FA8000     ULNK
000524  78004F     MOV [--W15], W0
000526  064000     RETFIE
145:               
146:               void __attribute__((__interrupt__, no_auto_psv)) _SPI2Interrupt(void){
000528  781F80     MOV W0, [W15++]
00052A  FA0000     LNK #0x0
147:                   spi_transfer_done = 1;
00052C  B3C010     MOV.B #0x1, W0
00052E  B7F074     MOV.B WREG, 0x1074
148:                   _SPI2IF = 0;
000530  A92804     BCLR IFS2, #1
149:               }
000532  FA8000     ULNK
000534  78004F     MOV [--W15], W0
000536  064000     RETFIE
150:               
151:               void __attribute__((__interrupt__, no_auto_psv)) _SPI3Interrupt(void){
000538  781F80     MOV W0, [W15++]
00053A  FA0000     LNK #0x0
152:                   spi_transfer_done = 1;
00053C  B3C010     MOV.B #0x1, W0
00053E  B7F074     MOV.B WREG, 0x1074
153:                   _SPI3IF = 0;
000540  A9680B     BCLR 0x80B, #3
154:               }
000542  FA8000     ULNK
000544  78004F     MOV [--W15], W0
000546  064000     RETFIE
155:               
156:               void send_spi1_message(spi_message_t* m){
002322  FA0002     LNK #0x2
002324  780F00     MOV W0, [W14]
157:                   static uint8_t n_transfers;
158:                   
159:                   while(m->status != SPI_TRANSFER_DONE){
002326  370070     BRA .L8
002408  78001E     MOV [W14], W0
00240A  900070     MOV [W0+14], W0
00240C  500FE1     SUB W0, #0x1, [W15]
00240E  3AFF8C     BRA NZ, .L20
160:                           switch(spi_transfer_status){
002328  BFD06C     MOV.B spi_transfer_status, WREG
00232A  FB8000     ZE W0, W0
00232C  500FE1     SUB W0, #0x1, [W15]
00232E  32002C     BRA Z, .L11
002330  500FE1     SUB W0, #0x1, [W15]
002332  3C0003     BRA GT, .L14
002334  E00000     CP0 W0
002336  320006     BRA Z, .L10
002338  370065     BRA .L9
00233A  500FE2     SUB W0, #0x2, [W15]
00233C  320030     BRA Z, .L21
00233E  500FE3     SUB W0, #0x3, [W15]
002340  320049     BRA Z, .L13
002342  370060     BRA .L9
161:                               case 0:
162:                                   if(m->data_length > 0){
002344  78001E     MOV [W14], W0
002346  904040     MOV.B [W0+4], W0
002348  E00400     CP0.B W0
00234A  32001B     BRA Z, .L15
163:                                       n_transfers = 0;
00234C  EF706E     CLR.B n_transfers
164:                                       m->status = SPI_TRANSFER_ONGOING;
00234E  78001E     MOV [W14], W0
002350  200021     MOV #0x2, W1
002352  980071     MOV W1, [W0+14]
165:                                       spi_transfer_status = 1;
002354  B3C010     MOV.B #0x1, W0
002356  B7F06C     MOV.B WREG, spi_transfer_status
166:                                       CLEAR_BIT(m->cs_pin.lat_r, m->cs_pin.n);
002358  78001E     MOV [W14], W0
00235A  900150     MOV [W0+10], W2
00235C  78001E     MOV [W14], W0
00235E  900050     MOV [W0+10], W0
002360  780190     MOV [W0], W3
002362  78001E     MOV [W14], W0
002364  904840     MOV.B [W0+12], W0
002366  FB8200     ZE W0, W4
002368  200010     MOV #0x1, W0
00236A  200001     MOV #0x0, W1
00236C  780284     MOV W4, W5
00236E  E90285     DEC W5, W5
002370  330003     BRA N, .LE239
002372  400000     ADD W0, W0, W0
002374  488081     ADDC W1, W1, W1
002376  37FFFB     BRA .LB239
002378  780000     MOV W0, W0
00237A  EA8000     COM W0, W0
00237C  618000     AND W3, W0, W0
00237E  780900     MOV W0, [W2]
167:                                   } else {
168:                                       spi_transfer_status = 3;
002382  B3C030     MOV.B #0x3, W0
002384  B7F06C     MOV.B WREG, spi_transfer_status
169:                                   }
170:                                   
171:                                   break;
002380  370043     BRA .L8
002386  370040     BRA .L8
172:                               case 1:
173:                                   SPI1BUF = m->write_data[n_transfers];
002388  78001E     MOV [W14], W0
00238A  780090     MOV [W0], W1
00238C  BFD06E     MOV.B n_transfers, WREG
00238E  FB8000     ZE W0, W0
002390  400000     ADD W0, W0, W0
002392  408000     ADD W1, W0, W0
002394  780010     MOV [W0], W0
002396  881240     MOV W0, SPI1BUF
174:                                   spi_transfer_status = 2;
002398  B3C020     MOV.B #0x2, W0
00239A  B7F06C     MOV.B WREG, spi_transfer_status
175:                                   break;
00239C  370035     BRA .L8
176:                               case 2:
177:                                   while( !SPI1STATbits.SPIRBF );
00239E  000000     NOP
0023A0  801200     MOV SPI1STAT, W0
0023A2  600061     AND W0, #0x1, W0
0023A4  E00000     CP0 W0
0023A6  32FFFC     BRA Z, .L17
178:                                   m->read_data[n_transfers] = SPI1BUF;
0023A8  78001E     MOV [W14], W0
0023AA  900090     MOV [W0+2], W1
0023AC  BFD06E     MOV.B n_transfers, WREG
0023AE  FB8000     ZE W0, W0
0023B0  400000     ADD W0, W0, W0
0023B2  408000     ADD W1, W0, W0
0023B4  801241     MOV SPI1BUF, W1
0023B6  780801     MOV W1, [W0]
179:                                   n_transfers++;
0023B8  BFD06E     MOV.B n_transfers, WREG
0023BA  E84000     INC.B W0, W0
0023BC  B7F06E     MOV.B WREG, n_transfers
180:                                   if(n_transfers == m->data_length){
0023BE  78001E     MOV [W14], W0
0023C0  9040C0     MOV.B [W0+4], W1
0023C2  BFD06E     MOV.B n_transfers, WREG
0023C4  50CF80     SUB.B W1, W0, [W15]
0023C6  3A0003     BRA NZ, .L18
181:                                       spi_transfer_status = 3;
0023C8  B3C030     MOV.B #0x3, W0
0023CA  B7F06C     MOV.B WREG, spi_transfer_status
182:                                   } else {
183:                                       spi_transfer_status = 1;
0023CE  B3C010     MOV.B #0x1, W0
0023D0  B7F06C     MOV.B WREG, spi_transfer_status
184:                                   }
185:                                   break;
0023CC  37001D     BRA .L8
0023D2  37001A     BRA .L8
186:                               case 3:
187:                                   SET_BIT(m->cs_pin.lat_r, m->cs_pin.n);
0023D4  78001E     MOV [W14], W0
0023D6  900150     MOV [W0+10], W2
0023D8  78001E     MOV [W14], W0
0023DA  900050     MOV [W0+10], W0
0023DC  780190     MOV [W0], W3
0023DE  78001E     MOV [W14], W0
0023E0  904840     MOV.B [W0+12], W0
0023E2  FB8200     ZE W0, W4
0023E4  200010     MOV #0x1, W0
0023E6  200001     MOV #0x0, W1
0023E8  780284     MOV W4, W5
0023EA  E90285     DEC W5, W5
0023EC  330003     BRA N, .LE315
0023EE  400000     ADD W0, W0, W0
0023F0  488081     ADDC W1, W1, W1
0023F2  37FFFB     BRA .LB315
0023F4  780000     MOV W0, W0
0023F6  700003     IOR W0, W3, W0
0023F8  780900     MOV W0, [W2]
188:                                   m->status = SPI_TRANSFER_DONE;
0023FA  78001E     MOV [W14], W0
0023FC  200011     MOV #0x1, W1
0023FE  980071     MOV W1, [W0+14]
189:                                   spi_transfer_status = 0;
002400  EF706C     CLR.B spi_transfer_status
190:                                   break;
002402  370002     BRA .L8
191:                               default:
192:                                   spi_transfer_status = 0;
002404  EF706C     CLR.B spi_transfer_status
193:                                   break;
002406  000000     NOP
194:                           }
195:                   }
196:               }
002410  FA8000     ULNK
002412  060000     RETURN
197:               
198:               void send_spi2_message(spi_message_t* m){
002414  FA0006     LNK #0x6
002416  980720     MOV W0, [W14+4]
199:                   uint8_t n_transfers;
200:                   uint8_t dma4_status, dma5_status;
201:                   
202:                   // save DMA status
203:                   dma4_status = DMA4CONbits.CHEN;
002418  805A00     MOV DMA4CON, W0
00241A  DE004F     LSR W0, #15, W0
00241C  784000     MOV.B W0, W0
00241E  984710     MOV.B W0, [W14+1]
204:                   dma5_status = DMA5CONbits.CHEN;
002420  805A80     MOV DMA5CON, W0
002422  DE004F     LSR W0, #15, W0
002424  784000     MOV.B W0, W0
002426  984720     MOV.B W0, [W14+2]
205:                   
206:                   // disable DMA channels
207:                   DMA4CONbits.CHEN = 0;
002428  A9EB41     BCLR 0xB41, #7
208:                   DMA5CONbits.CHEN = 0;
00242A  A9EB51     BCLR 0xB51, #7
209:                   
210:                   // enable interrupt
211:                   _SPI2IE = 0;
00242C  A92824     BCLR IEC2, #1
212:                   
213:                   CLEAR_BIT(m->cs_pin.lat_r, m->cs_pin.n);
00242E  90002E     MOV [W14+4], W0
002430  900150     MOV [W0+10], W2
002432  90002E     MOV [W14+4], W0
002434  900050     MOV [W0+10], W0
002436  780190     MOV [W0], W3
002438  90002E     MOV [W14+4], W0
00243A  904840     MOV.B [W0+12], W0
00243C  FB8200     ZE W0, W4
00243E  200010     MOV #0x1, W0
002440  200001     MOV #0x0, W1
002442  780284     MOV W4, W5
002444  E90285     DEC W5, W5
002446  330003     BRA N, .LE371
002448  400000     ADD W0, W0, W0
00244A  488081     ADDC W1, W1, W1
00244C  37FFFB     BRA .LB371
00244E  780000     MOV W0, W0
002450  EA8000     COM W0, W0
002452  618000     AND W3, W0, W0
002454  780900     MOV W0, [W2]
214:                   while(m->status != SPI_TRANSFER_DONE){
002456  370046     BRA .L23
0024E4  90002E     MOV [W14+4], W0
0024E6  900070     MOV [W0+14], W0
0024E8  500FE1     SUB W0, #0x1, [W15]
0024EA  3AFFB6     BRA NZ, .L35
215:                       //if(spi_transfer_done != 0){
216:                           switch(spi_transfer_status){
002458  BFD06C     MOV.B spi_transfer_status, WREG
00245A  FB8000     ZE W0, W0
00245C  500FE1     SUB W0, #0x1, [W15]
00245E  320019     BRA Z, .L26
002460  500FE1     SUB W0, #0x1, [W15]
002462  3C0003     BRA GT, .L29
002464  E00000     CP0 W0
002466  320006     BRA Z, .L25
002468  37003B     BRA .L24
00246A  500FE2     SUB W0, #0x2, [W15]
00246C  32001D     BRA Z, .L36
00246E  500FE3     SUB W0, #0x3, [W15]
002470  320032     BRA Z, .L28
002472  370036     BRA .L24
217:                               case 0:
218:                                   if(m->data_length > 0){
002474  90002E     MOV [W14+4], W0
002476  904040     MOV.B [W0+4], W0
002478  E00400     CP0.B W0
00247A  320008     BRA Z, .L30
219:                                       n_transfers = 0;
00247C  EB4000     CLR.B W0
00247E  784F00     MOV.B W0, [W14]
220:                                       m->status = SPI_TRANSFER_ONGOING;
002480  90002E     MOV [W14+4], W0
002482  200021     MOV #0x2, W1
002484  980071     MOV W1, [W0+14]
221:                                       spi_transfer_status = 1;
002486  B3C010     MOV.B #0x1, W0
002488  B7F06C     MOV.B WREG, spi_transfer_status
222:                                       
223:                                   } else {
224:                                       spi_transfer_status = 3;
00248C  B3C030     MOV.B #0x3, W0
00248E  B7F06C     MOV.B WREG, spi_transfer_status
225:                                   }
226:                                   
227:                                   break;
00248A  37002C     BRA .L23
002490  370029     BRA .L23
228:                               case 1:
229:                                   SPI2BUF = m->write_data[n_transfers];
002492  90002E     MOV [W14+4], W0
002494  780090     MOV [W0], W1
002496  FB801E     ZE [W14], W0
002498  400000     ADD W0, W0, W0
00249A  408000     ADD W1, W0, W0
00249C  780010     MOV [W0], W0
00249E  881340     MOV W0, SPI2BUF
230:                                   spi_transfer_status = 2;
0024A0  B3C020     MOV.B #0x2, W0
0024A2  B7F06C     MOV.B WREG, spi_transfer_status
231:                                   spi_transfer_done = 0;
0024A4  EF7074     CLR.B 0x1074
232:                                   break;
0024A6  37001E     BRA .L23
233:                               case 2:
234:                                   while( !SPI2STATbits.SPIRBF );
0024A8  000000     NOP
0024AA  801300     MOV SPI2STAT, W0
0024AC  600061     AND W0, #0x1, W0
0024AE  E00000     CP0 W0
0024B0  32FFFC     BRA Z, .L32
235:                                   m->read_data[n_transfers] = SPI2BUF;
0024B2  90002E     MOV [W14+4], W0
0024B4  900090     MOV [W0+2], W1
0024B6  FB801E     ZE [W14], W0
0024B8  400000     ADD W0, W0, W0
0024BA  408000     ADD W1, W0, W0
0024BC  801341     MOV SPI2BUF, W1
0024BE  780801     MOV W1, [W0]
236:                                   n_transfers++;
0024C0  E84F1E     INC.B [W14], [W14]
237:                                   if(n_transfers == m->data_length){
0024C2  90002E     MOV [W14+4], W0
0024C4  904040     MOV.B [W0+4], W0
0024C6  504F9E     SUB.B W0, [W14], [W15]
0024C8  3A0003     BRA NZ, .L33
238:                                       spi_transfer_status = 3;
0024CA  B3C030     MOV.B #0x3, W0
0024CC  B7F06C     MOV.B WREG, spi_transfer_status
239:                                   } else {
240:                                       spi_transfer_status = 1;
0024D0  B3C010     MOV.B #0x1, W0
0024D2  B7F06C     MOV.B WREG, spi_transfer_status
241:                                   }
242:                                   break;
0024CE  37000A     BRA .L23
0024D4  370007     BRA .L23
243:                               case 3:
244:                                   
245:                                   m->status = SPI_TRANSFER_DONE;
0024D6  90002E     MOV [W14+4], W0
0024D8  200011     MOV #0x1, W1
0024DA  980071     MOV W1, [W0+14]
246:                                   spi_transfer_status = 0;
0024DC  EF706C     CLR.B spi_transfer_status
247:                                   break;
0024DE  370002     BRA .L23
248:                               default:
249:                                   spi_transfer_status = 0;
0024E0  EF706C     CLR.B spi_transfer_status
250:                                   break;
0024E2  000000     NOP
251:                           }
252:                       //}
253:                   }
254:                   
255:                   SET_BIT(m->cs_pin.lat_r, m->cs_pin.n);
0024EC  90002E     MOV [W14+4], W0
0024EE  900150     MOV [W0+10], W2
0024F0  90002E     MOV [W14+4], W0
0024F2  900050     MOV [W0+10], W0
0024F4  780190     MOV [W0], W3
0024F6  90002E     MOV [W14+4], W0
0024F8  904840     MOV.B [W0+12], W0
0024FA  FB8200     ZE W0, W4
0024FC  200010     MOV #0x1, W0
0024FE  200001     MOV #0x0, W1
002500  780284     MOV W4, W5
002502  E90285     DEC W5, W5
002504  330003     BRA N, .LE502
002506  400000     ADD W0, W0, W0
002508  488081     ADDC W1, W1, W1
00250A  37FFFB     BRA .LB502
00250C  780000     MOV W0, W0
00250E  700003     IOR W0, W3, W0
002510  780900     MOV W0, [W2]
256:                   
257:                   // re-enable DMA if it was activated
258:                   DMA4CONbits.CHEN = dma4_status;
002512  90401E     MOV.B [W14+1], W0
002514  604061     AND.B W0, #0x1, W0
002516  FB8000     ZE W0, W0
002518  DD004F     SL W0, #15, W0
00251A  805A01     MOV DMA4CON, W1
00251C  A1F001     BCLR W1, #15
00251E  700001     IOR W0, W1, W0
002520  885A00     MOV W0, DMA4CON
259:                   DMA5CONbits.CHEN = dma5_status;
002522  90402E     MOV.B [W14+2], W0
002524  604061     AND.B W0, #0x1, W0
002526  FB8000     ZE W0, W0
002528  DD004F     SL W0, #15, W0
00252A  805A81     MOV DMA5CON, W1
00252C  A1F001     BCLR W1, #15
00252E  700001     IOR W0, W1, W0
002530  885A80     MOV W0, DMA5CON
260:                   
261:                   // disable interrupt
262:                   _SPI2IE = 0;
002532  A92824     BCLR IEC2, #1
263:               }
002534  FA8000     ULNK
002536  060000     RETURN
264:               
265:               void send_spi3_message(spi_message_t* m){
002538  FA0002     LNK #0x2
00253A  780F00     MOV W0, [W14]
266:                   static uint8_t n_transfers;
267:                   
268:                   while(m->status != SPI_TRANSFER_DONE){
00253C  370070     BRA .L38
00261E  78001E     MOV [W14], W0
002620  900070     MOV [W0+14], W0
002622  500FE1     SUB W0, #0x1, [W15]
002624  3AFF8C     BRA NZ, .L50
269:                           switch(spi_transfer_status){
00253E  BFD06C     MOV.B spi_transfer_status, WREG
002540  FB8000     ZE W0, W0
002542  500FE1     SUB W0, #0x1, [W15]
002544  32002C     BRA Z, .L41
002546  500FE1     SUB W0, #0x1, [W15]
002548  3C0003     BRA GT, .L44
00254A  E00000     CP0 W0
00254C  320006     BRA Z, .L40
00254E  370065     BRA .L39
002550  500FE2     SUB W0, #0x2, [W15]
002552  320030     BRA Z, .L51
002554  500FE3     SUB W0, #0x3, [W15]
002556  320049     BRA Z, .L43
002558  370060     BRA .L39
270:                               case 0:
271:                                   if(m->data_length > 0){
00255A  78001E     MOV [W14], W0
00255C  904040     MOV.B [W0+4], W0
00255E  E00400     CP0.B W0
002560  32001B     BRA Z, .L45
272:                                       n_transfers = 0;
002562  EF706D     CLR.B n_transfers
273:                                       m->status = SPI_TRANSFER_ONGOING;
002564  78001E     MOV [W14], W0
002566  200021     MOV #0x2, W1
002568  980071     MOV W1, [W0+14]
274:                                       spi_transfer_status = 1;
00256A  B3C010     MOV.B #0x1, W0
00256C  B7F06C     MOV.B WREG, spi_transfer_status
275:                                       CLEAR_BIT(m->cs_pin.lat_r, m->cs_pin.n);
00256E  78001E     MOV [W14], W0
002570  900150     MOV [W0+10], W2
002572  78001E     MOV [W14], W0
002574  900050     MOV [W0+10], W0
002576  780190     MOV [W0], W3
002578  78001E     MOV [W14], W0
00257A  904840     MOV.B [W0+12], W0
00257C  FB8200     ZE W0, W4
00257E  200010     MOV #0x1, W0
002580  200001     MOV #0x0, W1
002582  780284     MOV W4, W5
002584  E90285     DEC W5, W5
002586  330003     BRA N, .LE586
002588  400000     ADD W0, W0, W0
00258A  488081     ADDC W1, W1, W1
00258C  37FFFB     BRA .LB586
00258E  780000     MOV W0, W0
002590  EA8000     COM W0, W0
002592  618000     AND W3, W0, W0
002594  780900     MOV W0, [W2]
276:                                   } else {
277:                                       spi_transfer_status = 3;
002598  B3C030     MOV.B #0x3, W0
00259A  B7F06C     MOV.B WREG, spi_transfer_status
278:                                   }
279:                                   
280:                                   break;
002596  370043     BRA .L38
00259C  370040     BRA .L38
281:                               case 1:
282:                                   SPI3BUF = m->write_data[n_transfers];
00259E  78001E     MOV [W14], W0
0025A0  780090     MOV [W0], W1
0025A2  BFD06D     MOV.B n_transfers, WREG
0025A4  FB8000     ZE W0, W0
0025A6  400000     ADD W0, W0, W0
0025A8  408000     ADD W1, W0, W0
0025AA  780010     MOV [W0], W0
0025AC  881540     MOV W0, SPI3BUF
283:                                   spi_transfer_status = 2;
0025AE  B3C020     MOV.B #0x2, W0
0025B0  B7F06C     MOV.B WREG, spi_transfer_status
284:                                   break;
0025B2  370035     BRA .L38
285:                               case 2:
286:                                   while( !SPI3STATbits.SPIRBF );
0025B4  000000     NOP
0025B6  801500     MOV SPI3STAT, W0
0025B8  600061     AND W0, #0x1, W0
0025BA  E00000     CP0 W0
0025BC  32FFFC     BRA Z, .L47
287:                                   m->read_data[n_transfers] = SPI3BUF;
0025BE  78001E     MOV [W14], W0
0025C0  900090     MOV [W0+2], W1
0025C2  BFD06D     MOV.B n_transfers, WREG
0025C4  FB8000     ZE W0, W0
0025C6  400000     ADD W0, W0, W0
0025C8  408000     ADD W1, W0, W0
0025CA  801541     MOV SPI3BUF, W1
0025CC  780801     MOV W1, [W0]
288:                                   n_transfers++;
0025CE  BFD06D     MOV.B n_transfers, WREG
0025D0  E84000     INC.B W0, W0
0025D2  B7F06D     MOV.B WREG, n_transfers
289:                                   if(n_transfers == m->data_length){
0025D4  78001E     MOV [W14], W0
0025D6  9040C0     MOV.B [W0+4], W1
0025D8  BFD06D     MOV.B n_transfers, WREG
0025DA  50CF80     SUB.B W1, W0, [W15]
0025DC  3A0003     BRA NZ, .L48
290:                                       spi_transfer_status = 3;
0025DE  B3C030     MOV.B #0x3, W0
0025E0  B7F06C     MOV.B WREG, spi_transfer_status
291:                                   } else {
292:                                       spi_transfer_status = 1;
0025E4  B3C010     MOV.B #0x1, W0
0025E6  B7F06C     MOV.B WREG, spi_transfer_status
293:                                   }
294:                                   break;
0025E2  37001D     BRA .L38
0025E8  37001A     BRA .L38
295:                               case 3:
296:                                   SET_BIT(m->cs_pin.lat_r, m->cs_pin.n);
0025EA  78001E     MOV [W14], W0
0025EC  900150     MOV [W0+10], W2
0025EE  78001E     MOV [W14], W0
0025F0  900050     MOV [W0+10], W0
0025F2  780190     MOV [W0], W3
0025F4  78001E     MOV [W14], W0
0025F6  904840     MOV.B [W0+12], W0
0025F8  FB8200     ZE W0, W4
0025FA  200010     MOV #0x1, W0
0025FC  200001     MOV #0x0, W1
0025FE  780284     MOV W4, W5
002600  E90285     DEC W5, W5
002602  330003     BRA N, .LE662
002604  400000     ADD W0, W0, W0
002606  488081     ADDC W1, W1, W1
002608  37FFFB     BRA .LB662
00260A  780000     MOV W0, W0
00260C  700003     IOR W0, W3, W0
00260E  780900     MOV W0, [W2]
297:                                   m->status = SPI_TRANSFER_DONE;
002610  78001E     MOV [W14], W0
002612  200011     MOV #0x1, W1
002614  980071     MOV W1, [W0+14]
298:                                   spi_transfer_status = 0;
002616  EF706C     CLR.B spi_transfer_status
299:                                   break;
002618  370002     BRA .L38
300:                               default:
301:                                   spi_transfer_status = 0;
00261A  EF706C     CLR.B spi_transfer_status
302:                                   break;
00261C  000000     NOP
303:                           }
304:                   }
305:               }
002626  FA8000     ULNK
002628  060000     RETURN
306:               
307:               
308:               void software_spi(pin_t* sck, pin_t* sdo, pin_t* sdi, pin_t* cs, uint8_t* tx_data, uint8_t* rx_data, uint8_t n, uint16_t period){
00262A  FA001C     LNK #0x1C
00262C  980760     MOV W0, [W14+12]
00262E  980771     MOV W1, [W14+14]
002630  980F02     MOV W2, [W14+16]
002632  980F13     MOV W3, [W14+18]
002634  980F24     MOV W4, [W14+20]
002636  980F35     MOV W5, [W14+22]
002638  985F06     MOV.B W6, [W14+24]
00263A  980F57     MOV W7, [W14+26]
309:                   uint8_t n_transfers = 0;
00263C  EB4000     CLR.B W0
00263E  784F00     MOV.B W0, [W14]
310:                   uint8_t tris_sck, tris_sdo, tris_sdi, tris_cs;
311:                   uint8_t lat_sck, lat_sdo, lat_sdi, lat_cs;
312:                   
313:                   // set minimum value of period
314:                   if(period < 2){
002640  90085E     MOV [W14+26], W0
002642  500FE1     SUB W0, #0x1, [W15]
002644  3E0002     BRA GTU, .L53
315:                       period = 2;
002646  200020     MOV #0x2, W0
002648  980F50     MOV W0, [W14+26]
316:                   }
317:                   
318:                   // read current state registers
319:                   tris_sck = GET_BIT(sck->tris_r, sck->n);
00264A  90006E     MOV [W14+12], W0
00264C  900010     MOV [W0+2], W0
00264E  780090     MOV [W0], W1
002650  90006E     MOV [W14+12], W0
002652  904060     MOV.B [W0+6], W0
002654  FB8000     ZE W0, W0
002656  DE0800     LSR W1, W0, W0
002658  784000     MOV.B W0, W0
00265A  604061     AND.B W0, #0x1, W0
00265C  984730     MOV.B W0, [W14+3]
320:                   tris_sdo = GET_BIT(sdo->tris_r, sdo->n);
00265E  90007E     MOV [W14+14], W0
002660  900010     MOV [W0+2], W0
002662  780090     MOV [W0], W1
002664  90007E     MOV [W14+14], W0
002666  904060     MOV.B [W0+6], W0
002668  FB8000     ZE W0, W0
00266A  DE0800     LSR W1, W0, W0
00266C  784000     MOV.B W0, W0
00266E  604061     AND.B W0, #0x1, W0
002670  984740     MOV.B W0, [W14+4]
321:                   tris_sdi = GET_BIT(sdi->tris_r, sdi->n);
002672  90080E     MOV [W14+16], W0
002674  900010     MOV [W0+2], W0
002676  780090     MOV [W0], W1
002678  90080E     MOV [W14+16], W0
00267A  904060     MOV.B [W0+6], W0
00267C  FB8000     ZE W0, W0
00267E  DE0800     LSR W1, W0, W0
002680  784000     MOV.B W0, W0
002682  604061     AND.B W0, #0x1, W0
002684  984750     MOV.B W0, [W14+5]
322:                   tris_cs  = GET_BIT(cs->tris_r, cs->n);
002686  90081E     MOV [W14+18], W0
002688  900010     MOV [W0+2], W0
00268A  780090     MOV [W0], W1
00268C  90081E     MOV [W14+18], W0
00268E  904060     MOV.B [W0+6], W0
002690  FB8000     ZE W0, W0
002692  DE0800     LSR W1, W0, W0
002694  784000     MOV.B W0, W0
002696  604061     AND.B W0, #0x1, W0
002698  984760     MOV.B W0, [W14+6]
323:                   
324:                   lat_sck = GET_BIT(sck->lat_r, sck->n);
00269A  90006E     MOV [W14+12], W0
00269C  900020     MOV [W0+4], W0
00269E  780090     MOV [W0], W1
0026A0  90006E     MOV [W14+12], W0
0026A2  904060     MOV.B [W0+6], W0
0026A4  FB8000     ZE W0, W0
0026A6  DE0800     LSR W1, W0, W0
0026A8  784000     MOV.B W0, W0
0026AA  604061     AND.B W0, #0x1, W0
0026AC  984770     MOV.B W0, [W14+7]
325:                   lat_sdo = GET_BIT(sdo->lat_r, sdo->n);
0026AE  90007E     MOV [W14+14], W0
0026B0  900020     MOV [W0+4], W0
0026B2  780090     MOV [W0], W1
0026B4  90007E     MOV [W14+14], W0
0026B6  904060     MOV.B [W0+6], W0
0026B8  FB8000     ZE W0, W0
0026BA  DE0800     LSR W1, W0, W0
0026BC  784000     MOV.B W0, W0
0026BE  604061     AND.B W0, #0x1, W0
0026C0  984F00     MOV.B W0, [W14+8]
326:                   lat_sdi = GET_BIT(sdi->lat_r, sdi->n);
0026C2  90080E     MOV [W14+16], W0
0026C4  900020     MOV [W0+4], W0
0026C6  780090     MOV [W0], W1
0026C8  90080E     MOV [W14+16], W0
0026CA  904060     MOV.B [W0+6], W0
0026CC  FB8000     ZE W0, W0
0026CE  DE0800     LSR W1, W0, W0
0026D0  784000     MOV.B W0, W0
0026D2  604061     AND.B W0, #0x1, W0
0026D4  984F10     MOV.B W0, [W14+9]
327:                   lat_cs  = GET_BIT(cs->lat_r, cs->n);
0026D6  90081E     MOV [W14+18], W0
0026D8  900020     MOV [W0+4], W0
0026DA  780090     MOV [W0], W1
0026DC  90081E     MOV [W14+18], W0
0026DE  904060     MOV.B [W0+6], W0
0026E0  FB8000     ZE W0, W0
0026E2  DE0800     LSR W1, W0, W0
0026E4  784000     MOV.B W0, W0
0026E6  604061     AND.B W0, #0x1, W0
0026E8  984F20     MOV.B W0, [W14+10]
328:                   
329:                   // update configuration
330:                   CLEAR_BIT(sck->tris_r, sck->n);
0026EA  90006E     MOV [W14+12], W0
0026EC  900110     MOV [W0+2], W2
0026EE  90006E     MOV [W14+12], W0
0026F0  900010     MOV [W0+2], W0
0026F2  780190     MOV [W0], W3
0026F4  90006E     MOV [W14+12], W0
0026F6  904060     MOV.B [W0+6], W0
0026F8  FB8200     ZE W0, W4
0026FA  200010     MOV #0x1, W0
0026FC  200001     MOV #0x0, W1
0026FE  780284     MOV W4, W5
002700  E90285     DEC W5, W5
002702  330003     BRA N, .LE804
002704  400000     ADD W0, W0, W0
002706  488081     ADDC W1, W1, W1
002708  37FFFB     BRA .LB804
00270A  780000     MOV W0, W0
00270C  EA8000     COM W0, W0
00270E  618000     AND W3, W0, W0
002710  780900     MOV W0, [W2]
331:                   CLEAR_BIT(sdo->tris_r, sdo->n);
002712  90007E     MOV [W14+14], W0
002714  900110     MOV [W0+2], W2
002716  90007E     MOV [W14+14], W0
002718  900010     MOV [W0+2], W0
00271A  780190     MOV [W0], W3
00271C  90007E     MOV [W14+14], W0
00271E  904060     MOV.B [W0+6], W0
002720  FB8200     ZE W0, W4
002722  200010     MOV #0x1, W0
002724  200001     MOV #0x0, W1
002726  780284     MOV W4, W5
002728  E90285     DEC W5, W5
00272A  330003     BRA N, .LE819
00272C  400000     ADD W0, W0, W0
00272E  488081     ADDC W1, W1, W1
002730  37FFFB     BRA .LB819
002732  780000     MOV W0, W0
002734  EA8000     COM W0, W0
002736  618000     AND W3, W0, W0
002738  780900     MOV W0, [W2]
332:                   SET_BIT(sdi->tris_r, sdi->n);
00273A  90080E     MOV [W14+16], W0
00273C  900110     MOV [W0+2], W2
00273E  90080E     MOV [W14+16], W0
002740  900010     MOV [W0+2], W0
002742  780190     MOV [W0], W3
002744  90080E     MOV [W14+16], W0
002746  904060     MOV.B [W0+6], W0
002748  FB8200     ZE W0, W4
00274A  200010     MOV #0x1, W0
00274C  200001     MOV #0x0, W1
00274E  780284     MOV W4, W5
002750  E90285     DEC W5, W5
002752  330003     BRA N, .LE834
002754  400000     ADD W0, W0, W0
002756  488081     ADDC W1, W1, W1
002758  37FFFB     BRA .LB834
00275A  780000     MOV W0, W0
00275C  700003     IOR W0, W3, W0
00275E  780900     MOV W0, [W2]
333:                   CLEAR_BIT(cs->tris_r, cs->n);
002760  90081E     MOV [W14+18], W0
002762  900110     MOV [W0+2], W2
002764  90081E     MOV [W14+18], W0
002766  900010     MOV [W0+2], W0
002768  780190     MOV [W0], W3
00276A  90081E     MOV [W14+18], W0
00276C  904060     MOV.B [W0+6], W0
00276E  FB8200     ZE W0, W4
002770  200010     MOV #0x1, W0
002772  200001     MOV #0x0, W1
002774  780284     MOV W4, W5
002776  E90285     DEC W5, W5
002778  330003     BRA N, .LE848
00277A  400000     ADD W0, W0, W0
00277C  488081     ADDC W1, W1, W1
00277E  37FFFB     BRA .LB848
002780  780000     MOV W0, W0
002782  EA8000     COM W0, W0
002784  618000     AND W3, W0, W0
002786  780900     MOV W0, [W2]
334:                   
335:                   CLEAR_BIT(sck->lat_r, sck->n);
002788  90006E     MOV [W14+12], W0
00278A  900120     MOV [W0+4], W2
00278C  90006E     MOV [W14+12], W0
00278E  900020     MOV [W0+4], W0
002790  780190     MOV [W0], W3
002792  90006E     MOV [W14+12], W0
002794  904060     MOV.B [W0+6], W0
002796  FB8200     ZE W0, W4
002798  200010     MOV #0x1, W0
00279A  200001     MOV #0x0, W1
00279C  780284     MOV W4, W5
00279E  E90285     DEC W5, W5
0027A0  330003     BRA N, .LE863
0027A2  400000     ADD W0, W0, W0
0027A4  488081     ADDC W1, W1, W1
0027A6  37FFFB     BRA .LB863
0027A8  780000     MOV W0, W0
0027AA  EA8000     COM W0, W0
0027AC  618000     AND W3, W0, W0
0027AE  780900     MOV W0, [W2]
336:                   CLEAR_BIT(sdo->lat_r, sdo->n);
0027B0  90007E     MOV [W14+14], W0
0027B2  900120     MOV [W0+4], W2
0027B4  90007E     MOV [W14+14], W0
0027B6  900020     MOV [W0+4], W0
0027B8  780190     MOV [W0], W3
0027BA  90007E     MOV [W14+14], W0
0027BC  904060     MOV.B [W0+6], W0
0027BE  FB8200     ZE W0, W4
0027C0  200010     MOV #0x1, W0
0027C2  200001     MOV #0x0, W1
0027C4  780284     MOV W4, W5
0027C6  E90285     DEC W5, W5
0027C8  330003     BRA N, .LE878
0027CA  400000     ADD W0, W0, W0
0027CC  488081     ADDC W1, W1, W1
0027CE  37FFFB     BRA .LB878
0027D0  780000     MOV W0, W0
0027D2  EA8000     COM W0, W0
0027D4  618000     AND W3, W0, W0
0027D6  780900     MOV W0, [W2]
337:                   SET_BIT(cs->lat_r, cs->n);
0027D8  90081E     MOV [W14+18], W0
0027DA  900120     MOV [W0+4], W2
0027DC  90081E     MOV [W14+18], W0
0027DE  900020     MOV [W0+4], W0
0027E0  780190     MOV [W0], W3
0027E2  90081E     MOV [W14+18], W0
0027E4  904060     MOV.B [W0+6], W0
0027E6  FB8200     ZE W0, W4
0027E8  200010     MOV #0x1, W0
0027EA  200001     MOV #0x0, W1
0027EC  780284     MOV W4, W5
0027EE  E90285     DEC W5, W5
0027F0  330003     BRA N, .LE893
0027F2  400000     ADD W0, W0, W0
0027F4  488081     ADDC W1, W1, W1
0027F6  37FFFB     BRA .LB893
0027F8  780000     MOV W0, W0
0027FA  700003     IOR W0, W3, W0
0027FC  780900     MOV W0, [W2]
338:                   
339:                   // SPI transfer
340:                   // set CS pin
341:                   delay_us(4*period);
0027FE  90085E     MOV [W14+26], W0
002800  DD0042     SL W0, #2, W0
002802  070CC2     RCALL delay_us
342:                   CLEAR_BIT(cs->lat_r, cs->n);
002804  90081E     MOV [W14+18], W0
002806  900120     MOV [W0+4], W2
002808  90081E     MOV [W14+18], W0
00280A  900020     MOV [W0+4], W0
00280C  780190     MOV [W0], W3
00280E  90081E     MOV [W14+18], W0
002810  904060     MOV.B [W0+6], W0
002812  FB8200     ZE W0, W4
002814  200010     MOV #0x1, W0
002816  200001     MOV #0x0, W1
002818  780284     MOV W4, W5
00281A  E90285     DEC W5, W5
00281C  330003     BRA N, .LE910
00281E  400000     ADD W0, W0, W0
002820  488081     ADDC W1, W1, W1
002822  37FFFB     BRA .LB910
002824  780000     MOV W0, W0
002826  EA8000     COM W0, W0
002828  618000     AND W3, W0, W0
00282A  780900     MOV W0, [W2]
343:                   delay_us(period / 2);
00282C  90085E     MOV [W14+26], W0
00282E  D10000     LSR W0, W0
002830  070CAB     RCALL delay_us
344:                   while(n_transfers < n){
002832  370092     BRA .L54, .LBE2
002958  90580E     MOV.B [W14+24], W0
00295A  78409E     MOV.B [W14], W1
00295C  50CF80     SUB.B W1, W0, [W15]
00295E  39FF6A     BRA NC, .L59, .LBB2
345:                       // shift out byte
346:                       uint8_t i;
347:                       uint8_t current_tx_byte = tx_data[n_transfers];
002834  FB801E     ZE [W14], W0
002836  9008AE     MOV [W14+20], W1
002838  408000     ADD W1, W0, W0
00283A  784010     MOV.B [W0], W0
00283C  984F30     MOV.B W0, [W14+11]
348:                       uint8_t current_rx_byte = 0;
00283E  EB4000     CLR.B W0
002840  984720     MOV.B W0, [W14+2]
349:                       for(i = 0; i < 8; i++){
002842  EB4000     CLR.B W0
002844  984710     MOV.B W0, [W14+1]
002846  37007F     BRA .L55
002940  90401E     MOV.B [W14+1], W0
002942  E84000     INC.B W0, W0
002944  984710     MOV.B W0, [W14+1]
002946  90401E     MOV.B [W14+1], W0
002948  504FE7     SUB.B W0, #0x7, [W15]
00294A  36FF7E     BRA LEU, .L58
350:                           if(GET_BIT(&current_tx_byte, 7-i) == 0){
002848  90483E     MOV.B [W14+11], W0
00284A  FB8080     ZE W0, W1
00284C  90401E     MOV.B [W14+1], W0
00284E  FB8000     ZE W0, W0
002850  100067     SUBR W0, #0x7, W0
002852  DE8800     ASR W1, W0, W0
002854  B90161     MUL.SU W0, #0x1, W2
002856  200010     MOV #0x1, W0
002858  200001     MOV #0x0, W1
00285A  780202     MOV W2, W4
00285C  780103     MOV W3, W2
00285E  780180     MOV W0, W3
002860  780001     MOV W1, W0
002862  620203     AND W4, W3, W4
002864  610000     AND W2, W0, W0
002866  EB0080     CLR W1
002868  DD00C0     SL W0, #0, W1
00286A  200000     MOV #0x0, W0
00286C  BE0100     MOV.D W0, W2
00286E  B82061     MUL.UU W4, #0x1, W0
002870  710100     IOR W2, W0, W2
002872  718181     IOR W3, W1, W3
002874  510FE0     SUB W2, #0x0, [W15]
002876  598FE0     SUBB W3, #0x0, [W15]
002878  3A0015     BRA NZ, .L56
351:                               CLEAR_BIT(sdo->lat_r, sdo->n);
00287A  90007E     MOV [W14+14], W0
00287C  900120     MOV [W0+4], W2
00287E  90007E     MOV [W14+14], W0
002880  900020     MOV [W0+4], W0
002882  780190     MOV [W0], W3
002884  90007E     MOV [W14+14], W0
002886  904060     MOV.B [W0+6], W0
002888  FB8200     ZE W0, W4
00288A  200010     MOV #0x1, W0
00288C  200001     MOV #0x0, W1
00288E  780284     MOV W4, W5
002890  E90285     DEC W5, W5
002892  330003     BRA N, .LE968
002894  400000     ADD W0, W0, W0
002896  488081     ADDC W1, W1, W1
002898  37FFFB     BRA .LB968
00289A  780000     MOV W0, W0
00289C  EA8000     COM W0, W0
00289E  618000     AND W3, W0, W0
0028A0  780900     MOV W0, [W2]
0028A2  370013     BRA .L57
352:                           } else {
353:                               SET_BIT(sdo->lat_r, sdo->n);
0028A4  90007E     MOV [W14+14], W0
0028A6  900120     MOV [W0+4], W2
0028A8  90007E     MOV [W14+14], W0
0028AA  900020     MOV [W0+4], W0
0028AC  780190     MOV [W0], W3
0028AE  90007E     MOV [W14+14], W0
0028B0  904060     MOV.B [W0+6], W0
0028B2  FB8200     ZE W0, W4
0028B4  200010     MOV #0x1, W0
0028B6  200001     MOV #0x0, W1
0028B8  780284     MOV W4, W5
0028BA  E90285     DEC W5, W5
0028BC  330003     BRA N, .LE987
0028BE  400000     ADD W0, W0, W0
0028C0  488081     ADDC W1, W1, W1
0028C2  37FFFB     BRA .LB987
0028C4  780000     MOV W0, W0
0028C6  700003     IOR W0, W3, W0
0028C8  780900     MOV W0, [W2]
354:                           }
355:                           delay_us(period / 2);
0028CA  90085E     MOV [W14+26], W0
0028CC  D10000     LSR W0, W0
0028CE  070C5C     RCALL delay_us
356:                           SET_BIT(sck->lat_r, sck->n);
0028D0  90006E     MOV [W14+12], W0
0028D2  900120     MOV [W0+4], W2
0028D4  90006E     MOV [W14+12], W0
0028D6  900020     MOV [W0+4], W0
0028D8  780190     MOV [W0], W3
0028DA  90006E     MOV [W14+12], W0
0028DC  904060     MOV.B [W0+6], W0
0028DE  FB8200     ZE W0, W4
0028E0  200010     MOV #0x1, W0
0028E2  200001     MOV #0x0, W1
0028E4  780284     MOV W4, W5
0028E6  E90285     DEC W5, W5
0028E8  330003     BRA N, .LE1006
0028EA  400000     ADD W0, W0, W0
0028EC  488081     ADDC W1, W1, W1
0028EE  37FFFB     BRA .LB1006
0028F0  780000     MOV W0, W0
0028F2  700003     IOR W0, W3, W0
0028F4  780900     MOV W0, [W2]
357:                           current_rx_byte = (current_rx_byte << 1) | GET_BIT(sdi->port_r, sdi->n);
0028F6  90402E     MOV.B [W14+2], W0
0028F8  404000     ADD.B W0, W0, W0
0028FA  784080     MOV.B W0, W1
0028FC  90080E     MOV [W14+16], W0
0028FE  780010     MOV [W0], W0
002900  780110     MOV [W0], W2
002902  90080E     MOV [W14+16], W0
002904  904060     MOV.B [W0+6], W0
002906  FB8000     ZE W0, W0
002908  DE1000     LSR W2, W0, W0
00290A  784000     MOV.B W0, W0
00290C  604061     AND.B W0, #0x1, W0
00290E  70C000     IOR.B W1, W0, W0
002910  984720     MOV.B W0, [W14+2]
358:                           delay_us(period / 2);
002912  90085E     MOV [W14+26], W0
002914  D10000     LSR W0, W0
002916  070C38     RCALL delay_us
359:                           CLEAR_BIT(sck->lat_r, sck->n);
002918  90006E     MOV [W14+12], W0
00291A  900120     MOV [W0+4], W2
00291C  90006E     MOV [W14+12], W0
00291E  900020     MOV [W0+4], W0
002920  780190     MOV [W0], W3
002922  90006E     MOV [W14+12], W0
002924  904060     MOV.B [W0+6], W0
002926  FB8200     ZE W0, W4
002928  200010     MOV #0x1, W0
00292A  200001     MOV #0x0, W1
00292C  780284     MOV W4, W5
00292E  E90285     DEC W5, W5
002930  330003     BRA N, .LE1037
002932  400000     ADD W0, W0, W0
002934  488081     ADDC W1, W1, W1
002936  37FFFB     BRA .LB1037
002938  780000     MOV W0, W0
00293A  EA8000     COM W0, W0
00293C  618000     AND W3, W0, W0
00293E  780900     MOV W0, [W2]
360:                       }
361:                       rx_data[n_transfers] = current_rx_byte;
00294C  FB801E     ZE [W14], W0
00294E  9008BE     MOV [W14+22], W1
002950  408000     ADD W1, W0, W0
002952  9040AE     MOV.B [W14+2], W1
002954  784801     MOV.B W1, [W0]
362:                       n_transfers++;
002956  E84F1E     INC.B [W14], [W14]
363:                   }
364:                   delay_us(period / 2);
002960  90085E     MOV [W14+26], W0
002962  D10000     LSR W0, W0
002964  070C11     RCALL delay_us
365:                   CLEAR_BIT(sdo->lat_r, sdo->n);
002966  90007E     MOV [W14+14], W0
002968  900120     MOV [W0+4], W2
00296A  90007E     MOV [W14+14], W0
00296C  900020     MOV [W0+4], W0
00296E  780190     MOV [W0], W3
002970  90007E     MOV [W14+14], W0
002972  904060     MOV.B [W0+6], W0
002974  FB8200     ZE W0, W4
002976  200010     MOV #0x1, W0
002978  200001     MOV #0x0, W1
00297A  780284     MOV W4, W5
00297C  E90285     DEC W5, W5
00297E  330003     BRA N, .LE1078
002980  400000     ADD W0, W0, W0
002982  488081     ADDC W1, W1, W1
002984  37FFFB     BRA .LB1078
002986  780000     MOV W0, W0
002988  EA8000     COM W0, W0
00298A  618000     AND W3, W0, W0
00298C  780900     MOV W0, [W2]
366:                   delay_us(period / 2);
00298E  90085E     MOV [W14+26], W0
002990  D10000     LSR W0, W0
002992  070BFA     RCALL delay_us
367:                   SET_BIT(cs->lat_r, cs->n);
002994  90081E     MOV [W14+18], W0
002996  900120     MOV [W0+4], W2
002998  90081E     MOV [W14+18], W0
00299A  900020     MOV [W0+4], W0
00299C  780190     MOV [W0], W3
00299E  90081E     MOV [W14+18], W0
0029A0  904060     MOV.B [W0+6], W0
0029A2  FB8200     ZE W0, W4
0029A4  200010     MOV #0x1, W0
0029A6  200001     MOV #0x0, W1
0029A8  780284     MOV W4, W5
0029AA  E90285     DEC W5, W5
0029AC  330003     BRA N, .LE1096
0029AE  400000     ADD W0, W0, W0
0029B0  488081     ADDC W1, W1, W1
0029B2  37FFFB     BRA .LB1096
0029B4  780000     MOV W0, W0
0029B6  700003     IOR W0, W3, W0
0029B8  780900     MOV W0, [W2]
368:                   
369:                   // reset configuration to old state
370:                   if(tris_sck == 0){
0029BA  90403E     MOV.B [W14+3], W0
0029BC  E00400     CP0.B W0
0029BE  3A0015     BRA NZ, .L60
371:                       CLEAR_BIT(sck->tris_r, sck->n);
0029C0  90006E     MOV [W14+12], W0
0029C2  900110     MOV [W0+2], W2
0029C4  90006E     MOV [W14+12], W0
0029C6  900010     MOV [W0+2], W0
0029C8  780190     MOV [W0], W3
0029CA  90006E     MOV [W14+12], W0
0029CC  904060     MOV.B [W0+6], W0
0029CE  FB8200     ZE W0, W4
0029D0  200010     MOV #0x1, W0
0029D2  200001     MOV #0x0, W1
0029D4  780284     MOV W4, W5
0029D6  E90285     DEC W5, W5
0029D8  330003     BRA N, .LE1114
0029DA  400000     ADD W0, W0, W0
0029DC  488081     ADDC W1, W1, W1
0029DE  37FFFB     BRA .LB1114
0029E0  780000     MOV W0, W0
0029E2  EA8000     COM W0, W0
0029E4  618000     AND W3, W0, W0
0029E6  780900     MOV W0, [W2]
0029E8  370013     BRA .L61
372:                   } else {
373:                       SET_BIT(sck->tris_r, sck->n);
0029EA  90006E     MOV [W14+12], W0
0029EC  900110     MOV [W0+2], W2
0029EE  90006E     MOV [W14+12], W0
0029F0  900010     MOV [W0+2], W0
0029F2  780190     MOV [W0], W3
0029F4  90006E     MOV [W14+12], W0
0029F6  904060     MOV.B [W0+6], W0
0029F8  FB8200     ZE W0, W4
0029FA  200010     MOV #0x1, W0
0029FC  200001     MOV #0x0, W1
0029FE  780284     MOV W4, W5
002A00  E90285     DEC W5, W5
002A02  330003     BRA N, .LE1133
002A04  400000     ADD W0, W0, W0
002A06  488081     ADDC W1, W1, W1
002A08  37FFFB     BRA .LB1133
002A0A  780000     MOV W0, W0
002A0C  700003     IOR W0, W3, W0
002A0E  780900     MOV W0, [W2]
374:                   }
375:                   if(tris_sdo == 0){
002A10  90404E     MOV.B [W14+4], W0
002A12  E00400     CP0.B W0
002A14  3A0015     BRA NZ, .L62
376:                       CLEAR_BIT(sdo->tris_r, sdo->n);
002A16  90007E     MOV [W14+14], W0
002A18  900110     MOV [W0+2], W2
002A1A  90007E     MOV [W14+14], W0
002A1C  900010     MOV [W0+2], W0
002A1E  780190     MOV [W0], W3
002A20  90007E     MOV [W14+14], W0
002A22  904060     MOV.B [W0+6], W0
002A24  FB8200     ZE W0, W4
002A26  200010     MOV #0x1, W0
002A28  200001     MOV #0x0, W1
002A2A  780284     MOV W4, W5
002A2C  E90285     DEC W5, W5
002A2E  330003     BRA N, .LE1153
002A30  400000     ADD W0, W0, W0
002A32  488081     ADDC W1, W1, W1
002A34  37FFFB     BRA .LB1153
002A36  780000     MOV W0, W0
002A38  EA8000     COM W0, W0
002A3A  618000     AND W3, W0, W0
002A3C  780900     MOV W0, [W2]
002A3E  370013     BRA .L63
377:                   } else {
378:                       SET_BIT(sdo->tris_r, sdo->n);
002A40  90007E     MOV [W14+14], W0
002A42  900110     MOV [W0+2], W2
002A44  90007E     MOV [W14+14], W0
002A46  900010     MOV [W0+2], W0
002A48  780190     MOV [W0], W3
002A4A  90007E     MOV [W14+14], W0
002A4C  904060     MOV.B [W0+6], W0
002A4E  FB8200     ZE W0, W4
002A50  200010     MOV #0x1, W0
002A52  200001     MOV #0x0, W1
002A54  780284     MOV W4, W5
002A56  E90285     DEC W5, W5
002A58  330003     BRA N, .LE1172
002A5A  400000     ADD W0, W0, W0
002A5C  488081     ADDC W1, W1, W1
002A5E  37FFFB     BRA .LB1172
002A60  780000     MOV W0, W0
002A62  700003     IOR W0, W3, W0
002A64  780900     MOV W0, [W2]
379:                   }
380:                   if(tris_sdi == 0){
002A66  90405E     MOV.B [W14+5], W0
002A68  E00400     CP0.B W0
002A6A  3A0015     BRA NZ, .L64
381:                       CLEAR_BIT(sdi->tris_r, sdi->n);
002A6C  90080E     MOV [W14+16], W0
002A6E  900110     MOV [W0+2], W2
002A70  90080E     MOV [W14+16], W0
002A72  900010     MOV [W0+2], W0
002A74  780190     MOV [W0], W3
002A76  90080E     MOV [W14+16], W0
002A78  904060     MOV.B [W0+6], W0
002A7A  FB8200     ZE W0, W4
002A7C  200010     MOV #0x1, W0
002A7E  200001     MOV #0x0, W1
002A80  780284     MOV W4, W5
002A82  E90285     DEC W5, W5
002A84  330003     BRA N, .LE1192
002A86  400000     ADD W0, W0, W0
002A88  488081     ADDC W1, W1, W1
002A8A  37FFFB     BRA .LB1192
002A8C  780000     MOV W0, W0
002A8E  EA8000     COM W0, W0
002A90  618000     AND W3, W0, W0
002A92  780900     MOV W0, [W2]
002A94  370013     BRA .L65
382:                   } else {
383:                       SET_BIT(sdi->tris_r, sdi->n);
002A96  90080E     MOV [W14+16], W0
002A98  900110     MOV [W0+2], W2
002A9A  90080E     MOV [W14+16], W0
002A9C  900010     MOV [W0+2], W0
002A9E  780190     MOV [W0], W3
002AA0  90080E     MOV [W14+16], W0
002AA2  904060     MOV.B [W0+6], W0
002AA4  FB8200     ZE W0, W4
002AA6  200010     MOV #0x1, W0
002AA8  200001     MOV #0x0, W1
002AAA  780284     MOV W4, W5
002AAC  E90285     DEC W5, W5
002AAE  330003     BRA N, .LE1211
002AB0  400000     ADD W0, W0, W0
002AB2  488081     ADDC W1, W1, W1
002AB4  37FFFB     BRA .LB1211
002AB6  780000     MOV W0, W0
002AB8  700003     IOR W0, W3, W0
002ABA  780900     MOV W0, [W2]
384:                   }
385:                   if(tris_cs == 0){
002ABC  90406E     MOV.B [W14+6], W0
002ABE  E00400     CP0.B W0
002AC0  3A0015     BRA NZ, .L66
386:                       CLEAR_BIT(cs->tris_r, cs->n);
002AC2  90081E     MOV [W14+18], W0
002AC4  900110     MOV [W0+2], W2
002AC6  90081E     MOV [W14+18], W0
002AC8  900010     MOV [W0+2], W0
002ACA  780190     MOV [W0], W3
002ACC  90081E     MOV [W14+18], W0
002ACE  904060     MOV.B [W0+6], W0
002AD0  FB8200     ZE W0, W4
002AD2  200010     MOV #0x1, W0
002AD4  200001     MOV #0x0, W1
002AD6  780284     MOV W4, W5
002AD8  E90285     DEC W5, W5
002ADA  330003     BRA N, .LE1231
002ADC  400000     ADD W0, W0, W0
002ADE  488081     ADDC W1, W1, W1
002AE0  37FFFB     BRA .LB1231
002AE2  780000     MOV W0, W0
002AE4  EA8000     COM W0, W0
002AE6  618000     AND W3, W0, W0
002AE8  780900     MOV W0, [W2]
002AEA  370013     BRA .L67
387:                   } else {
388:                       SET_BIT(cs->tris_r, cs->n);
002AEC  90081E     MOV [W14+18], W0
002AEE  900110     MOV [W0+2], W2
002AF0  90081E     MOV [W14+18], W0
002AF2  900010     MOV [W0+2], W0
002AF4  780190     MOV [W0], W3
002AF6  90081E     MOV [W14+18], W0
002AF8  904060     MOV.B [W0+6], W0
002AFA  FB8200     ZE W0, W4
002AFC  200010     MOV #0x1, W0
002AFE  200001     MOV #0x0, W1
002B00  780284     MOV W4, W5
002B02  E90285     DEC W5, W5
002B04  330003     BRA N, .LE1250
002B06  400000     ADD W0, W0, W0
002B08  488081     ADDC W1, W1, W1
002B0A  37FFFB     BRA .LB1250
002B0C  780000     MOV W0, W0
002B0E  700003     IOR W0, W3, W0
002B10  780900     MOV W0, [W2]
389:                   }
390:                   
391:                   if(lat_sck == 0){
002B12  90407E     MOV.B [W14+7], W0
002B14  E00400     CP0.B W0
002B16  3A0015     BRA NZ, .L68
392:                       CLEAR_BIT(sck->lat_r, sck->n);
002B18  90006E     MOV [W14+12], W0
002B1A  900120     MOV [W0+4], W2
002B1C  90006E     MOV [W14+12], W0
002B1E  900020     MOV [W0+4], W0
002B20  780190     MOV [W0], W3
002B22  90006E     MOV [W14+12], W0
002B24  904060     MOV.B [W0+6], W0
002B26  FB8200     ZE W0, W4
002B28  200010     MOV #0x1, W0
002B2A  200001     MOV #0x0, W1
002B2C  780284     MOV W4, W5
002B2E  E90285     DEC W5, W5
002B30  330003     BRA N, .LE1270
002B32  400000     ADD W0, W0, W0
002B34  488081     ADDC W1, W1, W1
002B36  37FFFB     BRA .LB1270
002B38  780000     MOV W0, W0
002B3A  EA8000     COM W0, W0
002B3C  618000     AND W3, W0, W0
002B3E  780900     MOV W0, [W2]
002B40  370013     BRA .L69
393:                   } else {
394:                       SET_BIT(sck->lat_r, sck->n);
002B42  90006E     MOV [W14+12], W0
002B44  900120     MOV [W0+4], W2
002B46  90006E     MOV [W14+12], W0
002B48  900020     MOV [W0+4], W0
002B4A  780190     MOV [W0], W3
002B4C  90006E     MOV [W14+12], W0
002B4E  904060     MOV.B [W0+6], W0
002B50  FB8200     ZE W0, W4
002B52  200010     MOV #0x1, W0
002B54  200001     MOV #0x0, W1
002B56  780284     MOV W4, W5
002B58  E90285     DEC W5, W5
002B5A  330003     BRA N, .LE1289
002B5C  400000     ADD W0, W0, W0
002B5E  488081     ADDC W1, W1, W1
002B60  37FFFB     BRA .LB1289
002B62  780000     MOV W0, W0
002B64  700003     IOR W0, W3, W0
002B66  780900     MOV W0, [W2]
395:                   }
396:                   if(lat_sdo == 0){
002B68  90480E     MOV.B [W14+8], W0
002B6A  E00400     CP0.B W0
002B6C  3A0015     BRA NZ, .L70
397:                       CLEAR_BIT(sdo->lat_r, sdo->n);
002B6E  90007E     MOV [W14+14], W0
002B70  900120     MOV [W0+4], W2
002B72  90007E     MOV [W14+14], W0
002B74  900020     MOV [W0+4], W0
002B76  780190     MOV [W0], W3
002B78  90007E     MOV [W14+14], W0
002B7A  904060     MOV.B [W0+6], W0
002B7C  FB8200     ZE W0, W4
002B7E  200010     MOV #0x1, W0
002B80  200001     MOV #0x0, W1
002B82  780284     MOV W4, W5
002B84  E90285     DEC W5, W5
002B86  330003     BRA N, .LE1309
002B88  400000     ADD W0, W0, W0
002B8A  488081     ADDC W1, W1, W1
002B8C  37FFFB     BRA .LB1309
002B8E  780000     MOV W0, W0
002B90  EA8000     COM W0, W0
002B92  618000     AND W3, W0, W0
002B94  780900     MOV W0, [W2]
002B96  370013     BRA .L71
398:                   } else {
399:                       SET_BIT(sdo->lat_r, sdo->n);
002B98  90007E     MOV [W14+14], W0
002B9A  900120     MOV [W0+4], W2
002B9C  90007E     MOV [W14+14], W0
002B9E  900020     MOV [W0+4], W0
002BA0  780190     MOV [W0], W3
002BA2  90007E     MOV [W14+14], W0
002BA4  904060     MOV.B [W0+6], W0
002BA6  FB8200     ZE W0, W4
002BA8  200010     MOV #0x1, W0
002BAA  200001     MOV #0x0, W1
002BAC  780284     MOV W4, W5
002BAE  E90285     DEC W5, W5
002BB0  330003     BRA N, .LE1328
002BB2  400000     ADD W0, W0, W0
002BB4  488081     ADDC W1, W1, W1
002BB6  37FFFB     BRA .LB1328
002BB8  780000     MOV W0, W0
002BBA  700003     IOR W0, W3, W0
002BBC  780900     MOV W0, [W2]
400:                   }
401:                   if(lat_sdi == 0){
002BBE  90481E     MOV.B [W14+9], W0
002BC0  E00400     CP0.B W0
002BC2  3A0015     BRA NZ, .L72
402:                       CLEAR_BIT(sdi->lat_r, sdi->n);
002BC4  90080E     MOV [W14+16], W0
002BC6  900120     MOV [W0+4], W2
002BC8  90080E     MOV [W14+16], W0
002BCA  900020     MOV [W0+4], W0
002BCC  780190     MOV [W0], W3
002BCE  90080E     MOV [W14+16], W0
002BD0  904060     MOV.B [W0+6], W0
002BD2  FB8200     ZE W0, W4
002BD4  200010     MOV #0x1, W0
002BD6  200001     MOV #0x0, W1
002BD8  780284     MOV W4, W5
002BDA  E90285     DEC W5, W5
002BDC  330003     BRA N, .LE1348
002BDE  400000     ADD W0, W0, W0
002BE0  488081     ADDC W1, W1, W1
002BE2  37FFFB     BRA .LB1348
002BE4  780000     MOV W0, W0
002BE6  EA8000     COM W0, W0
002BE8  618000     AND W3, W0, W0
002BEA  780900     MOV W0, [W2]
002BEC  370013     BRA .L73
403:                   } else {
404:                       SET_BIT(sdi->lat_r, sdi->n);
002BEE  90080E     MOV [W14+16], W0
002BF0  900120     MOV [W0+4], W2
002BF2  90080E     MOV [W14+16], W0
002BF4  900020     MOV [W0+4], W0
002BF6  780190     MOV [W0], W3
002BF8  90080E     MOV [W14+16], W0
002BFA  904060     MOV.B [W0+6], W0
002BFC  FB8200     ZE W0, W4
002BFE  200010     MOV #0x1, W0
002C00  200001     MOV #0x0, W1
002C02  780284     MOV W4, W5
002C04  E90285     DEC W5, W5
002C06  330003     BRA N, .LE1367
002C08  400000     ADD W0, W0, W0
002C0A  488081     ADDC W1, W1, W1
002C0C  37FFFB     BRA .LB1367
002C0E  780000     MOV W0, W0
002C10  700003     IOR W0, W3, W0
002C12  780900     MOV W0, [W2]
405:                   }
406:                   if(lat_cs == 0){
002C14  90482E     MOV.B [W14+10], W0
002C16  E00400     CP0.B W0
002C18  3A0015     BRA NZ, .L74
407:                       CLEAR_BIT(cs->lat_r, cs->n);
002C1A  90081E     MOV [W14+18], W0
002C1C  900120     MOV [W0+4], W2
002C1E  90081E     MOV [W14+18], W0
002C20  900020     MOV [W0+4], W0
002C22  780190     MOV [W0], W3
002C24  90081E     MOV [W14+18], W0
002C26  904060     MOV.B [W0+6], W0
002C28  FB8200     ZE W0, W4
002C2A  200010     MOV #0x1, W0
002C2C  200001     MOV #0x0, W1
002C2E  780284     MOV W4, W5
002C30  E90285     DEC W5, W5
002C32  330003     BRA N, .LE1387
002C34  400000     ADD W0, W0, W0
002C36  488081     ADDC W1, W1, W1
002C38  37FFFB     BRA .LB1387
002C3A  780000     MOV W0, W0
002C3C  EA8000     COM W0, W0
002C3E  618000     AND W3, W0, W0
002C40  780900     MOV W0, [W2]
002C42  370013     BRA .L52
408:                   } else {
409:                       SET_BIT(cs->lat_r, cs->n);
002C44  90081E     MOV [W14+18], W0
002C46  900120     MOV [W0+4], W2
002C48  90081E     MOV [W14+18], W0
002C4A  900020     MOV [W0+4], W0
002C4C  780190     MOV [W0], W3
002C4E  90081E     MOV [W14+18], W0
002C50  904060     MOV.B [W0+6], W0
002C52  FB8200     ZE W0, W4
002C54  200010     MOV #0x1, W0
002C56  200001     MOV #0x0, W1
002C58  780284     MOV W4, W5
002C5A  E90285     DEC W5, W5
002C5C  330003     BRA N, .LE1406
002C5E  400000     ADD W0, W0, W0
002C60  488081     ADDC W1, W1, W1
002C62  37FFFB     BRA .LB1406
002C64  780000     MOV W0, W0
002C66  700003     IOR W0, W3, W0
002C68  780900     MOV W0, [W2]
410:                   }
411:               }
002C6A  FA8000     ULNK
002C6C  060000     RETURN
412:               
413:               spi_message_t* init_spi_message(spi_message_t* m, uint16_t* write_data, uint16_t* read_data, uint8_t length, const pin_t* pin){
002C6E  FA000A     LNK #0xA
002C70  780F00     MOV W0, [W14]
002C72  980711     MOV W1, [W14+2]
002C74  980722     MOV W2, [W14+4]
002C76  984763     MOV.B W3, [W14+6]
002C78  980744     MOV W4, [W14+8]
414:                   m->cs_pin = (*pin);
002C7A  78001E     MOV [W14], W0
002C7C  9000CE     MOV [W14+8], W1
002C7E  780211     MOV [W1], W4
002C80  900291     MOV [W1+2], W5
002C82  900321     MOV [W1+4], W6
002C84  9003B1     MOV [W1+6], W7
002C86  980034     MOV W4, [W0+6]
002C88  980045     MOV W5, [W0+8]
002C8A  980056     MOV W6, [W0+10]
002C8C  980067     MOV W7, [W0+12]
415:                   m->write_data = write_data;
002C8E  78001E     MOV [W14], W0
002C90  90029E     MOV [W14+2], W5
002C92  780805     MOV W5, [W0]
416:                   m->read_data = read_data;
002C94  78001E     MOV [W14], W0
002C96  90032E     MOV [W14+4], W6
002C98  980016     MOV W6, [W0+2]
417:                   m->data_length = length;
002C9A  78001E     MOV [W14], W0
002C9C  9043EE     MOV.B [W14+6], W7
002C9E  984047     MOV.B W7, [W0+4]
418:                   if(length == 0){
002CA0  90406E     MOV.B [W14+6], W0
002CA2  E00400     CP0.B W0
002CA4  3A0004     BRA NZ, .L77
419:                       m->status = SPI_TRANSFER_DONE;
002CA6  78001E     MOV [W14], W0
002CA8  200011     MOV #0x1, W1
002CAA  980071     MOV W1, [W0+14]
002CAC  370003     BRA .L78
420:                   } else {
421:                       m->status = SPI_TRANSFER_PENDING;
002CAE  78001E     MOV [W14], W0
002CB0  EB0080     CLR W1
002CB2  980071     MOV W1, [W0+14]
422:                   }
423:                   
424:                   return m;
002CB4  78001E     MOV [W14], W0
425:               }
002CB6  FA8000     ULNK
002CB8  060000     RETURN
---  /home/opieters/PhD/gloxinia/src/lib/pga.c  ---------------------------------------------------------
1:                 #include <xc.h> 
2:                 #include <pga.h>
3:                 #include <spi.h>
4:                 #include <utilities.h>
5:                 
6:                 
7:                 uint8_t pga_convert_channel_to_bits(pga_mux_channel_t channel){
00400A  FA0002     LNK #0x2
00400C  780F00     MOV W0, [W14]
8:                     switch(channel){
00400E  78001E     MOV [W14], W0
004010  500FE2     SUB W0, #0x2, [W15]
004012  320012     BRA Z, .L5
004014  500FE2     SUB W0, #0x2, [W15]
004016  3E0005     BRA GTU, .L9
004018  E00000     CP0 W0
00401A  32000A     BRA Z, .L3
00401C  500FE1     SUB W0, #0x1, [W15]
00401E  32000A     BRA Z, .L4
004020  370013     BRA .L2
004022  500FE4     SUB W0, #0x4, [W15]
004024  32000D     BRA Z, .L7
004026  500FE4     SUB W0, #0x4, [W15]
004028  390009     BRA NC, .L6
00402A  500FE5     SUB W0, #0x5, [W15]
00402C  32000B     BRA Z, .L8
00402E  37000C     BRA .L2
9:                         case PGA_MUX_VCAL_CH0:
10:                            return 0b0000;
004030  EB4000     CLR.B W0
004032  37000B     BRA .L10
11:                            break;
12:                        case PGA_MUX_CH1:
13:                            return 0b0001;
004034  B3C010     MOV.B #0x1, W0
004036  370009     BRA .L10
14:                            break;
15:                        case PGA_CAL1:
16:                            return 0b1100;
004038  B3C0C0     MOV.B #0xC, W0
00403A  370007     BRA .L10
17:                            break;
18:                        case PGA_CAL2:
19:                            return 0b1101;
00403C  B3C0D0     MOV.B #0xD, W0
00403E  370005     BRA .L10
20:                            break;
21:                        case PGA_CAL3:
22:                            return 0b1110;
004040  B3C0E0     MOV.B #0xE, W0
004042  370003     BRA .L10
23:                            break;
24:                        case PGA_CAL4:
25:                            return 0b1111;
004044  B3C0F0     MOV.B #0xF, W0
004046  370001     BRA .L10
26:                            break;
27:                        default:
28:                            return 0b0000;
004048  EB4000     CLR.B W0
29:                            break;
30:                    }
31:                }
00404A  FA8000     ULNK
00404C  060000     RETURN
32:                
33:                uint8_t pga_convert_gain_to_bits(pga_gain_t channel){
00404E  FA0002     LNK #0x2
004050  780F00     MOV W0, [W14]
34:                    switch(channel){
004052  78001E     MOV [W14], W0
004054  500FE3     SUB W0, #0x3, [W15]
004056  320016     BRA Z, .L16
004058  500FE3     SUB W0, #0x3, [W15]
00405A  3E0005     BRA GTU, .L21
00405C  500FE1     SUB W0, #0x1, [W15]
00405E  32000E     BRA Z, .L14
004060  500FE1     SUB W0, #0x1, [W15]
004062  3E000E     BRA GTU, .L15
004064  370009     BRA .L23
004066  500FE5     SUB W0, #0x5, [W15]
004068  320011     BRA Z, .L18
00406A  500FE5     SUB W0, #0x5, [W15]
00406C  39000D     BRA NC, .L17
00406E  500FE6     SUB W0, #0x6, [W15]
004070  32000F     BRA Z, .L19
004072  500FE7     SUB W0, #0x7, [W15]
004074  32000F     BRA Z, .L20
004076  370010     BRA .L24
35:                        case PGA_GAIN_1:
36:                            return 0b0000;
004078  EB4000     CLR.B W0
00407A  37000F     BRA .L22
37:                            break;
38:                        case PGA_GAIN_2:
39:                            return 0b0001;
00407C  B3C010     MOV.B #0x1, W0
00407E  37000D     BRA .L22
40:                            break;
41:                        case PGA_GAIN_5:
42:                            return 0b0010;
004080  B3C020     MOV.B #0x2, W0
004082  37000B     BRA .L22
43:                            break;
44:                        case PGA_GAIN_10:
45:                            return 0b0011;
004084  B3C030     MOV.B #0x3, W0
004086  370009     BRA .L22
46:                            break;
47:                        case PGA_GAIN_20:
48:                            return 0b0100;
004088  B3C040     MOV.B #0x4, W0
00408A  370007     BRA .L22
49:                            break;
50:                        case PGA_GAIN_50:
51:                            return 0b0101;
00408C  B3C050     MOV.B #0x5, W0
00408E  370005     BRA .L22
52:                            break;
53:                        case PGA_GAIN_100:
54:                            return 0b0110;
004090  B3C060     MOV.B #0x6, W0
004092  370003     BRA .L22
55:                            break;
56:                        case PGA_GAIN_200:
57:                            return 0b0111;
004094  B3C070     MOV.B #0x7, W0
004096  370001     BRA .L22
58:                            break;
59:                        default:
60:                            return 0b0000;
004098  EB4000     CLR.B W0
61:                            break;
62:                    }
63:                }
00409A  FA8000     ULNK
00409C  060000     RETURN
64:                
65:                void init_pga(pga_config_t* config){
00409E  FA0002     LNK #0x2
0040A0  780F00     MOV W0, [W14]
66:                    // configure nCS pin as output 
67:                    CLEAR_BIT(config->cs_pin.tris_r, config->cs_pin.n);
0040A2  78001E     MOV [W14], W0
0040A4  900140     MOV [W0+8], W2
0040A6  78001E     MOV [W14], W0
0040A8  900040     MOV [W0+8], W0
0040AA  780190     MOV [W0], W3
0040AC  78001E     MOV [W14], W0
0040AE  904840     MOV.B [W0+12], W0
0040B0  FB8200     ZE W0, W4
0040B2  200010     MOV #0x1, W0
0040B4  200001     MOV #0x0, W1
0040B6  780284     MOV W4, W5
0040B8  E90285     DEC W5, W5
0040BA  330003     BRA N, .LE185
0040BC  400000     ADD W0, W0, W0
0040BE  488081     ADDC W1, W1, W1
0040C0  37FFFB     BRA .LB185
0040C2  780000     MOV W0, W0
0040C4  EA8000     COM W0, W0
0040C6  618000     AND W3, W0, W0
0040C8  780900     MOV W0, [W2]
68:                    SET_BIT(config->cs_pin.lat_r, config->cs_pin.n);
0040CA  78001E     MOV [W14], W0
0040CC  900150     MOV [W0+10], W2
0040CE  78001E     MOV [W14], W0
0040D0  900050     MOV [W0+10], W0
0040D2  780190     MOV [W0], W3
0040D4  78001E     MOV [W14], W0
0040D6  904840     MOV.B [W0+12], W0
0040D8  FB8200     ZE W0, W4
0040DA  200010     MOV #0x1, W0
0040DC  200001     MOV #0x0, W1
0040DE  780284     MOV W4, W5
0040E0  E90285     DEC W5, W5
0040E2  330003     BRA N, .LE200
0040E4  400000     ADD W0, W0, W0
0040E6  488081     ADDC W1, W1, W1
0040E8  37FFFB     BRA .LB200
0040EA  780000     MOV W0, W0
0040EC  700003     IOR W0, W3, W0
0040EE  780900     MOV W0, [W2]
69:                    
70:                    update_pga_status(config);
0040F0  78001E     MOV [W14], W0
0040F2  070002     RCALL update_pga_status
71:                }
0040F4  FA8000     ULNK
0040F6  060000     RETURN
72:                
73:                void update_pga_status(pga_config_t* config){
0040F8  FA0016     LNK #0x16
0040FA  781F88     MOV W8, [W15++]
0040FC  980F20     MOV W0, [W14+20]
74:                    spi_message_t m;
75:                    uint16_t write_buffer[1], read_buffer[1];
76:                    m.cs_pin = config->cs_pin;
0040FE  90082E     MOV [W14+20], W0
004100  900230     MOV [W0+6], W4
004102  9002C0     MOV [W0+8], W5
004104  900350     MOV [W0+10], W6
004106  9003E0     MOV [W0+12], W7
004108  980734     MOV W4, [W14+6]
00410A  980745     MOV W5, [W14+8]
00410C  980756     MOV W6, [W14+10]
00410E  980767     MOV W7, [W14+12]
77:                    
78:                    m.write_data = write_buffer;
004110  470F70     ADD W14, #0x10, [W14]
79:                    m.read_data = read_buffer;
004112  470072     ADD W14, #0x12, W0
004114  980710     MOV W0, [W14+2]
80:                    m.data_length = 1;
004116  B3C010     MOV.B #0x1, W0
004118  984740     MOV.B W0, [W14+4]
81:                    
82:                    switch(config->status){
00411A  90082E     MOV [W14+20], W0
00411C  900020     MOV [W0+4], W0
00411E  500FE1     SUB W0, #0x1, [W15]
004120  320005     BRA Z, .L29
004122  500FE1     SUB W0, #0x1, [W15]
004124  39001F     BRA NC, .L28
004126  500FE2     SUB W0, #0x2, [W15]
004128  32001D     BRA Z, .L28
83:                        case PGA_STATUS_ON:
84:                            // enable device
85:                            write_buffer[0] = 0xE100;
00412C  2E1000     MOV #0xE100, W0
00412E  980F00     MOV W0, [W14+16]
86:                            
87:                            m.status = SPI_TRANSFER_PENDING;
004130  EB0000     CLR W0
004132  980770     MOV W0, [W14+14]
88:                            config->spi_message_handler(&m);
004134  90082E     MOV [W14+20], W0
004136  9000F0     MOV [W0+14], W1
004138  78000E     MOV W14, W0
00413A  010001     CALL W1
89:                            
90:                            // send the switch channel command
91:                            write_buffer[0] = 0x2A00 
004154  980F00     MOV W0, [W14+16]
92:                                    | (pga_convert_gain_to_bits(config->gain) << 4) 
00413C  90082E     MOV [W14+20], W0
00413E  900010     MOV [W0+2], W0
004140  07FF86     RCALL pga_convert_gain_to_bits
004142  FB8000     ZE W0, W0
004144  DD00C4     SL W0, #4, W1
004146  22A000     MOV #0x2A00, W0
004148  700401     IOR W0, W1, W8
93:                                    | pga_convert_channel_to_bits(config->channel);
00414A  90082E     MOV [W14+20], W0
00414C  780010     MOV [W0], W0
00414E  07FF5D     RCALL pga_convert_channel_to_bits
004150  FB8000     ZE W0, W0
004152  700008     IOR W0, W8, W0
94:                            m.status = SPI_TRANSFER_PENDING;
004156  EB0000     CLR W0
004158  980770     MOV W0, [W14+14]
95:                            config->spi_message_handler(&m);
00415A  90082E     MOV [W14+20], W0
00415C  9000F0     MOV [W0+14], W1
00415E  78000E     MOV W14, W0
004160  010001     CALL W1
96:                            
97:                            
98:                            break;
004162  370009     BRA .L26
99:                        case PGA_STATUS_OFF:
100:                       case PGA_STATUS_ERROR:
101:                           // disable device
102:                           
103:                           write_buffer[0] = 0xE1F1;
004164  2E1F10     MOV #0xE1F1, W0
004166  980F00     MOV W0, [W14+16]
104:                           
105:                           m.status = SPI_TRANSFER_PENDING;
004168  EB0000     CLR W0
00416A  980770     MOV W0, [W14+14]
106:                           config->spi_message_handler(&m);
00416C  90082E     MOV [W14+20], W0
00416E  9000F0     MOV [W0+14], W1
004170  78000E     MOV W14, W0
004172  010001     CALL W1
107:                           break;
004174  000000     NOP
108:                       default:
109:                           break;
00412A  370025     BRA .L26
110:                   }
111:               
112:                   
113:               }
004176  78044F     MOV [--W15], W8
004178  FA8000     ULNK
00417A  060000     RETURN
114:               
115:               #ifdef A
116:               spi_message_t m;
117:                   uint16_t write_data[1];
118:                   uint16_t read_data[1];
119:                   uint8_t write_data2[2];
120:                   uint8_t read_data2[2];
121:                   uint16_t length;
122:                   
123:                   m.read_data = read_data;
124:                   m.write_data = write_data;
125:                   m.status = SPI_TRANSFER_PENDING;
126:                   m.cs_pin = config->cs_pin;
127:                   
128:                   pin_t sck = PIN_INIT(G, 6);
129:                   pin_t sdo = PIN_INIT(G, 8);
130:                   pin_t sdi = PIN_INIT(G, 7);
131:                   pin_t cs = PIN_INIT(G, 9);
132:                   pin_t cs2 = PIN_INIT(B, 8);
133:               
134:               // test config
135:                   pin_t sck2 = PIN_INIT(D, 1);
136:                   pin_t sdo2 = PIN_INIT(D, 3);
137:                   pin_t sdi2 = PIN_INIT(D, 4); // not used
138:                   pin_t cs3 = PIN_INIT(D, 2); // not used
139:                   
140:                   switch(config->status){
141:                       
142:                       case PGA_STATUS_ON:
143:                           write_data[0] = 0xD100; 
144:                           
145:                           write_data2[0] = 0xD1; 
146:                           write_data2[1] = 0x00;
147:                           m.data_length = 1;
148:                           length = 2;
149:                           software_spi(&sck, &sdo, &sdi, &cs, write_data2, read_data2, length, 1000);
150:                           software_spi(&sck, &sdo, &sdi, &cs2, write_data2, read_data2, length, 1000);
151:                           software_spi(&sck2, &sdo2, &sdi2, &cs3, write_data2, read_data2, length, 1000);
152:                           
153:                           write_data[1] = (0x2A << 8) 
154:                                   | (pga_convert_gain_to_bits(config->gain) << 4) 
155:                                   | pga_convert_channel_to_bits(config->channel);
156:                           write_data2[2] = 0x2A;
157:                           write_data2[3] = (pga_convert_gain_to_bits(config->gain) << 4) 
158:                                   | pga_convert_channel_to_bits(config->channel);
159:                           
160:                           m.data_length = 1;
161:                           length = 2;
162:                           software_spi(&sck, &sdo, &sdi, &cs, write_data2, read_data2, length, 1000);
163:                           software_spi(&sck, &sdo, &sdi, &cs2, write_data2, read_data2, length, 1000);
164:                           software_spi(&sck2, &sdo2, &sdi2, &cs3, write_data2, read_data2, length, 1000);
165:                           
166:                           break;
167:                       case PGA_STATUS_OFF:
168:                       case PGA_STATUS_ERROR:
169:               
170:                           /*write_data[0] = 0xD1F1;
171:                           write_data2[0] = 0xD1;
172:                           write_data2[1] = 0xF1;
173:                           m.data_length = 1;
174:                           length = 2;
175:                           
176:                           software_spi(&sck, &sdo, &sdi, &cs, write_data2, read_data2, length, 1000);
177:                           software_spi(&sck, &sdo, &sdi, &cs2, write_data2, read_data2, length, 1000);
178:                           software_spi(&sck2, &sdo2, &sdi2, &cs3, write_data2, read_data2, length, 1000);*/
179:                           break;
180:                   }
181:                   
182:                   // TODO (feature): read status after write to verify if it was updated
183:                   // correctly
184:                   //send_spi2_message(&m);
185:                   
186:                   //write_data2[0] = 0b01010100;
187:                   //write_data2[1] = 0b
188:                   // actual config
189:               #endif
---  /home/opieters/PhD/gloxinia/src/lib/lia_mixing.s  --------------------------------------------------
                                                  1:     
                                                  2:     ; this routine computes the output of a mixer to build a LIA, assuming the 
                                                  3:     ; sampling frequency is 4x higher than the main component's frequency
                                                  4:         .global _lia_mixer ; name of the function
                                                  5:     ; this function has 5 arguments:
                                                  6:     ;  - w0 = number of samples to be filtered
                                                  7:     ;  - w1 = address of first sample to be filtered
                                                  8:     ;  - w2 = address of first I sample
                                                  9:     ;  - w3 = address of first Q sample
                                                  10:    ;  - w4 = DC offset to be added to samples (can be used to correct DC offset
                                                  11:    ;         that might saturate the output)
                                                  12:    _lia_mixer:
                                                  13:        ;push       w5                ; save this register (not one of the arguments)
                                                  14:    
004410  DE0042     LSR W0, #2, W0                 15:        lsr        w0, #2, w0        ; divide number of samples by 4
004412  E90000     DEC W0, W0                     16:        dec        w0, w0            ; adjust for number of data entries
                                                  17:    
004414  088000     DO W0, 0x4422                  18:        do         w0, _end_mixer  ; do instructions: perform loop w0+1 times
004418  421931     ADD W4, [W1++], [W2++]         19:        add        w4, [w1++], [w2++]; i(n)   =  1 * x(n)   + DC
                                                  20:        ;clr	       [w3++]
00441A  4219B1     ADD W4, [W1++], [W3++]         21:        add        w4, [w1++], [w3++]; q(n+1) =  1 * x(n+1) + DC
                                                  22:        ;clr	       [w2++]
                                                  23:        ;add        w4, [w1++], w5
00441C  420891     ADD W4, [W1], [W1]             24:        add        w4, [w1], [w1]
00441E  EA1931     NEG [W1++], [W2++]             25:        neg        [w1++], [w2++]        ; i(n+2) = -1 * x(n+2) - DC
                                                  26:        ;clr	       [w3++]
004420  420891     ADD W4, [W1], [W1]             27:        add        w4, [w1], [w1]
                                                  28:        ;clr	       [w2++]
                                                  29:    _end_mixer:
004422  EA19B1     NEG [W1++], [W3++]             30:        neg        [w1++], [w3++]        ; q(n+3) = -1 * x(n+3) - DC
                                                  31:        ;pop        w5
004424  060000     RETURN                         32:        return
                                                  33:        
                                                  34:    ;--------------
                                                  35:    ; alternative version 
                                                  36:    ;--------------
                                                  37:    ;
                                                  38:    ; this routine computes the output of a mixer to build a LIA, assuming the 
                                                  39:    ; sampling frequency is 4x higher than the main component's frequency
                                                  40:        .global _lia_mixer_no_dc ; name of the function
                                                  41:    ; this function has 5 arguments:
                                                  42:    ;  - w0 = number of samples to be filtered
                                                  43:    ;  - w1 = address of first sample to be filtered
                                                  44:    ;  - w2 = address of first I sample
                                                  45:    ;  - w3 = address of first Q sample
                                                  46:    _lia_mixer_no_dc:
004426  DE0042     LSR W0, #2, W0                 47:        lsr        w0, #2, w0        ; divide number of samples by 4
004428  E90000     DEC W0, W0                     48:        dec        w0, w0            ; adjust for number of data entries
                                                  49:    
00442A  088000     DO W0, 0x4434                  50:        do         w0, _end_mixer_no_dc  ; do instructions: perform loop w0+1 times
00442E  781931     MOV [W1++], [W2++]             51:        mov        [w1++], [w2++]        ; i(n)   =  1 * x(n)
004430  7819B1     MOV [W1++], [W3++]             52:        mov        [w1++], [w3++]        ; q(n+1) =  1 * x(n+1)
004432  EA1931     NEG [W1++], [W2++]             53:        neg        [w1++], [w2++]        ; i(n+2) = -1 * x(n+2) TODO: attention!! if 0x8000 is located in w1, the data in w2 will be INVALID!
                                                  54:    _end_mixer_no_dc:
004434  EA19B1     NEG [W1++], [W3++]             55:        neg        [w1++], [w3++]        ; q(n+3) = -1 * x(n+3)
004436  060000     RETURN                         56:        return
                                                  57:        
                                                  58:    ; this routine computes the output of a mixer to build a LIA, assuming the 
                                                  59:    ; sampling frequency is 4x higher than the main component's frequency and the
                                                  60:    ; source buffer MUST be stored in EDS. The visibility is automatically changed
                                                  61:    ; and restored afterwards
                                                  62:        .global _lia_mixer_no_dc_eds ; name of the function
                                                  63:    ; this function has 5 arguments:
                                                  64:    ;  - w0 = number of samples to be filtered
                                                  65:    ;  - w1 = address of first sample to be filtered
                                                  66:    ;  - w2 = address of first I sample
                                                  67:    ;  - w3 = address of first Q sample
                                                  68:    _lia_mixer_no_dc_eds:
004438  800194     MOV DSRPAG, W4                 69:        mov        DSRPAG, w4
00443A  200015     MOV #0x1, W5                   70:        mov        #0x1, w5
00443C  880195     MOV W5, DSRPAG                 71:        mov        w5, DSRPAG
00443E  DE0042     LSR W0, #2, W0                 72:        lsr        w0, #2, w0        ; divide number of samples by 4
004440  E90000     DEC W0, W0                     73:        dec        w0, w0            ; adjust for number of data entries
                                                  74:    
004442  088000     DO W0, 0x444C                  75:        do         w0, _end_mixer_no_dc_eds  ; do instructions: perform loop w0+1 times
004446  781931     MOV [W1++], [W2++]             76:        mov        [w1++], [w2++]        ; i(n)   =  1 * x(n)
004448  7819B1     MOV [W1++], [W3++]             77:        mov        [w1++], [w3++]        ; q(n+1) =  1 * x(n+1)
00444A  EA1931     NEG [W1++], [W2++]             78:        neg        [w1++], [w2++]        ; i(n+2) = -1 * x(n+2) TODO: attention!! if 0x8000 is located in w1, the data in w2 will be INVALID!
                                                  79:    _end_mixer_no_dc_eds:
00444C  EA19B1     NEG [W1++], [W3++]             80:        neg        [w1++], [w3++]        ; q(n+3) = -1 * x(n+3)
00444E  880194     MOV W4, DSRPAG                 81:        mov        w4, DSRPAG
004450  060000     RETURN                         82:        return
                                                  83:        
                                                  84:        
                                                  85:    ;--------------
                                                  86:    ; alternative version 
                                                  87:    ;--------------
                                                  88:    ;
                                                  89:    ; this routine computes the output of a mixer to build a LIA, assuming the 
                                                  90:    ; sampling frequency is 4x higher than the main component's frequency
                                                  91:        .global _lia_mixer_no_dc2 ; name of the function
                                                  92:    ; this function has 5 arguments:
                                                  93:    ;  - w0 = number of samples to be filtered
                                                  94:    ;  - w1 = address of first sample to be filtered
                                                  95:    ;  - w2 = address of first I sample of LIA1
                                                  96:    ;  - w3 = address of first Q sample of LIA1
                                                  97:    ;  - w4 = address of first I sample of LIA2
                                                  98:    ;  - w5 = address of first Q sample of LIA2
                                                  99:    _lia_mixer_no_dc2:
004452  DE0043     LSR W0, #3, W0                 100:       lsr        w0, #3, w0        ; divide number of samples by 8
004454  E90000     DEC W0, W0                     101:       dec        w0, w0            ; adjust for number of data entries
004456  420204     ADD W4, W4, W4                 102:       add        w4, w4, w4        ; multiply by 2 (we need word addresses)
004458  420081     ADD W4, W1, W1                 103:       add        w4, w1, w1        ; shift start address
                                                  104:   
00445A  088000     DO W0, 0x446C                  105:       do         w0, _end_mixer_no_dc2  ; do instructions: perform loop w0+1 times
00445E  781931     MOV [W1++], [W2++]             106:       mov        [w1++], [w2++]        ; i1(n)   =  1 * x(n)
004460  781A31     MOV [W1++], [W4++]             107:       mov        [w1++], [w4++]        ; i2(n)   =  1 * x(n+1)
004462  7819B1     MOV [W1++], [W3++]             108:       mov        [w1++], [w3++]        ; q1(n+1) =  1 * x(n+2)
004464  781AB1     MOV [W1++], [W5++]             109:       mov        [w1++], [w5++]        ; q2(n+1) =  1 * x(n+3)
004466  EA1931     NEG [W1++], [W2++]             110:       neg        [w1++], [w2++]        ; i1(n+2) = -1 * x(n+4) TODO: attention!! if 0x8000 is located in w1, the data in w2 will be INVALID!
004468  EA1A31     NEG [W1++], [W4++]             111:       neg        [w1++], [w4++]        ; i2(n+2) = -1 * x(n+5) TODO: attention!! if 0x8000 is located in w1, the data in w2 will be INVALID!
00446A  EA19B1     NEG [W1++], [W3++]             112:       neg        [w1++], [w3++]        ; q1(n+3) = -1 * x(n+6)
                                                  113:   _end_mixer_no_dc2:
00446C  EA1AB1     NEG [W1++], [W5++]             114:       neg        [w1++], [w5++]        ; q2(n+3) = -1 * x(n+7)
00446E  060000     RETURN                         115:       return
                                                  116:       
                                                  117:       
                                                  118:       .global _sample_copy
                                                  119:   _sample_copy:
004470  E90000     DEC W0, W0                     120:       dec w0, w0
004472  098000     REPEAT W0                      121:       repeat w0
004474  781931     MOV [W1++], [W2++]             122:       mov [w1++], [w2++]
004476  060000     RETURN                         123:       return
                                                  124:       
---  /home/opieters/PhD/gloxinia/src/lib/i2c.c  ---------------------------------------------------------
1:                 /*
2:                  * File:   i2c.c
3:                  * Author: opieters
4:                  *
5:                  * Created on June 28, 2018, 6:04 PM
6:                  */
7:                 
8:                 
9:                 #include <xc.h>
10:                #include <i2c.h>
11:                #include <stddef.h>
12:                #include <string.h>
13:                #include <uart.h>
14:                #include <device_configuration.h>
15:                #include <utilities.h>
16:                #include <p33EP512MC806.h>
17:                
18:                typedef enum {
19:                    I2C_CALLBACK_NONE,
20:                    I2C_CALLBACK_M_READ_S_WRITE,
21:                    I2C_CALLBACK_M_WRITE_S_READ,
22:                }i2c_callback_status_t;
23:                
24:                i2c_mstatus_t (*i2c_transciever_controller)(void);
25:                i2c_mstatus_t (*i2c_transciever_reset)(void);
26:                //i2c_error_status_t i2c_error = I2C_NO_ERROR;
27:                
28:                volatile uint8_t transfer_done = 0;
29:                
30:                volatile uint8_t i2c_transfer;
31:                
32:                volatile i2c_bus_status_t i2c1_bus_status = I2C_BUS_DISABLED; 
33:                volatile i2c_bus_status_t i2c2_bus_status = I2C_BUS_DISABLED; 
34:                
35:                i2c_reset_sensor_t i2c_bus_reset[N_I2C_DEVICE_RESET_CALLBACKS];
36:                
37:                
38:                i2c_message_t* i2c_message_queue [I2C_MESSAGE_BUFFER_LENGTH];
39:                volatile uint8_t i2c_queue_idx = 0;
40:                volatile uint8_t i2c_queue_valid = 0;
41:                volatile uint8_t n_i2c_queued_messages = 0;
42:                
43:                static volatile uint8_t i2c_transfer_status = 0;
44:                
45:                
46:                static pin_t i2c1_scl_pin, i2c2_scl_pin;
47:                static pin_t i2c1_sda_pin, i2c2_sda_pin;
48:                i2c_slave_state_t i2c1_state = I2C_SLAVE_STATE_IDLE, i2c2_state = I2C_SLAVE_STATE_IDLE;
49:                
50:                void (*i2c_slave_mw_sr_callback) (i2c_message_t*) = NULL;
51:                void (*i2c_slave_mr_sw_callback) (i2c_message_t*) = NULL;
52:                volatile i2c_callback_status_t callback_status = I2C_CALLBACK_NONE;
53:                
54:                static i2c_message_t* i2c_slave_mr_sw_message;
55:                static i2c_message_t i2c_slave_mw_sr_message;
56:                static uint8_t i2c_slave_mw_sr_data[I2C_W_MESSAGE_BUFFER_LENGTH];
57:                uint8_t n_slave_write_transfers = 0;
58:                
59:                volatile uint8_t i2c_slave_continue = 0;
60:                
61:                volatile uint8_t stop_detected = 0, start_detected = 0;
62:                
63:                
64:                void run_i2c_slave(void){
0012D6  FA0000     LNK #0x0
65:                    if(callback_status != I2C_CALLBACK_NONE){
0012D8  8081B0     MOV callback_status, W0
0012DA  E00000     CP0 W0
0012DC  320017     BRA Z, .L2
66:                        switch(callback_status){
0012DE  8081B0     MOV callback_status, W0
0012E0  500FE1     SUB W0, #0x1, [W15]
0012E2  320003     BRA Z, .L4
0012E4  500FE2     SUB W0, #0x2, [W15]
0012E6  320008     BRA Z, .L5
67:                            case I2C_CALLBACK_M_READ_S_WRITE:
68:                                if(i2c_slave_mr_sw_callback != NULL){
0012EA  8081A0     MOV i2c_slave_mr_sw_callback, W0
0012EC  E00000     CP0 W0
0012EE  32000B     BRA Z, .L11
69:                                    i2c_slave_mr_sw_callback(i2c_slave_mr_sw_message);
0012F0  8081A1     MOV i2c_slave_mr_sw_callback, W1
0012F2  8081C0     MOV i2c_slave_mr_sw_message, W0
0012F4  010001     CALL W1
70:                                }
71:                                break;
0012F6  37000A     BRA .L2
001306  000000     NOP
001308  370001     BRA .L2
72:                            case I2C_CALLBACK_M_WRITE_S_READ:
73:                                if(i2c_slave_mw_sr_callback != NULL){
0012F8  808190     MOV i2c_slave_mw_sr_callback, W0
0012FA  E00000     CP0 W0
0012FC  320006     BRA Z, .L12
74:                                    i2c_slave_mw_sr_callback(&i2c_slave_mw_sr_message);
0012FE  808191     MOV i2c_slave_mw_sr_callback, W1
001300  24B2C0     MOV #0x4B2C, W0
001302  010001     CALL W1
75:                                }
76:                                break;
001304  370003     BRA .L2
00130A  000000     NOP
77:                            default:
78:                                break;
0012E8  370011     BRA .L2
79:                
80:                        }
81:                    }
82:                    if((i2c1_state != I2C_SLAVE_STATE_IDLE) && (stop_detected == 0) && (I2C1STATbits.P == 1)){
00130C  808170     MOV i2c1_state, W0
00130E  E00000     CP0 W0
001310  32000A     BRA Z, .L8
001312  BFD03C     MOV.B stop_detected, WREG
001314  E00400     CP0.B W0
001316  3A0007     BRA NZ, .L8
001318  801040     MOV I2C1STAT, W0
00131A  600070     AND W0, #0x10, W0
00131C  E00000     CP0 W0
00131E  320003     BRA Z, .L8
83:                        stop_detected = 1;
001320  B3C010     MOV.B #0x1, W0
001322  B7F03C     MOV.B WREG, stop_detected
84:                        _SI2C1IF = 1;
001324  A80802     BSET IFS1, #0
85:                    }
86:                    // TODO
87:                    if(I2C2STATbits.P == 1){
001326  8010C0     MOV I2C2STAT, W0
001328  600070     AND W0, #0x10, W0
00132A  E00000     CP0 W0
00132C  320001     BRA Z, .L9
88:                        _SI2C2IF = 1;
00132E  A82806     BSET IFS3, #1
89:                    }
90:                    
91:                    if(i2c_slave_continue == 1){
001330  BFD03B     MOV.B i2c_slave_continue, WREG
001332  504FE1     SUB.B W0, #0x1, [W15]
001334  3A0002     BRA NZ, .L1
92:                        process_i2c_slave_auto();
001336  07062E     RCALL process_i2c_slave_auto
93:                        i2c_slave_continue = 0;
001338  EF703B     CLR.B i2c_slave_continue
94:                    }
95:                }
00133A  FA8000     ULNK
00133C  060000     RETURN
96:                
97:                void add_i2c_reset_callback(i2c_bus_t i2c_bus, uint8_t address, void (*reset)(void), void (*init)(void)){
00133E  FA0008     LNK #0x8
001340  780F00     MOV W0, [W14]
001342  984721     MOV.B W1, [W14+2]
001344  980722     MOV W2, [W14+4]
001346  980733     MOV W3, [W14+6]
98:                    static uint8_t n_i2c_callbacks = 0;
99:                    if(n_i2c_callbacks < N_I2C_DEVICE_RESET_CALLBACKS){
001348  BFD047     MOV.B n_i2c_callbacks, WREG
00134A  504FE4     SUB.B W0, #0x4, [W15]
00134C  3E001B     BRA GTU, .L14
100:                       i2c_bus_reset[n_i2c_callbacks].reset = reset;
00134E  BFD047     MOV.B n_i2c_callbacks, WREG
001350  FB8000     ZE W0, W0
001352  DD00C3     SL W0, #3, W1
001354  24AC80     MOV #0x4AC8, W0
001356  408000     ADD W1, W0, W0
001358  9000AE     MOV [W14+4], W1
00135A  780801     MOV W1, [W0]
101:                       i2c_bus_reset[n_i2c_callbacks].init = init;
00135C  BFD047     MOV.B n_i2c_callbacks, WREG
00135E  FB8000     ZE W0, W0
001360  DD00C3     SL W0, #3, W1
001362  24ACA0     MOV #0x4ACA, W0
001364  408000     ADD W1, W0, W0
001366  9000BE     MOV [W14+6], W1
001368  780801     MOV W1, [W0]
102:                       i2c_bus_reset[n_i2c_callbacks].address = address;
00136A  BFD047     MOV.B n_i2c_callbacks, WREG
00136C  FB8000     ZE W0, W0
00136E  DD00C3     SL W0, #3, W1
001370  24AC60     MOV #0x4AC6, W0
001372  408000     ADD W1, W0, W0
001374  9040AE     MOV.B [W14+2], W1
001376  784801     MOV.B W1, [W0]
103:                       i2c_bus_reset[n_i2c_callbacks].i2c_bus = i2c_bus;
001378  BFD047     MOV.B n_i2c_callbacks, WREG
00137A  FB8000     ZE W0, W0
00137C  DD00C3     SL W0, #3, W1
00137E  24AC40     MOV #0x4AC4, W0
001380  408000     ADD W1, W0, W0
001382  78081E     MOV [W14], [W0]
104:                   }
105:                   n_i2c_callbacks++;
001384  BFD047     MOV.B n_i2c_callbacks, WREG
001386  E84000     INC.B W0, W0
001388  B7F047     MOV.B WREG, n_i2c_callbacks
106:               }
00138A  FA8000     ULNK
00138C  060000     RETURN
107:               
108:               void i2c_reset_callback_init(void){
00138E  FA0002     LNK #0x2
109:                   // make sure this function is only executed once!
110:                   static uint8_t init_done = 0;
111:                   
112:                   if(init_done == 0){
001390  BFD046     MOV.B init_done, WREG
001392  E00400     CP0.B W0
001394  3A0021     BRA NZ, .L15, .LBE2
113:                       uint8_t i;
114:                       for(i = 0; i < N_I2C_DEVICE_RESET_CALLBACKS; i++){
001396  EB4000     CLR.B W0
001398  784F00     MOV.B W0, [W14]
00139A  370019     BRA .L17
0013CC  E84F1E     INC.B [W14], [W14]
0013CE  78401E     MOV.B [W14], W0
0013D0  504FE4     SUB.B W0, #0x4, [W15]
0013D2  36FFE4     BRA LEU, .L18
115:                           i2c_bus_reset[i].reset = NULL;
00139C  FB801E     ZE [W14], W0
00139E  DD00C3     SL W0, #3, W1
0013A0  24AC80     MOV #0x4AC8, W0
0013A2  408000     ADD W1, W0, W0
0013A4  EB0080     CLR W1
0013A6  780801     MOV W1, [W0]
116:                           i2c_bus_reset[i].init = NULL;
0013A8  FB801E     ZE [W14], W0
0013AA  DD00C3     SL W0, #3, W1
0013AC  24ACA0     MOV #0x4ACA, W0
0013AE  408000     ADD W1, W0, W0
0013B0  EB0080     CLR W1
0013B2  780801     MOV W1, [W0]
117:                           i2c_bus_reset[i].address = 0;
0013B4  FB801E     ZE [W14], W0
0013B6  DD00C3     SL W0, #3, W1
0013B8  24AC60     MOV #0x4AC6, W0
0013BA  408000     ADD W1, W0, W0
0013BC  EB4080     CLR.B W1
0013BE  784801     MOV.B W1, [W0]
118:                           i2c_bus_reset[i].i2c_bus = I2C1_BUS;
0013C0  FB801E     ZE [W14], W0
0013C2  DD00C3     SL W0, #3, W1
0013C4  24AC40     MOV #0x4AC4, W0
0013C6  408000     ADD W1, W0, W0
0013C8  EB0080     CLR W1
0013CA  780801     MOV W1, [W0]
119:                       }
120:                       init_done = 1;
0013D4  B3C010     MOV.B #0x1, W0
0013D6  B7F046     MOV.B WREG, init_done
121:                   }
122:               }
0013D8  FA8000     ULNK
0013DA  060000     RETURN
123:               
124:               void dummy_i2c_transciever_reset(i2c_message_t* m){
0013DC  FA0002     LNK #0x2
0013DE  780F00     MOV W0, [W14]
125:                   // TODO
126:               }
0013E0  FA8000     ULNK
0013E2  060000     RETURN
127:               
128:               void dummy_i2c_callback(i2c_message_t* m){
0013E4  FA0002     LNK #0x2
0013E6  780F00     MOV W0, [W14]
129:               }
0013E8  FA8000     ULNK
0013EA  060000     RETURN
130:               
131:               void init_i2c1_master(i2c_config_t* config) {
0013EC  FA0004     LNK #0x4
0013EE  980710     MOV W0, [W14+2]
132:                   uint16_t frequency;
133:                   
134:                   i2c_reset_callback_init();
0013F0  07FFCE     RCALL i2c_reset_callback_init
135:                   
136:               #ifdef __LOG__
137:                   uart_wait();
138:                   sprintf(print_buffer, "Initialised I2C module 1.");
139:                   uart_print(print_buffer, strlen(print_buffer));
140:               #endif
141:                   
142:                   transfer_done = 1;
0013F2  B3C010     MOV.B #0x1, W0
0013F4  B7F004     MOV.B WREG, transfer_done
143:                   i2c_transfer = 0;
0013F6  EF7005     CLR.B i2c_transfer
144:                   
145:                   I2C1CONbits.A10M = 0; // 7-bit slave address
0013F8  A94207     BCLR 0x207, #2
146:                   I2C1CONbits.SCLREL = 1; // release clock
0013FA  A88207     BSET 0x207, #4
147:               
148:                   frequency = FCY/(2*FREQUENCY_SCL) - DELAY_I2C*(FCY/2) - 2;
0013FC  2013E0     MOV #0x13E, W0
0013FE  780F00     MOV W0, [W14]
149:                   if(frequency>0x1FF){
001400  201FF0     MOV #0x1FF, W0
001402  78009E     MOV [W14], W1
001404  508F80     SUB W1, W0, [W15]
001406  360002     BRA LEU, .L22
150:                       frequency = 0x1FF; // max allowed value for this register
001408  201FF0     MOV #0x1FF, W0
00140A  780F00     MOV W0, [W14]
151:                   }
152:                   I2C1BRG = frequency;
00140C  78009E     MOV [W14], W1
00140E  881021     MOV W1, I2C1BRG
153:                   
154:                   I2C1ADD = 0x0; // no slave address, this is I2C master
001410  EF220A     CLR I2C1ADD
155:                   I2C1MSK = 0x0; // disable address masking for this bit position
001412  EF220C     CLR I2C1MSK
156:                   
157:                   I2C1CONbits.I2CEN = 1; // enable I2C module and configure pins as serial port pins
001414  A8E207     BSET 0x207, #7
158:                   IEC1bits.MI2C1IE = 1; // enable I2C interrupt
001416  A82822     BSET IEC1, #1
159:                   IFS1bits.MI2C1IF = 0; // clear I2C interrupt flag
001418  A92802     BCLR IFS1, #1
160:                   
161:                   i2c1_bus_status = I2C_BUS_ENABLED;
00141A  200010     MOV #0x1, W0
00141C  888030     MOV W0, i2c1_bus_status
162:                   
163:                   T2CONbits.TON = 0;
00141E  A9E111     BCLR 0x111, #7
164:                   T2CONbits.TCS = 0; // use internal instruction cycle as clock source
001420  A92110     BCLR T2CON, #1
165:                   T2CONbits.TGATE = 0; // disable gated timer
001422  A9C110     BCLR T2CON, #6
166:                   T2CONbits.TCKPS = 0b11; // prescaler 1:256
001424  800881     MOV T2CON, W1
001426  200300     MOV #0x30, W0
001428  700001     IOR W0, W1, W0
00142A  880880     MOV W0, T2CON
167:                   TMR2 = 0; // clear timer register
00142C  EF2106     CLR TMR2
168:                   PR2 = I2C_TIMER_PERIOD - 1; // set period of ADC_SAMPLE_FREQUENCY
00142E  EB8000     SETM W0
001430  880860     MOV W0, PR2
169:                   _T2IF = 0; // clear interrupt flag
001432  A9E800     BCLR IFS0, #7
170:                   _T2IE = 1; // enable interrupt
001434  A8E820     BSET IEC0, #7
171:               }
001436  FA8000     ULNK
001438  060000     RETURN
172:               
173:               
174:               
175:               void __attribute__ ( (interrupt, no_auto_psv) ) _MI2C1Interrupt( void ){
000548  781F80     MOV W0, [W15++]
00054A  FA0000     LNK #0x0
176:                   transfer_done = 1;
00054C  B3C010     MOV.B #0x1, W0
00054E  B7F004     MOV.B WREG, transfer_done
177:                   _MI2C1IF = 0;
000550  A92802     BCLR IFS1, #1
178:               }
000552  FA8000     ULNK
000554  78004F     MOV [--W15], W0
000556  064000     RETFIE
179:               
180:               void __attribute__ ( (interrupt, no_auto_psv) ) _MI2C2Interrupt( void ){
000558  781F80     MOV W0, [W15++]
00055A  FA0000     LNK #0x0
181:                   transfer_done = 1;
00055C  B3C010     MOV.B #0x1, W0
00055E  B7F004     MOV.B WREG, transfer_done
182:                   _MI2C2IF = 0;
000560  A94806     BCLR IFS3, #2
183:               }
000562  FA8000     ULNK
000564  78004F     MOV [--W15], W0
000566  064000     RETFIE
184:               
185:               inline void queue_simple_i2c_message(i2c_message_t* message){
00143A  FA0002     LNK #0x2
00143C  780F00     MOV W0, [W14]
186:                   if((message->address & 0x01) == 0){
00143E  78001E     MOV [W14], W0
001440  784010     MOV.B [W0], W0
001442  FB8000     ZE W0, W0
001444  600061     AND W0, #0x1, W0
001446  E00000     CP0 W0
001448  3A0010     BRA NZ, .L26
187:                       switch(message->i2c_bus){
00144A  78001E     MOV [W14], W0
00144C  900820     MOV [W0+20], W0
00144E  E00000     CP0 W0
001450  320003     BRA Z, .L28
001452  500FE1     SUB W0, #0x1, [W15]
001454  320005     BRA Z, .L29
188:                           case I2C1_BUS:
189:                               message->controller = default_i2c_write_controller;
001458  78001E     MOV [W14], W0
00145A  21B301     MOV #0x1B30, W1
00145C  980031     MOV W1, [W0+6]
190:                               break;
00145E  370014     BRA .L31
191:                           case I2C2_BUS:
192:                               message->controller = alt_i2c_write_controller;
001460  78001E     MOV [W14], W0
001462  21BEA1     MOV #0x1BEA, W1
001464  980031     MOV W1, [W0+6]
193:                               break;
001466  000000     NOP
001468  37000F     BRA .L31
194:                           default:
195:                               break;
001456  370018     BRA .L31
196:                       }
197:                   } else {
198:                       switch(message->i2c_bus) {
00146A  78001E     MOV [W14], W0
00146C  900820     MOV [W0+20], W0
00146E  E00000     CP0 W0
001470  320003     BRA Z, .L33
001472  500FE1     SUB W0, #0x1, [W15]
001474  320005     BRA Z, .L34
199:                           case I2C1_BUS:
200:                               message->controller = default_i2c_read_controller;
001478  78001E     MOV [W14], W0
00147A  214FE1     MOV #0x14FE, W1
00147C  980031     MOV W1, [W0+6]
201:                               break;
00147E  370004     BRA .L31
202:                           case I2C2_BUS:
203:                               message->controller = alt_i2c_read_controller;
001480  78001E     MOV [W14], W0
001482  21A681     MOV #0x1A68, W1
001484  980031     MOV W1, [W0+6]
204:                               break;
001486  000000     NOP
205:                           default:
206:                               break;
001476  370008     BRA .L31
207:                       }
208:                   }
209:                   
210:                   queue_i2c_message(message);
001488  78001E     MOV [W14], W0
00148A  070002     RCALL queue_i2c_message
211:               }
00148C  FA8000     ULNK
00148E  060000     RETURN
212:               
213:               inline void queue_i2c_message(i2c_message_t* message){
001490  FA0002     LNK #0x2
001492  780F00     MOV W0, [W14]
214:                   if(n_i2c_queued_messages == I2C_MESSAGE_BUFFER_LENGTH){
001494  2100C1     MOV #0x100C, W1
001496  784091     MOV.B [W1], W1
001498  B3C200     MOV.B #0x20, W0
00149A  50CF80     SUB.B W1, W0, [W15]
00149C  3A0007     BRA NZ, .L36
215:                       message->status = I2C_MESSAGE_CANCELED;
00149E  78001E     MOV [W14], W0
0014A0  200041     MOV #0x4, W1
0014A2  980051     MOV W1, [W0+10]
216:                       message->error = I2C_QUEUE_FULL;
0014A4  78001E     MOV [W14], W0
0014A6  200051     MOV #0x5, W1
0014A8  980061     MOV W1, [W0+12]
0014AA  370027     BRA .L35
217:                       #ifdef __DEBUG__
218:                           uart_wait();
219:                           sprintf(print_buffer, "I2C queue full.");
220:                           uart_print(print_buffer, strlen(print_buffer));
221:                       #endif
222:                   } else {
223:                       if(message->n_attempts < 1){
0014AC  78001E     MOV [W14], W0
0014AE  904800     MOV.B [W0+8], W0
0014B0  E00400     CP0.B W0
0014B2  3C0007     BRA GT, .L38
224:                           message->status = I2C_MESSAGE_HANDLED;
0014B4  78001E     MOV [W14], W0
0014B6  EB0080     CLR W1
0014B8  980051     MOV W1, [W0+10]
225:                           message->error = I2C_ZERO_ATTEMPTS;
0014BA  78001E     MOV [W14], W0
0014BC  200081     MOV #0x8, W1
0014BE  980061     MOV W1, [W0+12]
0014C0  37001C     BRA .L35
226:                       } else {
227:                           message->status = I2C_MESSAGE_QUEUED;
0014C2  78001E     MOV [W14], W0
0014C4  200011     MOV #0x1, W1
0014C6  980051     MOV W1, [W0+10]
228:                           i2c_message_queue[i2c_queue_valid] = message;
0014C8  BFD00B     MOV.B i2c_queue_valid, WREG
0014CA  FB8000     ZE W0, W0
0014CC  400080     ADD W0, W0, W1
0014CE  24AEC0     MOV #0x4AEC, W0
0014D0  408000     ADD W1, W0, W0
0014D2  78081E     MOV [W14], [W0]
229:                           i2c_queue_valid = (i2c_queue_valid+1) % I2C_MESSAGE_BUFFER_LENGTH;
0014D4  BFD00B     MOV.B i2c_queue_valid, WREG
0014D6  FB8000     ZE W0, W0
0014D8  E80080     INC W0, W1
0014DA  2801F0     MOV #0x801F, W0
0014DC  608000     AND W1, W0, W0
0014DE  E00000     CP0 W0
0014E0  3D0004     BRA GE, .L39
0014E2  E90000     DEC W0, W0
0014E4  2FFE01     MOV #0xFFE0, W1
0014E6  708000     IOR W1, W0, W0
0014E8  E80000     INC W0, W0
0014EA  784000     MOV.B W0, W0
0014EC  B7F00B     MOV.B WREG, i2c_queue_valid
230:                           message->error = I2C_NO_ERROR;
0014EE  78001E     MOV [W14], W0
0014F0  EB0080     CLR W1
0014F2  980061     MOV W1, [W0+12]
231:                           n_i2c_queued_messages++;
0014F4  BFD00C     MOV.B n_i2c_queued_messages, WREG
0014F6  E84000     INC.B W0, W0
0014F8  B7F00C     MOV.B WREG, n_i2c_queued_messages
232:                           #ifdef __DEBUG__
233:                               uart_wait();
234:                               sprintf(print_buffer, "I2C added message to %x on bus %x.", message->address, message->i2c_bus);
235:                               uart_print(print_buffer, strlen(print_buffer));
236:                           #endif
237:                       }
238:                   }
239:               }
0014FA  FA8000     ULNK
0014FC  060000     RETURN
240:               
241:               void default_i2c_read_controller(i2c_message_t* m){
0014FE  FA0002     LNK #0x2
001500  780F00     MOV W0, [W14]
242:                   static uint8_t n_transfers = 0;
243:                  
244:                   switch(i2c_transfer_status){
001502  BFD00D     MOV.B i2c_transfer_status, WREG
001504  FB8000     ZE W0, W0
001506  500FE3     SUB W0, #0x3, [W15]
001508  320020     BRA Z, .L45
00150A  500FE3     SUB W0, #0x3, [W15]
00150C  3C0007     BRA GT, .L49
00150E  500FE1     SUB W0, #0x1, [W15]
001510  32000F     BRA Z, .L43
001512  500FE1     SUB W0, #0x1, [W15]
001514  3C0012     BRA GT, .L44
001516  E00000     CP0 W0
001518  320008     BRA Z, .L42
00151A  37004C     BRA .L41
00151C  500FE5     SUB W0, #0x5, [W15]
00151E  320040     BRA Z, .L47
001520  500FE5     SUB W0, #0x5, [W15]
001522  350024     BRA LT, .L46
001524  500FE6     SUB W0, #0x6, [W15]
001526  320041     BRA Z, .L48
001528  370045     BRA .L41
245:                       case 0:
246:                           i2c_transfer_status = 1;
00152A  B3C010     MOV.B #0x1, W0
00152C  B7F00D     MOV.B WREG, i2c_transfer_status
247:                           n_transfers = 0;
00152E  EF7045     CLR.B n_transfers
248:                       case 1:
249:                           // i2c start condition
250:                           transfer_done = 0;
001530  EF7004     CLR.B transfer_done
251:                           I2C1CONbits.SEN = 1;
001532  A80206     BSET I2C1CON, #0
252:                           i2c_transfer_status = 2;
001534  B3C020     MOV.B #0x2, W0
001536  B7F00D     MOV.B WREG, i2c_transfer_status
253:                           break;
001538  370044     BRA .L40
254:                       case 2:
255:                           // send start byte with address for reading
256:                           transfer_done = 0;
00153A  EF7004     CLR.B transfer_done
257:                           I2C1TRN = m->address;
00153C  78001E     MOV [W14], W0
00153E  784010     MOV.B [W0], W0
001540  FB8000     ZE W0, W0
001542  881010     MOV W0, I2C1TRN
258:                           i2c_transfer_status = 3;
001544  B3C030     MOV.B #0x3, W0
001546  B7F00D     MOV.B WREG, i2c_transfer_status
259:                           break;
001548  37003C     BRA .L40
260:                       case 3:
261:                           // enable receive mode
262:                           transfer_done = 0;
00154A  EF7004     CLR.B transfer_done
263:                           if(I2C1STATbits.ACKSTAT == 1) {
00154C  801041     MOV I2C1STAT, W1
00154E  280000     MOV #0x8000, W0
001550  608000     AND W1, W0, W0
001552  E00000     CP0 W0
001554  320007     BRA Z, .L51
264:                               m->error = I2C_NO_ACK;
001556  78001E     MOV [W14], W0
001558  200011     MOV #0x1, W1
00155A  980061     MOV W1, [W0+12]
265:                               i2c_transfer_status = 6;
00155C  B3C060     MOV.B #0x6, W0
00155E  B7F00D     MOV.B WREG, i2c_transfer_status
266:                               I2C1CONbits.PEN = 1;
001560  A84206     BSET I2C1CON, #2
267:                           } else {
268:                               I2C1CONbits.RCEN = 1;
001564  A86206     BSET I2C1CON, #3
269:                               i2c_transfer_status = 4;
001566  B3C040     MOV.B #0x4, W0
001568  B7F00D     MOV.B WREG, i2c_transfer_status
270:                           }
271:                           break;
001562  37002F     BRA .L40
00156A  37002B     BRA .L40
272:                       case 4:
273:                           // receive data byte
274:                           transfer_done = 0;
00156C  EF7004     CLR.B transfer_done
275:                           
276:                           m->data[n_transfers] = I2C1RCV;
00156E  78001E     MOV [W14], W0
001570  900090     MOV [W0+2], W1
001572  BFD045     MOV.B n_transfers, WREG
001574  FB8000     ZE W0, W0
001576  408000     ADD W1, W0, W0
001578  801001     MOV I2C1RCV, W1
00157A  784081     MOV.B W1, W1
00157C  784801     MOV.B W1, [W0]
277:                           n_transfers++;
00157E  BFD045     MOV.B n_transfers, WREG
001580  E84000     INC.B W0, W0
001582  B7F045     MOV.B WREG, n_transfers
278:                           
279:                           if(n_transfers == m->data_length){
001584  78001E     MOV [W14], W0
001586  9040C0     MOV.B [W0+4], W1
001588  BFD045     MOV.B n_transfers, WREG
00158A  50CF80     SUB.B W1, W0, [W15]
00158C  3A0004     BRA NZ, .L53
280:                               I2C1CONbits.ACKDT = 1; // send NACK
00158E  A8A206     BSET I2C1CON, #5
281:                               i2c_transfer_status = 5;  
001590  B3C050     MOV.B #0x5, W0
001592  B7F00D     MOV.B WREG, i2c_transfer_status
001594  370003     BRA .L54
282:                           } else {
283:                               I2C1CONbits.ACKDT = 0; // send ACK
001596  A9A206     BCLR I2C1CON, #5
284:                               i2c_transfer_status = 3;
001598  B3C030     MOV.B #0x3, W0
00159A  B7F00D     MOV.B WREG, i2c_transfer_status
285:                           }
286:                           I2C1CONbits.ACKEN = 1; // start ACK event
00159C  A88206     BSET I2C1CON, #4
287:                           
288:                           break;
00159E  370011     BRA .L40
289:                       case 5:
290:                           // send stop event
291:                           transfer_done = 0;
0015A0  EF7004     CLR.B transfer_done
292:                           i2c_transfer_status = 6;
0015A2  B3C060     MOV.B #0x6, W0
0015A4  B7F00D     MOV.B WREG, i2c_transfer_status
293:                           I2C1CONbits.PEN = 1;
0015A6  A84206     BSET I2C1CON, #2
294:                           break;
0015A8  37000C     BRA .L40
295:                       case 6:
296:                           i2c_transfer_status = 0;
0015AA  EF700D     CLR.B i2c_transfer_status
297:                           m->status = I2C_MESSAGE_PROCESSING;
0015AC  78001E     MOV [W14], W0
0015AE  200021     MOV #0x2, W1
0015B0  980051     MOV W1, [W0+10]
298:                           break;
0015B2  370007     BRA .L40
299:                       default:
300:                           // go back to initial state
301:                           transfer_done = 0;
0015B4  EF7004     CLR.B transfer_done
302:                           i2c_transfer_status = 0;
0015B6  EF700D     CLR.B i2c_transfer_status
303:                           m->status = I2C_MESSAGE_PROCESSING;
0015B8  78001E     MOV [W14], W0
0015BA  200021     MOV #0x2, W1
0015BC  980051     MOV W1, [W0+10]
304:                           I2C1CONbits.PEN = 1;
0015BE  A84206     BSET I2C1CON, #2
305:                           break;
0015C0  000000     NOP
306:                   }
307:               }
0015C2  FA8000     ULNK
0015C4  060000     RETURN
308:               
309:               uint8_t reset_i2c1_bus(void){
0015C6  FA0002     LNK #0x2
310:                   uint8_t n_reads = 0, data = 0;
0015C8  EB4000     CLR.B W0
0015CA  784F00     MOV.B W0, [W14]
0015CC  EB4000     CLR.B W0
0015CE  984710     MOV.B W0, [W14+1]
311:                   
312:                   // disable I2C1 interrupt
313:                   _MI2C1IE = 0;
0015D0  A92822     BCLR IEC1, #1
314:                   
315:                   // disable I2C1 module
316:                   I2C1CONbits.I2CEN = 0;
0015D2  A9E207     BCLR 0x207, #7
317:                   delay_us(100);
0015D4  200640     MOV #0x64, W0
0015D6  0715D8     RCALL delay_us
318:                   
319:                   // SCL line is blocked by slave, so hard reset is needed
320:                   if(GET_BIT(i2c1_scl_pin.port_r, i2c1_scl_pin.n) == 0){
0015D8  2100E0     MOV #0x100E, W0
0015DA  780010     MOV [W0], W0
0015DC  780090     MOV [W0], W1
0015DE  2100E0     MOV #0x100E, W0
0015E0  904060     MOV.B [W0+6], W0
0015E2  FB8000     ZE W0, W0
0015E4  DE0800     LSR W1, W0, W0
0015E6  B80161     MUL.UU W0, #0x1, W2
0015E8  200010     MOV #0x1, W0
0015EA  200001     MOV #0x0, W1
0015EC  780202     MOV W2, W4
0015EE  780103     MOV W3, W2
0015F0  780180     MOV W0, W3
0015F2  780001     MOV W1, W0
0015F4  620203     AND W4, W3, W4
0015F6  610000     AND W2, W0, W0
0015F8  EB0080     CLR W1
0015FA  DD00C0     SL W0, #0, W1
0015FC  200000     MOV #0x0, W0
0015FE  BE0100     MOV.D W0, W2
001600  B82061     MUL.UU W4, #0x1, W0
001602  710100     IOR W2, W0, W2
001604  718181     IOR W3, W1, W3
001606  510FE0     SUB W2, #0x0, [W15]
001608  598FE0     SUBB W3, #0x0, [W15]
00160A  3A0012     BRA NZ, .L62
321:                       return MAX_N_I2C_RST_READS;
00160C  B3C640     MOV.B #0x64, W0
00160E  370036     BRA .L57
322:                   }
323:                   
324:                   // try to get 
325:                   while((GET_BIT(i2c1_sda_pin.port_r, i2c1_sda_pin.n) == 0) && (n_reads < MAX_N_I2C_RST_READS)){
001630  000000     NOP
001632  2101E0     MOV #0x101E, W0
001634  780010     MOV [W0], W0
001636  780090     MOV [W0], W1
001638  2101E0     MOV #0x101E, W0
00163A  904060     MOV.B [W0+6], W0
00163C  FB8000     ZE W0, W0
00163E  DE0800     LSR W1, W0, W0
001640  B80161     MUL.UU W0, #0x1, W2
001642  200010     MOV #0x1, W0
001644  200001     MOV #0x0, W1
001646  780202     MOV W2, W4
001648  780103     MOV W3, W2
00164A  780180     MOV W0, W3
00164C  780001     MOV W1, W0
00164E  620203     AND W4, W3, W4
001650  610000     AND W2, W0, W0
001652  EB0080     CLR W1
001654  DD00C0     SL W0, #0, W1
001656  200000     MOV #0x0, W0
001658  BE0100     MOV.D W0, W2
00165A  B82061     MUL.UU W4, #0x1, W0
00165C  710100     IOR W2, W0, W2
00165E  718181     IOR W3, W1, W3
001660  510FE0     SUB W2, #0x0, [W15]
001662  598FE0     SUBB W3, #0x0, [W15]
001664  3A0004     BRA NZ, .L60
001666  B3C630     MOV.B #0x63, W0
001668  78409E     MOV.B [W14], W1
00166A  50CF80     SUB.B W1, W0, [W15]
00166C  36FFD1     BRA LEU, .L61
326:                       I2C1CONbits.I2CEN = 1;
001610  A8E207     BSET 0x207, #7
327:                       delay_us(100);
001612  200640     MOV #0x64, W0
001614  0715B9     RCALL delay_us
328:                       
329:                       I2C1CONbits.RCEN = 1;
001616  A86206     BSET I2C1CON, #3
330:                       while(I2C1CONbits.RCEN == 1); // TODO: improve deadlock here!
001618  000000     NOP
00161A  801030     MOV I2C1CON, W0
00161C  600068     AND W0, #0x8, W0
00161E  E00000     CP0 W0
001620  3AFFFC     BRA NZ, .L59
331:                       data = I2C1TRN;
001622  801010     MOV I2C1TRN, W0
001624  984710     MOV.B W0, [W14+1]
332:                       n_reads++;
001626  E84F1E     INC.B [W14], [W14]
333:                       
334:                       I2C1CONbits.I2CEN = 0;
001628  A9E207     BCLR 0x207, #7
335:                       delay_us(100);
00162A  200640     MOV #0x64, W0
00162C  0715AD     RCALL delay_us
00162E  370001     BRA .L58
336:                   }
337:                   
338:                   // enable I2C1 module
339:                   I2C1CONbits.I2CEN = 1;
00166E  A8E207     BSET 0x207, #7
340:                   delay_us(100);
001670  200640     MOV #0x64, W0
001672  07158A     RCALL delay_us
341:                   
342:                   // send stop condition
343:                   I2C1CONbits.PEN = 1;
001674  A84206     BSET I2C1CON, #2
344:                   
345:                   // re-enable I2C interrupts
346:                   _MI2C1IF = 0;
001676  A92802     BCLR IFS1, #1
347:                   _MI2C1IE = 1;
001678  A82822     BSET IEC1, #1
348:                   
349:                   return n_reads;
00167A  78401E     MOV.B [W14], W0
350:               }
00167C  FA8000     ULNK
00167E  060000     RETURN
351:               
352:               uint8_t reset_i2c2_bus(void){
001680  FA0002     LNK #0x2
353:                   uint8_t n_reads = 0, data = 0;
001682  EB4000     CLR.B W0
001684  784F00     MOV.B W0, [W14]
001686  EB4000     CLR.B W0
001688  984710     MOV.B W0, [W14+1]
354:                   
355:                   // disable I2C2 interrupt
356:                   _MI2C2IE = 0;
00168A  A94826     BCLR IEC3, #2
357:                   
358:                   // disable I2C2 module
359:                   I2C2CONbits.I2CEN = 0;
00168C  A9E217     BCLR 0x217, #7
360:                   delay_us(100);
00168E  200640     MOV #0x64, W0
001690  07157B     RCALL delay_us
361:                   
362:                   // SCL line is blocked by slave, so hard reset is needed
363:                   if(GET_BIT(i2c2_scl_pin.port_r, i2c2_scl_pin.n) == 0){
001692  210160     MOV #0x1016, W0
001694  780010     MOV [W0], W0
001696  780090     MOV [W0], W1
001698  210160     MOV #0x1016, W0
00169A  904060     MOV.B [W0+6], W0
00169C  FB8000     ZE W0, W0
00169E  DE0800     LSR W1, W0, W0
0016A0  B80161     MUL.UU W0, #0x1, W2
0016A2  200010     MOV #0x1, W0
0016A4  200001     MOV #0x0, W1
0016A6  780202     MOV W2, W4
0016A8  780103     MOV W3, W2
0016AA  780180     MOV W0, W3
0016AC  780001     MOV W1, W0
0016AE  620203     AND W4, W3, W4
0016B0  610000     AND W2, W0, W0
0016B2  EB0080     CLR W1
0016B4  DD00C0     SL W0, #0, W1
0016B6  200000     MOV #0x0, W0
0016B8  BE0100     MOV.D W0, W2
0016BA  B82061     MUL.UU W4, #0x1, W0
0016BC  710100     IOR W2, W0, W2
0016BE  718181     IOR W3, W1, W3
0016C0  510FE0     SUB W2, #0x0, [W15]
0016C2  598FE0     SUBB W3, #0x0, [W15]
0016C4  3A0012     BRA NZ, .L70
364:                       return MAX_N_I2C_RST_READS;
0016C6  B3C640     MOV.B #0x64, W0
0016C8  370036     BRA .L65
365:                   }
366:                   
367:                   // try to get 
368:                   while((GET_BIT(i2c2_sda_pin.port_r, i2c2_sda_pin.n) == 0) && (n_reads < MAX_N_I2C_RST_READS)){
0016EA  000000     NOP
0016EC  210260     MOV #0x1026, W0
0016EE  780010     MOV [W0], W0
0016F0  780090     MOV [W0], W1
0016F2  210260     MOV #0x1026, W0
0016F4  904060     MOV.B [W0+6], W0
0016F6  FB8000     ZE W0, W0
0016F8  DE0800     LSR W1, W0, W0
0016FA  B80161     MUL.UU W0, #0x1, W2
0016FC  200010     MOV #0x1, W0
0016FE  200001     MOV #0x0, W1
001700  780202     MOV W2, W4
001702  780103     MOV W3, W2
001704  780180     MOV W0, W3
001706  780001     MOV W1, W0
001708  620203     AND W4, W3, W4
00170A  610000     AND W2, W0, W0
00170C  EB0080     CLR W1
00170E  DD00C0     SL W0, #0, W1
001710  200000     MOV #0x0, W0
001712  BE0100     MOV.D W0, W2
001714  B82061     MUL.UU W4, #0x1, W0
001716  710100     IOR W2, W0, W2
001718  718181     IOR W3, W1, W3
00171A  510FE0     SUB W2, #0x0, [W15]
00171C  598FE0     SUBB W3, #0x0, [W15]
00171E  3A0004     BRA NZ, .L68
001720  B3C630     MOV.B #0x63, W0
001722  78409E     MOV.B [W14], W1
001724  50CF80     SUB.B W1, W0, [W15]
001726  36FFD1     BRA LEU, .L69
369:                       I2C2CONbits.I2CEN = 1;
0016CA  A8E217     BSET 0x217, #7
370:                       delay_us(100);
0016CC  200640     MOV #0x64, W0
0016CE  07155C     RCALL delay_us
371:                       
372:                       I2C2CONbits.RCEN = 1;
0016D0  A86216     BSET I2C2CON, #3
373:                       while(I2C2CONbits.RCEN == 1); // TODO: improve deadlock here!
0016D2  000000     NOP
0016D4  8010B0     MOV I2C2CON, W0
0016D6  600068     AND W0, #0x8, W0
0016D8  E00000     CP0 W0
0016DA  3AFFFC     BRA NZ, .L67
374:                       data = I2C2TRN;
0016DC  801090     MOV I2C2TRN, W0
0016DE  984710     MOV.B W0, [W14+1]
375:                       n_reads++;
0016E0  E84F1E     INC.B [W14], [W14]
376:                       
377:                       I2C2CONbits.I2CEN = 0;
0016E2  A9E217     BCLR 0x217, #7
378:                       delay_us(100);
0016E4  200640     MOV #0x64, W0
0016E6  071550     RCALL delay_us
0016E8  370001     BRA .L66
379:                   }
380:                   
381:                   // enable I2C1 module
382:                   I2C2CONbits.I2CEN = 1;
001728  A8E217     BSET 0x217, #7
383:                   delay_us(100);
00172A  200640     MOV #0x64, W0
00172C  07152D     RCALL delay_us
384:                   
385:                   // send stop condition
386:                   I2C2CONbits.PEN = 1;
00172E  A84216     BSET I2C2CON, #2
387:                   
388:                   // re-enable I2C interrupts
389:                   _MI2C2IF = 0;
001730  A94806     BCLR IFS3, #2
390:                   _MI2C2IE = 1;
001732  A84826     BSET IEC3, #2
391:                   
392:                   return n_reads;
001734  78401E     MOV.B [W14], W0
393:               }
001736  FA8000     ULNK
001738  060000     RETURN
394:               
395:               void disable_i2c1_bus(){
00173A  FA0004     LNK #0x4
396:                   uint16_t i;
397:                   i2c_message_t* m;
398:                   
399:                   // disable I2C1 module
400:                   I2C1CONbits.I2CEN = 0;
00173C  A9E207     BCLR 0x207, #7
401:                   _MI2C1IE = 0;
00173E  A92822     BCLR IEC1, #1
402:                   _MI2C1IF = 0;
001740  A92802     BCLR IFS1, #1
403:                   
404:                   // cancel all I2C1 messages
405:                   for(i = 0; i < I2C_MESSAGE_BUFFER_LENGTH; i++){
001742  EB0000     CLR W0
001744  780F00     MOV W0, [W14]
001746  370018     BRA .L72
001776  E80F1E     INC [W14], [W14]
001778  78001E     MOV [W14], W0
00177A  500FFF     SUB W0, #0x1F, [W15]
00177C  36FFE5     BRA LEU, .L76
406:                       m = i2c_message_queue[i];
001748  78001E     MOV [W14], W0
00174A  400080     ADD W0, W0, W1
00174C  24AEC0     MOV #0x4AEC, W0
00174E  408000     ADD W1, W0, W0
001750  780090     MOV [W0], W1
001752  980711     MOV W1, [W14+2]
407:                       if((m != NULL) && (m->i2c_bus == I2C1_BUS)){
001754  90001E     MOV [W14+2], W0
001756  E00000     CP0 W0
001758  32000E     BRA Z, .L73
00175A  90001E     MOV [W14+2], W0
00175C  900820     MOV [W0+20], W0
00175E  E00000     CP0 W0
001760  3A000A     BRA NZ, .L73
408:                           switch(m->status){
001762  90001E     MOV [W14+2], W0
001764  900050     MOV [W0+10], W0
001766  E90000     DEC W0, W0
001768  500FE2     SUB W0, #0x2, [W15]
00176A  3E0004     BRA GTU, .L77
409:                               case I2C_MESSAGE_TRANSFERRING:
410:                               case I2C_MESSAGE_PROCESSING:
411:                               case I2C_MESSAGE_QUEUED:
412:                                   m->status = I2C_MESSAGE_CANCELED;
00176C  90001E     MOV [W14+2], W0
00176E  200041     MOV #0x4, W1
001770  980051     MOV W1, [W0+10]
413:                               default:
414:                                   break;
001772  370001     BRA .L73
001774  000000     NOP
415:                           }
416:                       }
417:                   }
418:               }
00177E  FA8000     ULNK
001780  060000     RETURN
419:               
420:               void disable_i2c2_bus(){
001782  FA0004     LNK #0x4
421:                   uint16_t i;
422:                   i2c_message_t* m;
423:                   
424:                   // disable I2C2 module
425:                   I2C2CONbits.I2CEN = 0;
001784  A9E217     BCLR 0x217, #7
426:                   _MI2C2IE = 0;
001786  A94826     BCLR IEC3, #2
427:                   _MI2C2IF = 0;
001788  A94806     BCLR IFS3, #2
428:                   
429:                   // cancel all I2C2 messages
430:                   for(i = 0; i < I2C_MESSAGE_BUFFER_LENGTH; i++){
00178A  EB0000     CLR W0
00178C  780F00     MOV W0, [W14]
00178E  370018     BRA .L79
0017BE  E80F1E     INC [W14], [W14]
0017C0  78001E     MOV [W14], W0
0017C2  500FFF     SUB W0, #0x1F, [W15]
0017C4  36FFE5     BRA LEU, .L83
431:                       m = i2c_message_queue[i];
001790  78001E     MOV [W14], W0
001792  400080     ADD W0, W0, W1
001794  24AEC0     MOV #0x4AEC, W0
001796  408000     ADD W1, W0, W0
001798  780090     MOV [W0], W1
00179A  980711     MOV W1, [W14+2]
432:                       if((m != NULL) && (m->i2c_bus == I2C2_BUS)){
00179C  90001E     MOV [W14+2], W0
00179E  E00000     CP0 W0
0017A0  32000E     BRA Z, .L80
0017A2  90001E     MOV [W14+2], W0
0017A4  900820     MOV [W0+20], W0
0017A6  500FE1     SUB W0, #0x1, [W15]
0017A8  3A000A     BRA NZ, .L80
433:                           switch(m->status){
0017AA  90001E     MOV [W14+2], W0
0017AC  900050     MOV [W0+10], W0
0017AE  E90000     DEC W0, W0
0017B0  500FE2     SUB W0, #0x2, [W15]
0017B2  3E0004     BRA GTU, .L84
434:                               case I2C_MESSAGE_TRANSFERRING:
435:                               case I2C_MESSAGE_PROCESSING:
436:                               case I2C_MESSAGE_QUEUED:
437:                                   m->status = I2C_MESSAGE_CANCELED;
0017B4  90001E     MOV [W14+2], W0
0017B6  200041     MOV #0x4, W1
0017B8  980051     MOV W1, [W0+10]
438:                               default:
439:                                   break;
0017BA  370001     BRA .L80
0017BC  000000     NOP
440:                           }
441:                       }
442:                   }
443:               }
0017C6  FA8000     ULNK
0017C8  060000     RETURN
444:               
445:               void __attribute__ ( (__interrupt__, no_auto_psv) ) _T2Interrupt( void ){
000568  F80036     PUSH RCOUNT
00056A  BE9F80     MOV.D W0, [W15++]
00056C  BE9F82     MOV.D W2, [W15++]
00056E  BE9F84     MOV.D W4, [W15++]
000570  BE9F86     MOV.D W6, [W15++]
000572  FA0002     LNK #0x2
446:                   uint8_t n_reads = 0, i;
000574  EB4000     CLR.B W0
000576  984710     MOV.B W0, [W14+1]
447:                   
448:                   // check if I2C1 bus is free
449:                   if(i2c1_bus_status == I2C_BUS_ENABLED){
000578  808030     MOV i2c1_bus_status, W0
00057A  500FE1     SUB W0, #0x1, [W15]
00057C  3A004A     BRA NZ, .L86
450:                       n_reads = reset_i2c1_bus();
00057E  070823     RCALL reset_i2c1_bus
000580  984710     MOV.B W0, [W14+1]
451:                       if(n_reads == MAX_N_I2C_RST_READS) {
000582  90409E     MOV.B [W14+1], W1
000584  B3C640     MOV.B #0x64, W0
000586  50CF80     SUB.B W1, W0, [W15]
000588  3A0044     BRA NZ, .L86
452:                           // reset all devices on I2C1 bus
453:                           for(i = 0; i < N_I2C_DEVICE_RESET_CALLBACKS; i++){
00058A  EB4000     CLR.B W0
00058C  784F00     MOV.B W0, [W14]
00058E  370017     BRA .L87
0005BC  E84F1E     INC.B [W14], [W14]
0005BE  78401E     MOV.B [W14], W0
0005C0  504FE4     SUB.B W0, #0x4, [W15]
0005C2  36FFE6     BRA LEU, .L89
454:                               if((i2c_bus_reset[i].reset != NULL) && (i2c_bus_reset[i].i2c_bus == I2C1_BUS)){
000590  FB801E     ZE [W14], W0
000592  DD0043     SL W0, #3, W0
000594  4000E4     ADD W0, #0x4, W1
000596  24AC40     MOV #0x4AC4, W0
000598  408000     ADD W1, W0, W0
00059A  780010     MOV [W0], W0
00059C  E00000     CP0 W0
00059E  32000E     BRA Z, .L88
0005A0  FB801E     ZE [W14], W0
0005A2  DD00C3     SL W0, #3, W1
0005A4  24AC40     MOV #0x4AC4, W0
0005A6  408000     ADD W1, W0, W0
0005A8  780010     MOV [W0], W0
0005AA  E00000     CP0 W0
0005AC  3A0007     BRA NZ, .L88
455:                                   i2c_bus_reset[i].reset();
0005AE  FB801E     ZE [W14], W0
0005B0  DD0043     SL W0, #3, W0
0005B2  4000E4     ADD W0, #0x4, W1
0005B4  24AC40     MOV #0x4AC4, W0
0005B6  408000     ADD W1, W0, W0
0005B8  780010     MOV [W0], W0
0005BA  010000     CALL W0
456:                               }
457:                           }
458:               
459:                           n_reads = reset_i2c1_bus();
0005C4  070800     RCALL reset_i2c1_bus
0005C6  984710     MOV.B W0, [W14+1]
460:                           if(n_reads == MAX_N_I2C_RST_READS){
0005C8  90409E     MOV.B [W14+1], W1
0005CA  B3C640     MOV.B #0x64, W0
0005CC  50CF80     SUB.B W1, W0, [W15]
0005CE  3A0004     BRA NZ, .L90
461:                               disable_i2c1_bus();
0005D0  0708B4     RCALL disable_i2c1_bus
462:                               i2c1_bus_status = I2C_BUS_ERROR;
0005D2  200020     MOV #0x2, W0
0005D4  888030     MOV W0, i2c1_bus_status
0005D6  37001D     BRA .L86
463:                           } else {
464:                               for(i = 0; i < N_I2C_DEVICE_RESET_CALLBACKS; i++){
0005D8  EB4000     CLR.B W0
0005DA  784F00     MOV.B W0, [W14]
0005DC  370017     BRA .L91
00060A  E84F1E     INC.B [W14], [W14]
00060C  78401E     MOV.B [W14], W0
00060E  504FE4     SUB.B W0, #0x4, [W15]
000610  36FFE6     BRA LEU, .L93
465:                                   if((i2c_bus_reset[i].init != NULL) && (i2c_bus_reset[i].i2c_bus == I2C1_BUS)){
0005DE  FB801E     ZE [W14], W0
0005E0  DD0043     SL W0, #3, W0
0005E2  4000E6     ADD W0, #0x6, W1
0005E4  24AC40     MOV #0x4AC4, W0
0005E6  408000     ADD W1, W0, W0
0005E8  780010     MOV [W0], W0
0005EA  E00000     CP0 W0
0005EC  32000E     BRA Z, .L92
0005EE  FB801E     ZE [W14], W0
0005F0  DD00C3     SL W0, #3, W1
0005F2  24AC40     MOV #0x4AC4, W0
0005F4  408000     ADD W1, W0, W0
0005F6  780010     MOV [W0], W0
0005F8  E00000     CP0 W0
0005FA  3A0007     BRA NZ, .L92
466:                                       i2c_bus_reset[i].init();
0005FC  FB801E     ZE [W14], W0
0005FE  DD0043     SL W0, #3, W0
000600  4000E6     ADD W0, #0x6, W1
000602  24AC40     MOV #0x4AC4, W0
000604  408000     ADD W1, W0, W0
000606  780010     MOV [W0], W0
000608  010000     CALL W0
467:                                   }
468:                               }
469:                           }
470:                       } 
471:                   }
472:                   
473:                   // check if I2C2 bus is free
474:                   if(i2c2_bus_status == I2C_BUS_ENABLED){
000612  808040     MOV i2c2_bus_status, W0
000614  500FE1     SUB W0, #0x1, [W15]
000616  3A004A     BRA NZ, .L94
475:                       n_reads = reset_i2c2_bus();
000618  070833     RCALL reset_i2c2_bus
00061A  984710     MOV.B W0, [W14+1]
476:                       if(n_reads == MAX_N_I2C_RST_READS) {
00061C  90409E     MOV.B [W14+1], W1
00061E  B3C640     MOV.B #0x64, W0
000620  50CF80     SUB.B W1, W0, [W15]
000622  3A0044     BRA NZ, .L94
477:                           // reset all devices on I2C2 bus
478:                           for(i = 0; i < N_I2C_DEVICE_RESET_CALLBACKS; i++){
000624  EB4000     CLR.B W0
000626  784F00     MOV.B W0, [W14]
000628  370017     BRA .L95
000656  E84F1E     INC.B [W14], [W14]
000658  78401E     MOV.B [W14], W0
00065A  504FE4     SUB.B W0, #0x4, [W15]
00065C  36FFE6     BRA LEU, .L97
479:                               if((i2c_bus_reset[i].reset != NULL) && (i2c_bus_reset[i].i2c_bus == I2C2_BUS)){
00062A  FB801E     ZE [W14], W0
00062C  DD0043     SL W0, #3, W0
00062E  4000E4     ADD W0, #0x4, W1
000630  24AC40     MOV #0x4AC4, W0
000632  408000     ADD W1, W0, W0
000634  780010     MOV [W0], W0
000636  E00000     CP0 W0
000638  32000E     BRA Z, .L96
00063A  FB801E     ZE [W14], W0
00063C  DD00C3     SL W0, #3, W1
00063E  24AC40     MOV #0x4AC4, W0
000640  408000     ADD W1, W0, W0
000642  780010     MOV [W0], W0
000644  500FE1     SUB W0, #0x1, [W15]
000646  3A0007     BRA NZ, .L96
480:                                   i2c_bus_reset[i].reset();
000648  FB801E     ZE [W14], W0
00064A  DD0043     SL W0, #3, W0
00064C  4000E4     ADD W0, #0x4, W1
00064E  24AC40     MOV #0x4AC4, W0
000650  408000     ADD W1, W0, W0
000652  780010     MOV [W0], W0
000654  010000     CALL W0
481:                               }
482:                           }
483:               
484:                           n_reads = reset_i2c2_bus();
00065E  070810     RCALL reset_i2c2_bus
000660  984710     MOV.B W0, [W14+1]
485:                           if(n_reads == MAX_N_I2C_RST_READS){
000662  90409E     MOV.B [W14+1], W1
000664  B3C640     MOV.B #0x64, W0
000666  50CF80     SUB.B W1, W0, [W15]
000668  3A0004     BRA NZ, .L98
486:                               disable_i2c2_bus();
00066A  07088B     RCALL disable_i2c2_bus
487:                               i2c2_bus_status = I2C_BUS_ERROR;
00066C  200020     MOV #0x2, W0
00066E  888040     MOV W0, i2c2_bus_status
000670  37001D     BRA .L94
488:                           } else {
489:                               for(i = 0; i < N_I2C_DEVICE_RESET_CALLBACKS; i++){
000672  EB4000     CLR.B W0
000674  784F00     MOV.B W0, [W14]
000676  370017     BRA .L99
0006A4  E84F1E     INC.B [W14], [W14]
0006A6  78401E     MOV.B [W14], W0
0006A8  504FE4     SUB.B W0, #0x4, [W15]
0006AA  36FFE6     BRA LEU, .L101
490:                                   if((i2c_bus_reset[i].init != NULL) && (i2c_bus_reset[i].i2c_bus == I2C2_BUS)){
000678  FB801E     ZE [W14], W0
00067A  DD0043     SL W0, #3, W0
00067C  4000E6     ADD W0, #0x6, W1
00067E  24AC40     MOV #0x4AC4, W0
000680  408000     ADD W1, W0, W0
000682  780010     MOV [W0], W0
000684  E00000     CP0 W0
000686  32000E     BRA Z, .L100
000688  FB801E     ZE [W14], W0
00068A  DD00C3     SL W0, #3, W1
00068C  24AC40     MOV #0x4AC4, W0
00068E  408000     ADD W1, W0, W0
000690  780010     MOV [W0], W0
000692  500FE1     SUB W0, #0x1, [W15]
000694  3A0007     BRA NZ, .L100
491:                                       i2c_bus_reset[i].init();
000696  FB801E     ZE [W14], W0
000698  DD0043     SL W0, #3, W0
00069A  4000E6     ADD W0, #0x6, W1
00069C  24AC40     MOV #0x4AC4, W0
00069E  408000     ADD W1, W0, W0
0006A0  780010     MOV [W0], W0
0006A2  010000     CALL W0
492:                                   }
493:                               }
494:                           }
495:                       } 
496:                   }
497:                   
498:                   if((i2c1_bus_status != I2C_BUS_ENABLED) && (i2c2_bus_status != I2C_BUS_ENABLED)){
0006AC  808030     MOV i2c1_bus_status, W0
0006AE  500FE1     SUB W0, #0x1, [W15]
0006B0  320006     BRA Z, .L102
0006B2  808040     MOV i2c2_bus_status, W0
0006B4  500FE1     SUB W0, #0x1, [W15]
0006B6  320003     BRA Z, .L102
499:                       // cancel timer
500:                       _T2IF = 0; // clear interrupt flag
0006B8  A9E800     BCLR IFS0, #7
501:                       _T2IE = 0; // disable interrupt
0006BA  A9E820     BCLR IEC0, #7
502:               
503:                       T2CONbits.TON = 0;
0006BC  A9E111     BCLR 0x111, #7
504:                   }
505:                   
506:                   // flag ongoing transmission as error
507:                   // and continue with next transmission
508:                   transfer_done = 1;
0006BE  B3C010     MOV.B #0x1, W0
0006C0  B7F004     MOV.B WREG, transfer_done
509:                   _T2IF = 0;
0006C2  A9E800     BCLR IFS0, #7
510:               }
0006C4  FA8000     ULNK
0006C6  BE034F     MOV.D [--W15], W6
0006C8  BE024F     MOV.D [--W15], W4
0006CA  BE014F     MOV.D [--W15], W2
0006CC  BE004F     MOV.D [--W15], W0
0006CE  F90036     POP RCOUNT
0006D0  064000     RETFIE
511:               
512:               void default_i2c_write_read_controller(i2c_message_t* m){
0017CA  FA0002     LNK #0x2
0017CC  780F00     MOV W0, [W14]
513:                   static uint8_t n_transfers = 0;
514:                  
515:                   switch(i2c_transfer_status){
0017CE  BFD00D     MOV.B i2c_transfer_status, WREG
0017D0  FB8000     ZE W0, W0
0017D2  DE80CF     ASR W0, #15, W1
0017D4  200092     MOV #0x9, W2
0017D6  200003     MOV #0x0, W3
0017D8  500F82     SUB W0, W2, [W15]
0017DA  588F83     SUBB W1, W3, [W15]
0017DC  3E0091     BRA GTU, .L104
0017DE  010600     BRA W0
0017E0  370009     BRA .L105
0017E2  37000B     BRA .L106
0017E4  37000F     BRA .L107
0017E6  370016     BRA .L108
0017E8  370038     BRA .L109
0017EA  370048     BRA .L110
0017EC  370052     BRA .L111
0017EE  370062     BRA .L112
0017F0  37007D     BRA .L113
0017F2  370081     BRA .L114
516:                       case 0:
517:                           i2c_transfer_status = 1;
0017F4  B3C010     MOV.B #0x1, W0
0017F6  B7F00D     MOV.B WREG, i2c_transfer_status
518:                           n_transfers = 0;
0017F8  EF7044     CLR.B .LPA0
519:                       case 1:
520:                           // i2c start condition
521:                           transfer_done = 0;
0017FA  EF7004     CLR.B transfer_done
522:                           I2C1CONbits.SEN = 1;
0017FC  A80206     BSET I2C1CON, #0
523:                           i2c_transfer_status = 2;
0017FE  B3C020     MOV.B #0x2, W0
001800  B7F00D     MOV.B WREG, i2c_transfer_status
524:                           break;
001802  370089     BRA .L103
525:                       case 2:
526:                           // send start byte with address for reading
527:                           transfer_done = 0;
001804  EF7004     CLR.B transfer_done
528:                           I2C1TRN = m->address;
001806  78001E     MOV [W14], W0
001808  784010     MOV.B [W0], W0
00180A  FB8000     ZE W0, W0
00180C  881010     MOV W0, I2C1TRN
529:                           i2c_transfer_status = 3;
00180E  B3C030     MOV.B #0x3, W0
001810  B7F00D     MOV.B WREG, i2c_transfer_status
530:                           break;
001812  370081     BRA .L103
531:                       case 3:
532:                           // transfer data byte
533:                           transfer_done = 0;
001814  EF7004     CLR.B transfer_done
534:                           if(I2C1STATbits.ACKSTAT == 1) {
001816  801041     MOV I2C1STAT, W1
001818  280000     MOV #0x8000, W0
00181A  608000     AND W1, W0, W0
00181C  E00000     CP0 W0
00181E  320007     BRA Z, .L117
535:                               m->error = I2C_NO_ACK;
001820  78001E     MOV [W14], W0
001822  200011     MOV #0x1, W1
001824  980061     MOV W1, [W0+12]
536:                               i2c_transfer_status = 9;
001826  B3C090     MOV.B #0x9, W0
001828  B7F00D     MOV.B WREG, i2c_transfer_status
537:                               I2C1CONbits.PEN = 1;
00182A  A84206     BSET I2C1CON, #2
538:                           } else {
539:                               I2C1TRN = m->data[n_transfers];
00182E  78001E     MOV [W14], W0
001830  900090     MOV [W0+2], W1
001832  BFD044     MOV.B .LPA0, WREG
001834  FB8000     ZE W0, W0
001836  408000     ADD W1, W0, W0
001838  784010     MOV.B [W0], W0
00183A  FB8000     ZE W0, W0
00183C  881010     MOV W0, I2C1TRN
540:                               n_transfers++;
00183E  BFD044     MOV.B .LPA0, WREG
001840  E84000     INC.B W0, W0
001842  B7F044     MOV.B WREG, .LPA0
541:                               
542:                               if(n_transfers == m->data_length){
001844  78001E     MOV [W14], W0
001846  9040C0     MOV.B [W0+4], W1
001848  BFD044     MOV.B .LPA0, WREG
00184A  50CF80     SUB.B W1, W0, [W15]
00184C  3A0003     BRA NZ, .L119
543:                                   i2c_transfer_status = 4;
00184E  B3C040     MOV.B #0x4, W0
001850  B7F00D     MOV.B WREG, i2c_transfer_status
544:                               } else {
545:                                   i2c_transfer_status = 3;
001854  B3C030     MOV.B #0x3, W0
001856  B7F00D     MOV.B WREG, i2c_transfer_status
546:                               }
547:                           }
548:                           break;
00182C  370074     BRA .L103
001852  370061     BRA .L103
001858  37005E     BRA .L103
549:                       case 4:
550:                           // check final ACK and send repeated start event
551:                           transfer_done = 0;
00185A  EF7004     CLR.B transfer_done
552:                           if(I2C1STATbits.ACKSTAT == 1) {
00185C  801041     MOV I2C1STAT, W1
00185E  280000     MOV #0x8000, W0
001860  608000     AND W1, W0, W0
001862  E00000     CP0 W0
001864  320007     BRA Z, .L120
553:                               m->error = I2C_NO_ACK;
001866  78001E     MOV [W14], W0
001868  200011     MOV #0x1, W1
00186A  980061     MOV W1, [W0+12]
554:                               i2c_transfer_status = 9;
00186C  B3C090     MOV.B #0x9, W0
00186E  B7F00D     MOV.B WREG, i2c_transfer_status
555:                               I2C1CONbits.PEN = 1;           
001870  A84206     BSET I2C1CON, #2
556:                           } else {
557:                               I2C1CONbits.RSEN = 1;
001874  A82206     BSET I2C1CON, #1
558:                               i2c_transfer_status = 5;
001876  B3C050     MOV.B #0x5, W0
001878  B7F00D     MOV.B WREG, i2c_transfer_status
559:                           }
560:                           break;
001872  370051     BRA .L103
00187A  37004D     BRA .L103
561:                       case 5:
562:                           // send start byte with address for reading
563:                           transfer_done = 0;
00187C  EF7004     CLR.B transfer_done
564:                           I2C1TRN = m->connected_message->address | 0x01;
00187E  78001E     MOV [W14], W0
001880  900830     MOV [W0+22], W0
001882  784010     MOV.B [W0], W0
001884  A00400     BSET.B W0, #0
001886  FB8000     ZE W0, W0
001888  881010     MOV W0, I2C1TRN
565:                           i2c_transfer_status = 6;
00188A  B3C060     MOV.B #0x6, W0
00188C  B7F00D     MOV.B WREG, i2c_transfer_status
566:                           n_transfers = 0;
00188E  EF7044     CLR.B .LPA0
567:                           break;
001890  370042     BRA .L103
568:                       case 6:
569:                           // enable receive mode
570:                           transfer_done = 0;
001892  EF7004     CLR.B transfer_done
571:                           if(I2C1STATbits.ACKSTAT == 1) {
001894  801041     MOV I2C1STAT, W1
001896  280000     MOV #0x8000, W0
001898  608000     AND W1, W0, W0
00189A  E00000     CP0 W0
00189C  320007     BRA Z, .L122
572:                               m->error = I2C_NO_ACK;
00189E  78001E     MOV [W14], W0
0018A0  200011     MOV #0x1, W1
0018A2  980061     MOV W1, [W0+12]
573:                               i2c_transfer_status = 9;
0018A4  B3C090     MOV.B #0x9, W0
0018A6  B7F00D     MOV.B WREG, i2c_transfer_status
574:                               I2C1CONbits.PEN = 1;  
0018A8  A84206     BSET I2C1CON, #2
575:                           } else {
576:                               I2C1CONbits.RCEN = 1;
0018AC  A86206     BSET I2C1CON, #3
577:                               i2c_transfer_status = 7;      
0018AE  B3C070     MOV.B #0x7, W0
0018B0  B7F00D     MOV.B WREG, i2c_transfer_status
578:                           }
579:                           break;
0018AA  370035     BRA .L103
0018B2  370031     BRA .L103
580:                       case 7:
581:                           // receive data byte
582:                           transfer_done = 0;
0018B4  EF7004     CLR.B transfer_done
583:                           
584:                           m->connected_message->data[n_transfers] = I2C1RCV;
0018B6  78001E     MOV [W14], W0
0018B8  900830     MOV [W0+22], W0
0018BA  900090     MOV [W0+2], W1
0018BC  BFD044     MOV.B .LPA0, WREG
0018BE  FB8000     ZE W0, W0
0018C0  408000     ADD W1, W0, W0
0018C2  801001     MOV I2C1RCV, W1
0018C4  784081     MOV.B W1, W1
0018C6  784801     MOV.B W1, [W0]
585:                           n_transfers++;
0018C8  BFD044     MOV.B .LPA0, WREG
0018CA  E84000     INC.B W0, W0
0018CC  B7F044     MOV.B WREG, .LPA0
586:                           
587:                           if(n_transfers == m->connected_message->data_length){
0018CE  78001E     MOV [W14], W0
0018D0  900830     MOV [W0+22], W0
0018D2  9040C0     MOV.B [W0+4], W1
0018D4  BFD044     MOV.B .LPA0, WREG
0018D6  50CF80     SUB.B W1, W0, [W15]
0018D8  3A0004     BRA NZ, .L124
588:                               I2C1CONbits.ACKDT = 1; // send NACK
0018DA  A8A206     BSET I2C1CON, #5
589:                               i2c_transfer_status = 8;  
0018DC  B3C080     MOV.B #0x8, W0
0018DE  B7F00D     MOV.B WREG, i2c_transfer_status
0018E0  370003     BRA .L125
590:                           } else {
591:                               I2C1CONbits.ACKDT = 0; // send ACK
0018E2  A9A206     BCLR I2C1CON, #5
592:                               i2c_transfer_status = 6;
0018E4  B3C060     MOV.B #0x6, W0
0018E6  B7F00D     MOV.B WREG, i2c_transfer_status
593:                           }
594:                           I2C1CONbits.ACKEN = 1; // start ACK event
0018E8  A88206     BSET I2C1CON, #4
595:                           
596:                           break;
0018EA  370015     BRA .L103
597:                       case 8:
598:                           // send stop event
599:                           transfer_done = 0;
0018EC  EF7004     CLR.B transfer_done
600:                           i2c_transfer_status = 9;
0018EE  B3C090     MOV.B #0x9, W0
0018F0  B7F00D     MOV.B WREG, i2c_transfer_status
601:                           I2C1CONbits.PEN = 1;
0018F2  A84206     BSET I2C1CON, #2
602:                           break;
0018F4  370010     BRA .L103
603:                       case 9:
604:                           m->status = I2C_MESSAGE_PROCESSING;
0018F6  78001E     MOV [W14], W0
0018F8  200021     MOV #0x2, W1
0018FA  980051     MOV W1, [W0+10]
605:                           i2c_transfer_status = 0;
0018FC  EF700D     CLR.B i2c_transfer_status
606:                           break;
0018FE  37000B     BRA .L103
607:                       default:
608:                           // go back to initial state
609:                           transfer_done = 0;
001900  EF7004     CLR.B transfer_done
610:                           i2c_transfer_status = 0;
001902  EF700D     CLR.B i2c_transfer_status
611:                           m->status = m->status = I2C_MESSAGE_PROCESSING;
001904  78001E     MOV [W14], W0
001906  200021     MOV #0x2, W1
001908  980051     MOV W1, [W0+10]
00190A  78001E     MOV [W14], W0
00190C  9000D0     MOV [W0+10], W1
00190E  78001E     MOV [W14], W0
001910  980051     MOV W1, [W0+10]
612:                           I2C1CONbits.PEN = 1;
001912  A84206     BSET I2C1CON, #2
613:                           break;
001914  000000     NOP
614:                   }
615:               }
001916  FA8000     ULNK
001918  060000     RETURN
616:               
617:               void alt_i2c_write_read_controller(i2c_message_t* m){
00191A  FA0002     LNK #0x2
00191C  780F00     MOV W0, [W14]
618:                   static uint8_t n_transfers = 0;
619:                  
620:                   switch(i2c_transfer_status){
00191E  BFD00D     MOV.B i2c_transfer_status, WREG
001920  FB8000     ZE W0, W0
001922  DE80CF     ASR W0, #15, W1
001924  200092     MOV #0x9, W2
001926  200003     MOV #0x0, W3
001928  500F82     SUB W0, W2, [W15]
00192A  588F83     SUBB W1, W3, [W15]
00192C  3E0090     BRA GTU, .L127
00192E  010600     BRA W0
001930  370009     BRA .L128
001932  37000B     BRA .L129
001934  37000F     BRA .L130
001936  370016     BRA .L131
001938  370038     BRA .L132
00193A  370048     BRA .L133
00193C  370051     BRA .L134
00193E  370061     BRA .L135
001940  37007C     BRA .L136
001942  370080     BRA .L137
621:                       case 0:
622:                           i2c_transfer_status = 1;
001944  B3C010     MOV.B #0x1, W0
001946  B7F00D     MOV.B WREG, i2c_transfer_status
623:                           n_transfers = 0;
001948  EF7043     CLR.B n_transfers
624:                       case 1:
625:                           // i2c start condition
626:                           transfer_done = 0;
00194A  EF7004     CLR.B transfer_done
627:                           I2C2CONbits.SEN = 1;
00194C  A80216     BSET I2C2CON, #0
628:                           i2c_transfer_status = 2;
00194E  B3C020     MOV.B #0x2, W0
001950  B7F00D     MOV.B WREG, i2c_transfer_status
629:                           break;
001952  370088     BRA .L126
630:                       case 2:
631:                           // send start byte with address for reading
632:                           transfer_done = 0;
001954  EF7004     CLR.B transfer_done
633:                           I2C2TRN = m->address;
001956  78001E     MOV [W14], W0
001958  784010     MOV.B [W0], W0
00195A  FB8000     ZE W0, W0
00195C  881090     MOV W0, I2C2TRN
634:                           i2c_transfer_status = 3;
00195E  B3C030     MOV.B #0x3, W0
001960  B7F00D     MOV.B WREG, i2c_transfer_status
635:                           break;
001962  370080     BRA .L126
636:                       case 3:
637:                           // transfer data byte
638:                           transfer_done = 0;
001964  EF7004     CLR.B transfer_done
639:                           if(I2C2STATbits.ACKSTAT == 1) {
001966  8010C1     MOV I2C2STAT, W1
001968  280000     MOV #0x8000, W0
00196A  608000     AND W1, W0, W0
00196C  E00000     CP0 W0
00196E  320007     BRA Z, .L140
640:                               m->error = I2C_NO_ACK;
001970  78001E     MOV [W14], W0
001972  200011     MOV #0x1, W1
001974  980061     MOV W1, [W0+12]
641:                               i2c_transfer_status = 9;
001976  B3C090     MOV.B #0x9, W0
001978  B7F00D     MOV.B WREG, i2c_transfer_status
642:                               I2C2CONbits.PEN = 1;
00197A  A84216     BSET I2C2CON, #2
643:                           } else {
644:                               I2C2TRN = m->data[n_transfers];
00197E  78001E     MOV [W14], W0
001980  900090     MOV [W0+2], W1
001982  BFD043     MOV.B n_transfers, WREG
001984  FB8000     ZE W0, W0
001986  408000     ADD W1, W0, W0
001988  784010     MOV.B [W0], W0
00198A  FB8000     ZE W0, W0
00198C  881090     MOV W0, I2C2TRN
645:                               n_transfers++;
00198E  BFD043     MOV.B n_transfers, WREG
001990  E84000     INC.B W0, W0
001992  B7F043     MOV.B WREG, n_transfers
646:                               
647:                               if(n_transfers == m->data_length){
001994  78001E     MOV [W14], W0
001996  9040C0     MOV.B [W0+4], W1
001998  BFD043     MOV.B n_transfers, WREG
00199A  50CF80     SUB.B W1, W0, [W15]
00199C  3A0003     BRA NZ, .L142
648:                                   i2c_transfer_status = 4;
00199E  B3C040     MOV.B #0x4, W0
0019A0  B7F00D     MOV.B WREG, i2c_transfer_status
649:                               } else {
650:                                   i2c_transfer_status = 3;
0019A4  B3C030     MOV.B #0x3, W0
0019A6  B7F00D     MOV.B WREG, i2c_transfer_status
651:                               }
652:                           }
653:                           break;
00197C  370073     BRA .L126
0019A2  370060     BRA .L126
0019A8  37005D     BRA .L126
654:                       case 4:
655:                           // check final ACK and send repeated start event
656:                           transfer_done = 0;
0019AA  EF7004     CLR.B transfer_done
657:                           if(I2C2STATbits.ACKSTAT == 1) {
0019AC  8010C1     MOV I2C2STAT, W1
0019AE  280000     MOV #0x8000, W0
0019B0  608000     AND W1, W0, W0
0019B2  E00000     CP0 W0
0019B4  320007     BRA Z, .L143
658:                               m->error = I2C_NO_ACK;
0019B6  78001E     MOV [W14], W0
0019B8  200011     MOV #0x1, W1
0019BA  980061     MOV W1, [W0+12]
659:                               i2c_transfer_status = 9;
0019BC  B3C090     MOV.B #0x9, W0
0019BE  B7F00D     MOV.B WREG, i2c_transfer_status
660:                               I2C2CONbits.PEN = 1;           
0019C0  A84216     BSET I2C2CON, #2
661:                           } else {
662:                               I2C2CONbits.RSEN = 1;
0019C4  A82216     BSET I2C2CON, #1
663:                               i2c_transfer_status = 5;
0019C6  B3C050     MOV.B #0x5, W0
0019C8  B7F00D     MOV.B WREG, i2c_transfer_status
664:                           }
665:                           break;
0019C2  370050     BRA .L126
0019CA  37004C     BRA .L126
666:                       case 5:
667:                           // send start byte with address for reading
668:                           transfer_done = 0;
0019CC  EF7004     CLR.B transfer_done
669:                           I2C2TRN = m->connected_message->address;
0019CE  78001E     MOV [W14], W0
0019D0  900830     MOV [W0+22], W0
0019D2  784010     MOV.B [W0], W0
0019D4  FB8000     ZE W0, W0
0019D6  881090     MOV W0, I2C2TRN
670:                           i2c_transfer_status = 6;
0019D8  B3C060     MOV.B #0x6, W0
0019DA  B7F00D     MOV.B WREG, i2c_transfer_status
671:                           n_transfers = 0;
0019DC  EF7043     CLR.B n_transfers
672:                           break;
0019DE  370042     BRA .L126
673:                       case 6:
674:                           // enable receive mode
675:                           transfer_done = 0;
0019E0  EF7004     CLR.B transfer_done
676:                           if(I2C2STATbits.ACKSTAT == 1) {
0019E2  8010C1     MOV I2C2STAT, W1
0019E4  280000     MOV #0x8000, W0
0019E6  608000     AND W1, W0, W0
0019E8  E00000     CP0 W0
0019EA  320007     BRA Z, .L145
677:                               m->error = I2C_NO_ACK;
0019EC  78001E     MOV [W14], W0
0019EE  200011     MOV #0x1, W1
0019F0  980061     MOV W1, [W0+12]
678:                               i2c_transfer_status = 9;
0019F2  B3C090     MOV.B #0x9, W0
0019F4  B7F00D     MOV.B WREG, i2c_transfer_status
679:                               I2C2CONbits.PEN = 1;  
0019F6  A84216     BSET I2C2CON, #2
680:                           } else {
681:                               I2C2CONbits.RCEN = 1;
0019FA  A86216     BSET I2C2CON, #3
682:                               i2c_transfer_status = 7;      
0019FC  B3C070     MOV.B #0x7, W0
0019FE  B7F00D     MOV.B WREG, i2c_transfer_status
683:                           }
684:                           break;
0019F8  370035     BRA .L126
001A00  370031     BRA .L126
685:                       case 7:
686:                           // receive data byte
687:                           transfer_done = 0;
001A02  EF7004     CLR.B transfer_done
688:                           
689:                           m->connected_message->data[n_transfers] = I2C2RCV;
001A04  78001E     MOV [W14], W0
001A06  900830     MOV [W0+22], W0
001A08  900090     MOV [W0+2], W1
001A0A  BFD043     MOV.B n_transfers, WREG
001A0C  FB8000     ZE W0, W0
001A0E  408000     ADD W1, W0, W0
001A10  801081     MOV I2C2RCV, W1
001A12  784081     MOV.B W1, W1
001A14  784801     MOV.B W1, [W0]
690:                           n_transfers++;
001A16  BFD043     MOV.B n_transfers, WREG
001A18  E84000     INC.B W0, W0
001A1A  B7F043     MOV.B WREG, n_transfers
691:                           
692:                           if(n_transfers == m->connected_message->data_length){
001A1C  78001E     MOV [W14], W0
001A1E  900830     MOV [W0+22], W0
001A20  9040C0     MOV.B [W0+4], W1
001A22  BFD043     MOV.B n_transfers, WREG
001A24  50CF80     SUB.B W1, W0, [W15]
001A26  3A0004     BRA NZ, .L147
693:                               I2C2CONbits.ACKDT = 1; // send NACK
001A28  A8A216     BSET I2C2CON, #5
694:                               i2c_transfer_status = 8;  
001A2A  B3C080     MOV.B #0x8, W0
001A2C  B7F00D     MOV.B WREG, i2c_transfer_status
001A2E  370003     BRA .L148
695:                           } else {
696:                               I2C2CONbits.ACKDT = 0; // send ACK
001A30  A9A216     BCLR I2C2CON, #5
697:                               i2c_transfer_status = 6;
001A32  B3C060     MOV.B #0x6, W0
001A34  B7F00D     MOV.B WREG, i2c_transfer_status
698:                           }
699:                           I2C2CONbits.ACKEN = 1; // start ACK event
001A36  A88216     BSET I2C2CON, #4
700:                           
701:                           break;
001A38  370015     BRA .L126
702:                       case 8:
703:                           // send stop event
704:                           transfer_done = 0;
001A3A  EF7004     CLR.B transfer_done
705:                           i2c_transfer_status = 9;
001A3C  B3C090     MOV.B #0x9, W0
001A3E  B7F00D     MOV.B WREG, i2c_transfer_status
706:                           I2C2CONbits.PEN = 1;
001A40  A84216     BSET I2C2CON, #2
707:                           break;
001A42  370010     BRA .L126
708:                       case 9:
709:                           m->status = I2C_MESSAGE_PROCESSING;
001A44  78001E     MOV [W14], W0
001A46  200021     MOV #0x2, W1
001A48  980051     MOV W1, [W0+10]
710:                           i2c_transfer_status = 0;
001A4A  EF700D     CLR.B i2c_transfer_status
711:                           break;
001A4C  37000B     BRA .L126
712:                       default:
713:                           // go back to initial state
714:                           transfer_done = 0;
001A4E  EF7004     CLR.B transfer_done
715:                           i2c_transfer_status = 0;
001A50  EF700D     CLR.B i2c_transfer_status
716:                           m->status = m->status = I2C_MESSAGE_PROCESSING;
001A52  78001E     MOV [W14], W0
001A54  200021     MOV #0x2, W1
001A56  980051     MOV W1, [W0+10]
001A58  78001E     MOV [W14], W0
001A5A  9000D0     MOV [W0+10], W1
001A5C  78001E     MOV [W14], W0
001A5E  980051     MOV W1, [W0+10]
717:                           I2C2CONbits.PEN = 1;
001A60  A84216     BSET I2C2CON, #2
718:                           break;
001A62  000000     NOP
719:                   }
720:               };
001A64  FA8000     ULNK
001A66  060000     RETURN
721:               
722:               void alt_i2c_read_controller(i2c_message_t* m){
001A68  FA0002     LNK #0x2
001A6A  780F00     MOV W0, [W14]
723:                   static uint8_t n_transfers = 0;
724:                  
725:                   switch(i2c_transfer_status){
001A6C  BFD00D     MOV.B i2c_transfer_status, WREG
001A6E  FB8000     ZE W0, W0
001A70  500FE3     SUB W0, #0x3, [W15]
001A72  320020     BRA Z, .L154
001A74  500FE3     SUB W0, #0x3, [W15]
001A76  3C0007     BRA GT, .L158
001A78  500FE1     SUB W0, #0x1, [W15]
001A7A  32000F     BRA Z, .L152
001A7C  500FE1     SUB W0, #0x1, [W15]
001A7E  3C0012     BRA GT, .L153
001A80  E00000     CP0 W0
001A82  320008     BRA Z, .L151
001A84  37004C     BRA .L150
001A86  500FE5     SUB W0, #0x5, [W15]
001A88  320040     BRA Z, .L156
001A8A  500FE5     SUB W0, #0x5, [W15]
001A8C  350024     BRA LT, .L155
001A8E  500FE6     SUB W0, #0x6, [W15]
001A90  320041     BRA Z, .L157
001A92  370045     BRA .L150
726:                       case 0:
727:                           i2c_transfer_status = 1;
001A94  B3C010     MOV.B #0x1, W0
001A96  B7F00D     MOV.B WREG, i2c_transfer_status
728:                           n_transfers = 0;
001A98  EF7042     CLR.B n_transfers
729:                       case 1:
730:                           // i2c start condition
731:                           transfer_done = 0;
001A9A  EF7004     CLR.B transfer_done
732:                           I2C2CONbits.SEN = 1;
001A9C  A80216     BSET I2C2CON, #0
733:                           i2c_transfer_status = 2;
001A9E  B3C020     MOV.B #0x2, W0
001AA0  B7F00D     MOV.B WREG, i2c_transfer_status
734:                           break;
001AA2  370044     BRA .L149
735:                       case 2:
736:                           // send start byte with address for reading
737:                           transfer_done = 0;
001AA4  EF7004     CLR.B transfer_done
738:                           I2C2TRN = m->address;
001AA6  78001E     MOV [W14], W0
001AA8  784010     MOV.B [W0], W0
001AAA  FB8000     ZE W0, W0
001AAC  881090     MOV W0, I2C2TRN
739:                           i2c_transfer_status = 3;
001AAE  B3C030     MOV.B #0x3, W0
001AB0  B7F00D     MOV.B WREG, i2c_transfer_status
740:                           break;
001AB2  37003C     BRA .L149
741:                       case 3:
742:                           // enable receive mode
743:                           transfer_done = 0;
001AB4  EF7004     CLR.B transfer_done
744:                           if(I2C2STATbits.ACKSTAT == 1) {
001AB6  8010C1     MOV I2C2STAT, W1
001AB8  280000     MOV #0x8000, W0
001ABA  608000     AND W1, W0, W0
001ABC  E00000     CP0 W0
001ABE  320007     BRA Z, .L160
745:                               m->error = I2C_NO_ACK;
001AC0  78001E     MOV [W14], W0
001AC2  200011     MOV #0x1, W1
001AC4  980061     MOV W1, [W0+12]
746:                               i2c_transfer_status = 6;
001AC6  B3C060     MOV.B #0x6, W0
001AC8  B7F00D     MOV.B WREG, i2c_transfer_status
747:                               I2C2CONbits.PEN = 1;
001ACA  A84216     BSET I2C2CON, #2
748:                           } else {
749:                               I2C2CONbits.RCEN = 1;
001ACE  A86216     BSET I2C2CON, #3
750:                               i2c_transfer_status = 4;    
001AD0  B3C040     MOV.B #0x4, W0
001AD2  B7F00D     MOV.B WREG, i2c_transfer_status
751:                           }
752:                           break;
001ACC  37002F     BRA .L149
001AD4  37002B     BRA .L149
753:                       case 4:
754:                           // receive data byte
755:                           transfer_done = 0;
001AD6  EF7004     CLR.B transfer_done
756:                           
757:                           m->data[n_transfers] = I2C2RCV;
001AD8  78001E     MOV [W14], W0
001ADA  900090     MOV [W0+2], W1
001ADC  BFD042     MOV.B n_transfers, WREG
001ADE  FB8000     ZE W0, W0
001AE0  408000     ADD W1, W0, W0
001AE2  801081     MOV I2C2RCV, W1
001AE4  784081     MOV.B W1, W1
001AE6  784801     MOV.B W1, [W0]
758:                           n_transfers++;
001AE8  BFD042     MOV.B n_transfers, WREG
001AEA  E84000     INC.B W0, W0
001AEC  B7F042     MOV.B WREG, n_transfers
759:                           
760:                           if(n_transfers == m->data_length){
001AEE  78001E     MOV [W14], W0
001AF0  9040C0     MOV.B [W0+4], W1
001AF2  BFD042     MOV.B n_transfers, WREG
001AF4  50CF80     SUB.B W1, W0, [W15]
001AF6  3A0004     BRA NZ, .L162
761:                               I2C2CONbits.ACKDT = 1; // send NACK
001AF8  A8A216     BSET I2C2CON, #5
762:                               i2c_transfer_status = 5;  
001AFA  B3C050     MOV.B #0x5, W0
001AFC  B7F00D     MOV.B WREG, i2c_transfer_status
001AFE  370003     BRA .L163
763:                           } else {
764:                               I2C2CONbits.ACKDT = 0; // send ACK
001B00  A9A216     BCLR I2C2CON, #5
765:                               i2c_transfer_status = 3;
001B02  B3C030     MOV.B #0x3, W0
001B04  B7F00D     MOV.B WREG, i2c_transfer_status
766:                           }
767:                           
768:                           I2C2CONbits.ACKEN = 1; // start ACK event        
001B06  A88216     BSET I2C2CON, #4
769:                           
770:                           break;
001B08  370011     BRA .L149
771:                       case 5:
772:                           // send stop event
773:                           transfer_done = 0;
001B0A  EF7004     CLR.B transfer_done
774:                           i2c_transfer_status = 6;
001B0C  B3C060     MOV.B #0x6, W0
001B0E  B7F00D     MOV.B WREG, i2c_transfer_status
775:                           I2C2CONbits.PEN = 1;
001B10  A84216     BSET I2C2CON, #2
776:                           break;
001B12  37000C     BRA .L149
777:                       case 6:
778:                           i2c_transfer_status = 0;
001B14  EF700D     CLR.B i2c_transfer_status
779:                           m->status = I2C_MESSAGE_PROCESSING;
001B16  78001E     MOV [W14], W0
001B18  200021     MOV #0x2, W1
001B1A  980051     MOV W1, [W0+10]
780:                           break;
001B1C  370007     BRA .L149
781:                       default:
782:                           // go back to initial state
783:                           transfer_done = 0;
001B1E  EF7004     CLR.B transfer_done
784:                           i2c_transfer_status = 0;
001B20  EF700D     CLR.B i2c_transfer_status
785:                           m->status = I2C_MESSAGE_PROCESSING;
001B22  78001E     MOV [W14], W0
001B24  200021     MOV #0x2, W1
001B26  980051     MOV W1, [W0+10]
786:                           I2C2CONbits.PEN = 1;
001B28  A84216     BSET I2C2CON, #2
787:                           break;
001B2A  000000     NOP
788:                   }
789:               }
001B2C  FA8000     ULNK
001B2E  060000     RETURN
790:               
791:               void default_i2c_write_controller(i2c_message_t* m){
001B30  FA0002     LNK #0x2
001B32  780F00     MOV W0, [W14]
792:                   static uint8_t n_transfers = 0;
793:                  
794:                   switch(i2c_transfer_status){
001B34  BFD00D     MOV.B i2c_transfer_status, WREG
001B36  FB8000     ZE W0, W0
001B38  500FE2     SUB W0, #0x2, [W15]
001B3A  320017     BRA Z, .L168
001B3C  500FE2     SUB W0, #0x2, [W15]
001B3E  3C0005     BRA GT, .L172
001B40  E00000     CP0 W0
001B42  32000A     BRA Z, .L166
001B44  500FE1     SUB W0, #0x1, [W15]
001B46  32000C     BRA Z, .L167
001B48  370047     BRA .L165
001B4A  500FE4     SUB W0, #0x4, [W15]
001B4C  32003B     BRA Z, .L170
001B4E  500FE4     SUB W0, #0x4, [W15]
001B50  350014     BRA LT, .L169
001B52  500FE5     SUB W0, #0x5, [W15]
001B54  32003C     BRA Z, .L171
001B56  370040     BRA .L165
795:                       case 0:
796:                           n_transfers = 0;
001B58  EF7041     CLR.B n_transfers
797:                           i2c_transfer_status = 1;
001B5A  B3C010     MOV.B #0x1, W0
001B5C  B7F00D     MOV.B WREG, i2c_transfer_status
798:                           break;
001B5E  370043     BRA .L164
799:                       case 1:
800:                           // i2c start condition
801:                           transfer_done = 0;
001B60  EF7004     CLR.B transfer_done
802:                           I2C1CONbits.SEN = 1;
001B62  A80206     BSET I2C1CON, #0
803:                           i2c_transfer_status = 2;
001B64  B3C020     MOV.B #0x2, W0
001B66  B7F00D     MOV.B WREG, i2c_transfer_status
804:                           break;
001B68  37003E     BRA .L164
805:                       case 2:
806:                           // send start byte with address for writing
807:                           transfer_done = 0;
001B6A  EF7004     CLR.B transfer_done
808:                           I2C1TRN = m->address;
001B6C  78001E     MOV [W14], W0
001B6E  784010     MOV.B [W0], W0
001B70  FB8000     ZE W0, W0
001B72  881010     MOV W0, I2C1TRN
809:                           i2c_transfer_status = 3;
001B74  B3C030     MOV.B #0x3, W0
001B76  B7F00D     MOV.B WREG, i2c_transfer_status
810:                           break;
001B78  370036     BRA .L164
811:                       case 3:
812:                           // transfer data byte
813:                           transfer_done = 0;
001B7A  EF7004     CLR.B transfer_done
814:                           if(I2C1STATbits.ACKSTAT == 1) {
001B7C  801041     MOV I2C1STAT, W1
001B7E  280000     MOV #0x8000, W0
001B80  608000     AND W1, W0, W0
001B82  E00000     CP0 W0
001B84  320009     BRA Z, .L174
815:                               m->error = I2C_NO_ACK;
001B86  78001E     MOV [W14], W0
001B88  200011     MOV #0x1, W1
001B8A  980061     MOV W1, [W0+12]
816:                               i2c_transfer_status = 0;
001B8C  EF700D     CLR.B i2c_transfer_status
817:                               I2C1CONbits.PEN = 1;
001B8E  A84206     BSET I2C1CON, #2
818:                               m->status = I2C_MESSAGE_PROCESSING;
001B90  78001E     MOV [W14], W0
001B92  200021     MOV #0x2, W1
001B94  980051     MOV W1, [W0+10]
819:                           } else {
820:                               I2C1TRN = m->data[n_transfers];
001B98  78001E     MOV [W14], W0
001B9A  900090     MOV [W0+2], W1
001B9C  BFD041     MOV.B n_transfers, WREG
001B9E  FB8000     ZE W0, W0
001BA0  408000     ADD W1, W0, W0
001BA2  784010     MOV.B [W0], W0
001BA4  FB8000     ZE W0, W0
001BA6  881010     MOV W0, I2C1TRN
821:                               n_transfers++;
001BA8  BFD041     MOV.B n_transfers, WREG
001BAA  E84000     INC.B W0, W0
001BAC  B7F041     MOV.B WREG, n_transfers
822:                               
823:                               if(n_transfers == m->data_length){
001BAE  78001E     MOV [W14], W0
001BB0  9040C0     MOV.B [W0+4], W1
001BB2  BFD041     MOV.B n_transfers, WREG
001BB4  50CF80     SUB.B W1, W0, [W15]
001BB6  3A0003     BRA NZ, .L176
824:                                   i2c_transfer_status = 4;
001BB8  B3C040     MOV.B #0x4, W0
001BBA  B7F00D     MOV.B WREG, i2c_transfer_status
825:                               } else {
826:                                   i2c_transfer_status = 3;
001BBE  B3C030     MOV.B #0x3, W0
001BC0  B7F00D     MOV.B WREG, i2c_transfer_status
827:                               }
828:                           }
829:               
830:                           break;
001B96  370027     BRA .L164
001BBC  370014     BRA .L164
001BC2  370011     BRA .L164
831:                       case 4:
832:                           // send stop event
833:                           transfer_done = 0;
001BC4  EF7004     CLR.B transfer_done
834:                           I2C1CONbits.PEN = 1;
001BC6  A84206     BSET I2C1CON, #2
835:                           i2c_transfer_status = 5;
001BC8  B3C050     MOV.B #0x5, W0
001BCA  B7F00D     MOV.B WREG, i2c_transfer_status
836:                           break;
001BCC  37000C     BRA .L164
837:                       case 5:
838:                           i2c_transfer_status = 0;
001BCE  EF700D     CLR.B i2c_transfer_status
839:                           m->status = I2C_MESSAGE_PROCESSING;
001BD0  78001E     MOV [W14], W0
001BD2  200021     MOV #0x2, W1
001BD4  980051     MOV W1, [W0+10]
840:                           break;
001BD6  370007     BRA .L164
841:                       default:
842:                           // go back to initial state
843:                           transfer_done = 0;
001BD8  EF7004     CLR.B transfer_done
844:                           I2C1CONbits.PEN = 1;
001BDA  A84206     BSET I2C1CON, #2
845:                           i2c_transfer_status = 0;
001BDC  EF700D     CLR.B i2c_transfer_status
846:                           m->status = I2C_MESSAGE_PROCESSING;
001BDE  78001E     MOV [W14], W0
001BE0  200021     MOV #0x2, W1
001BE2  980051     MOV W1, [W0+10]
847:                           break;
001BE4  000000     NOP
848:                   }
849:               }
001BE6  FA8000     ULNK
001BE8  060000     RETURN
850:               
851:               void alt_i2c_write_controller(i2c_message_t* m){
001BEA  FA0002     LNK #0x2
001BEC  780F00     MOV W0, [W14]
852:                   static uint8_t n_transfers = 0;
853:                  
854:                   switch(i2c_transfer_status){
001BEE  BFD00D     MOV.B i2c_transfer_status, WREG
001BF0  FB8000     ZE W0, W0
001BF2  500FE2     SUB W0, #0x2, [W15]
001BF4  320017     BRA Z, .L181
001BF6  500FE2     SUB W0, #0x2, [W15]
001BF8  3C0005     BRA GT, .L185
001BFA  E00000     CP0 W0
001BFC  32000A     BRA Z, .L179
001BFE  500FE1     SUB W0, #0x1, [W15]
001C00  32000C     BRA Z, .L180
001C02  370047     BRA .L178
001C04  500FE4     SUB W0, #0x4, [W15]
001C06  32003B     BRA Z, .L183
001C08  500FE4     SUB W0, #0x4, [W15]
001C0A  350014     BRA LT, .L182
001C0C  500FE5     SUB W0, #0x5, [W15]
001C0E  32003C     BRA Z, .L184
001C10  370040     BRA .L178
855:                       case 0:
856:                           n_transfers = 0;
001C12  EF7040     CLR.B n_transfers
857:                           i2c_transfer_status = 1;
001C14  B3C010     MOV.B #0x1, W0
001C16  B7F00D     MOV.B WREG, i2c_transfer_status
858:                           break;
001C18  370043     BRA .L177
859:                       case 1:
860:                           // i2c start condition
861:                           transfer_done = 0;
001C1A  EF7004     CLR.B transfer_done
862:                           I2C2CONbits.SEN = 1;
001C1C  A80216     BSET I2C2CON, #0
863:                           i2c_transfer_status = 2;
001C1E  B3C020     MOV.B #0x2, W0
001C20  B7F00D     MOV.B WREG, i2c_transfer_status
864:                           break;
001C22  37003E     BRA .L177
865:                       case 2:
866:                           // send start byte with address for writing
867:                           transfer_done = 0;
001C24  EF7004     CLR.B transfer_done
868:                           I2C2TRN = m->address;
001C26  78001E     MOV [W14], W0
001C28  784010     MOV.B [W0], W0
001C2A  FB8000     ZE W0, W0
001C2C  881090     MOV W0, I2C2TRN
869:                           i2c_transfer_status = 3;
001C2E  B3C030     MOV.B #0x3, W0
001C30  B7F00D     MOV.B WREG, i2c_transfer_status
870:                           break;
001C32  370036     BRA .L177
871:                       case 3:
872:                           // transfer data byte
873:                           transfer_done = 0;
001C34  EF7004     CLR.B transfer_done
874:                           if(I2C2STATbits.ACKSTAT == 1) {
001C36  8010C1     MOV I2C2STAT, W1
001C38  280000     MOV #0x8000, W0
001C3A  608000     AND W1, W0, W0
001C3C  E00000     CP0 W0
001C3E  320009     BRA Z, .L187
875:                               m->error = I2C_NO_ACK;
001C40  78001E     MOV [W14], W0
001C42  200011     MOV #0x1, W1
001C44  980061     MOV W1, [W0+12]
876:                               i2c_transfer_status = 0;
001C46  EF700D     CLR.B i2c_transfer_status
877:                               I2C2CONbits.PEN = 1;
001C48  A84216     BSET I2C2CON, #2
878:                               m->status = I2C_MESSAGE_PROCESSING;
001C4A  78001E     MOV [W14], W0
001C4C  200021     MOV #0x2, W1
001C4E  980051     MOV W1, [W0+10]
879:                           } else {
880:                               I2C2TRN = m->data[n_transfers];
001C52  78001E     MOV [W14], W0
001C54  900090     MOV [W0+2], W1
001C56  BFD040     MOV.B n_transfers, WREG
001C58  FB8000     ZE W0, W0
001C5A  408000     ADD W1, W0, W0
001C5C  784010     MOV.B [W0], W0
001C5E  FB8000     ZE W0, W0
001C60  881090     MOV W0, I2C2TRN
881:                               n_transfers++;
001C62  BFD040     MOV.B n_transfers, WREG
001C64  E84000     INC.B W0, W0
001C66  B7F040     MOV.B WREG, n_transfers
882:                               
883:                               if(n_transfers == m->data_length ){
001C68  78001E     MOV [W14], W0
001C6A  9040C0     MOV.B [W0+4], W1
001C6C  BFD040     MOV.B n_transfers, WREG
001C6E  50CF80     SUB.B W1, W0, [W15]
001C70  3A0003     BRA NZ, .L189
884:                                   i2c_transfer_status = 4;
001C72  B3C040     MOV.B #0x4, W0
001C74  B7F00D     MOV.B WREG, i2c_transfer_status
885:                               } else {
886:                                   i2c_transfer_status = 3;
001C78  B3C030     MOV.B #0x3, W0
001C7A  B7F00D     MOV.B WREG, i2c_transfer_status
887:                               }
888:                           }
889:               
890:                           break;
001C50  370027     BRA .L177
001C76  370014     BRA .L177
001C7C  370011     BRA .L177
891:                       case 4:
892:                           // send stop event
893:                           transfer_done = 0;
001C7E  EF7004     CLR.B transfer_done
894:                           I2C2CONbits.PEN = 1;
001C80  A84216     BSET I2C2CON, #2
895:                           i2c_transfer_status = 5;
001C82  B3C050     MOV.B #0x5, W0
001C84  B7F00D     MOV.B WREG, i2c_transfer_status
896:                           break;
001C86  37000C     BRA .L177
897:                       case 5:
898:                           i2c_transfer_status = 0;
001C88  EF700D     CLR.B i2c_transfer_status
899:                           m->status = I2C_MESSAGE_PROCESSING;
001C8A  78001E     MOV [W14], W0
001C8C  200021     MOV #0x2, W1
001C8E  980051     MOV W1, [W0+10]
900:                           break;
001C90  370007     BRA .L177
901:                       default:
902:                           // go back to initial state
903:                           transfer_done = 0;
001C92  EF7004     CLR.B transfer_done
904:                           I2C2CONbits.PEN = 1;
001C94  A84216     BSET I2C2CON, #2
905:                           i2c_transfer_status = 0;
001C96  EF700D     CLR.B i2c_transfer_status
906:                           m->status = I2C_MESSAGE_PROCESSING;
001C98  78001E     MOV [W14], W0
001C9A  200021     MOV #0x2, W1
001C9C  980051     MOV W1, [W0+10]
907:                           break;
001C9E  000000     NOP
908:                   }
909:               }
001CA0  FA8000     ULNK
001CA2  060000     RETURN
910:               
911:               void blocking_i2c_read_controller(i2c_message_t* m){
001CA4  FA0002     LNK #0x2
001CA6  780F00     MOV W0, [W14]
912:                   switch(m->i2c_bus) {
001CA8  78001E     MOV [W14], W0
001CAA  900820     MOV [W0+20], W0
001CAC  E00000     CP0 W0
001CAE  320006     BRA Z, .L199
001CB0  500FE1     SUB W0, #0x1, [W15]
001CB2  32000D     BRA Z, .L200
913:                       case I2C1_BUS:
914:                           while(m->status != I2C_MESSAGE_HANDLED){
001CBC  000000     NOP
001CBE  78001E     MOV [W14], W0
001CC0  900050     MOV [W0+10], W0
001CC2  E00000     CP0 W0
001CC4  3AFFF8     BRA NZ, .L195
915:                               default_i2c_read_controller(m);
001CB6  78001E     MOV [W14], W0
001CB8  07FC22     RCALL default_i2c_read_controller
001CBA  370001     BRA .L194
916:                           }
917:                           break;
001CC6  370009     BRA .L190
918:                       case I2C2_BUS:
919:                           while(m->status != I2C_MESSAGE_HANDLED){
001CCE  000000     NOP
001CD0  78001E     MOV [W14], W0
001CD2  900050     MOV [W0+10], W0
001CD4  E00000     CP0 W0
001CD6  3AFFF8     BRA NZ, .L198
920:                               alt_i2c_read_controller(m);
001CC8  78001E     MOV [W14], W0
001CCA  07FECE     RCALL alt_i2c_read_controller
001CCC  370001     BRA .L197
921:                           }
922:                           break;
001CD8  000000     NOP
923:                       default:
924:                           break;
001CB4  370012     BRA .L190
925:                   }
926:               }
001CDA  FA8000     ULNK
001CDC  060000     RETURN
927:               
928:               void blocking_i2c_write_controller(i2c_message_t* m){
001CDE  FA0002     LNK #0x2
001CE0  780F00     MOV W0, [W14]
929:                   switch(m->i2c_bus) {
001CE2  78001E     MOV [W14], W0
001CE4  900820     MOV [W0+20], W0
001CE6  E00000     CP0 W0
001CE8  320006     BRA Z, .L210
001CEA  500FE1     SUB W0, #0x1, [W15]
001CEC  32000D     BRA Z, .L211
930:                       case I2C1_BUS:
931:                           while(m->status != I2C_MESSAGE_HANDLED){
001CF6  000000     NOP
001CF8  78001E     MOV [W14], W0
001CFA  900050     MOV [W0+10], W0
001CFC  E00000     CP0 W0
001CFE  3AFFF8     BRA NZ, .L206
932:                               default_i2c_write_controller(m);
001CF0  78001E     MOV [W14], W0
001CF2  07FF1E     RCALL default_i2c_write_controller
001CF4  370001     BRA .L205
933:                           }
934:                           break;
001D00  370009     BRA .L201
935:                       case I2C2_BUS:
936:                           while(m->status != I2C_MESSAGE_HANDLED){
001D08  000000     NOP
001D0A  78001E     MOV [W14], W0
001D0C  900050     MOV [W0+10], W0
001D0E  E00000     CP0 W0
001D10  3AFFF8     BRA NZ, .L209
937:                               alt_i2c_write_controller(m);
001D02  78001E     MOV [W14], W0
001D04  07FF72     RCALL alt_i2c_write_controller
001D06  370001     BRA .L208
938:                           }
939:                           break;
001D12  000000     NOP
940:                       default:
941:                           break;
001CEE  370012     BRA .L201
942:                   }
943:               }
001D14  FA8000     ULNK
001D16  060000     RETURN
944:               
945:               void process_i2c_queue(void){
001D18  FA0000     LNK #0x0
946:                   static i2c_message_t* m = NULL;
947:                   
948:                   if(transfer_done == 1){
001D1A  BFD004     MOV.B transfer_done, WREG
001D1C  504FE1     SUB.B W0, #0x1, [W15]
001D1E  3A0069     BRA NZ, .L212
949:                       if(m != NULL){
001D20  8081F0     MOV m, W0
001D22  E00000     CP0 W0
001D24  32005A     BRA Z, .L214
950:                           switch(m->status){
001D26  8081F0     MOV m, W0
001D28  900050     MOV [W0+10], W0
001D2A  500FE1     SUB W0, #0x1, [W15]
001D2C  320035     BRA Z, .L217
001D2E  500FE1     SUB W0, #0x1, [W15]
001D30  39000C     BRA NC, .L216
001D32  500FE2     SUB W0, #0x2, [W15]
001D34  320003     BRA Z, .L218
001D36  500FE3     SUB W0, #0x3, [W15]
001D38  320034     BRA Z, .L219
001D3A  370039     BRA .L226
951:                               case I2C_MESSAGE_PROCESSING:
952:                                   m->callback(m); // execute callback
001D3C  8081F0     MOV m, W0
001D3E  9000F0     MOV [W0+14], W1
001D40  8081F0     MOV m, W0
001D42  010001     CALL W1
953:                                   m->status = I2C_MESSAGE_HANDLED;
001D44  8081F0     MOV m, W0
001D46  EB0080     CLR W1
001D48  980051     MOV W1, [W0+10]
954:               #ifdef __DEBUG__
955:                       uart_wait();            
956:                       sprintf(print_buffer, "I2C callback.");
957:                       uart_print(print_buffer, strlen(print_buffer));
958:               #endif
959:                               case I2C_MESSAGE_HANDLED:
960:                                   // check if transfer went OK or max attempts reached
961:                                   if((m->error == I2C_NO_ERROR) || (m->n_attempts <= 0)){
001D4A  8081F0     MOV m, W0
001D4C  900060     MOV [W0+12], W0
001D4E  E00000     CP0 W0
001D50  320004     BRA Z, .L220
001D52  8081F0     MOV m, W0
001D54  904800     MOV.B [W0+8], W0
001D56  E00400     CP0.B W0
001D58  3C0013     BRA GT, .L221
962:               #ifdef __DEBUG__
963:                       uart_wait();
964:                       sprintf(print_buffer, "I2C message handled.");
965:                       uart_print(print_buffer, strlen(print_buffer));
966:               #endif
967:                                       T2CONbits.TON = 0; // disable timer (everything OK!)
001D5A  A9E111     BCLR 0x111, #7
968:                                       
969:                                       i2c_queue_idx = (i2c_queue_idx + 1) % I2C_MESSAGE_BUFFER_LENGTH;
001D5C  BFD00A     MOV.B i2c_queue_idx, WREG
001D5E  FB8000     ZE W0, W0
001D60  E80080     INC W0, W1
001D62  2801F0     MOV #0x801F, W0
001D64  608000     AND W1, W0, W0
001D66  E00000     CP0 W0
001D68  3D0004     BRA GE, .L222
001D6A  E90000     DEC W0, W0
001D6C  2FFE01     MOV #0xFFE0, W1
001D6E  708000     IOR W1, W0, W0
001D70  E80000     INC W0, W0
001D72  784000     MOV.B W0, W0
001D74  B7F00A     MOV.B WREG, i2c_queue_idx
970:                                       m = NULL;
001D76  EF303E     CLR m
971:                                       n_i2c_queued_messages--;
001D78  BFD00C     MOV.B n_i2c_queued_messages, WREG
001D7A  E94000     DEC.B W0, W0
001D7C  B7F00C     MOV.B WREG, n_i2c_queued_messages
972:                                   } else {
973:               #ifdef __DEBUG__
974:                       uart_wait();
975:                       sprintf(print_buffer, "I2C ERROR, restarting.");
976:                       uart_print(print_buffer, strlen(print_buffer));
977:               #endif
978:                                       m->n_attempts--;
001D80  8081F0     MOV m, W0
001D82  904880     MOV.B [W0+8], W1
001D84  E94081     DEC.B W1, W1
001D86  984801     MOV.B W1, [W0+8]
979:                                       m->status = I2C_MESSAGE_TRANSFERRING;
001D88  8081F0     MOV m, W0
001D8A  200031     MOV #0x3, W1
001D8C  980051     MOV W1, [W0+10]
980:                                       m->error = I2C_NO_ERROR;
001D8E  8081F0     MOV m, W0
001D90  EB0080     CLR W1
001D92  980061     MOV W1, [W0+12]
981:                                       
982:                                       // TODO: attempt to reset the I2C device?
983:                                       
984:                                       // reset the transfer status (just in case)
985:                                       i2c_transfer_status = 0;
001D94  EF700D     CLR.B i2c_transfer_status
986:                                   }
987:                                   
988:                                   break;
001D7E  370039     BRA .L212
001D96  37002D     BRA .L212
989:                               case I2C_MESSAGE_QUEUED:
990:                                   m->status = I2C_MESSAGE_TRANSFERRING;
001D98  8081F0     MOV m, W0
001D9A  200031     MOV #0x3, W1
001D9C  980051     MOV W1, [W0+10]
991:                                   TMR2 = 0; // clear timer register
001D9E  EF2106     CLR TMR2
992:                                   // start timer: transfer must finish withing approx. 25ms
993:                                   T2CONbits.TON = 1; 
001DA0  A8E111     BSET 0x111, #7
994:               #ifdef __DEBUG__
995:                       uart_wait();
996:                       sprintf(print_buffer, "I2C message queued.");
997:                       uart_print(print_buffer, strlen(print_buffer));
998:               #endif
999:                               case I2C_MESSAGE_TRANSFERRING:
1000:              #ifdef __DEBUG__
1001:                      uart_wait();
1002:                      sprintf(print_buffer, "I2C message transferring.");
1003:                      uart_print(print_buffer, strlen(print_buffer));
1004:              #endif
1005:                                  m->controller(m);
001DA2  8081F0     MOV m, W0
001DA4  9000B0     MOV [W0+6], W1
001DA6  8081F0     MOV m, W0
001DA8  010001     CALL W1
1006:                                  break;
001DAA  000000     NOP
001DAC  370022     BRA .L212
1007:                              default:
1008:                                  T2CONbits.TON = 0; // disable timer (everything OK!)
001DAE  A9E111     BCLR 0x111, #7
1009:                                      
1010:                                  i2c_queue_idx = (i2c_queue_idx + 1) % I2C_MESSAGE_BUFFER_LENGTH;
001DB0  BFD00A     MOV.B i2c_queue_idx, WREG
001DB2  FB8000     ZE W0, W0
001DB4  E80080     INC W0, W1
001DB6  2801F0     MOV #0x801F, W0
001DB8  608000     AND W1, W0, W0
001DBA  E00000     CP0 W0
001DBC  3D0004     BRA GE, .L225
001DBE  E90000     DEC W0, W0
001DC0  2FFE01     MOV #0xFFE0, W1
001DC2  708000     IOR W1, W0, W0
001DC4  E80000     INC W0, W0
001DC6  784000     MOV.B W0, W0
001DC8  B7F00A     MOV.B WREG, i2c_queue_idx
1011:                                  m = NULL;
001DCA  EF303E     CLR m
1012:                                  n_i2c_queued_messages--;
001DCC  BFD00C     MOV.B n_i2c_queued_messages, WREG
001DCE  E94000     DEC.B W0, W0
001DD0  B7F00C     MOV.B WREG, n_i2c_queued_messages
1013:                                  m->status = I2C_MESSAGE_CANCELED;
001DD2  8081F0     MOV m, W0
001DD4  200041     MOV #0x4, W1
001DD6  980051     MOV W1, [W0+10]
001DD8  37000C     BRA .L212
1014:                          }
1015:                      } else {
1016:                          if(i2c_queue_idx != i2c_queue_valid){
001DDA  2100A1     MOV #0x100A, W1
001DDC  784091     MOV.B [W1], W1
001DDE  BFD00B     MOV.B i2c_queue_valid, WREG
001DE0  50CF80     SUB.B W1, W0, [W15]
001DE2  320007     BRA Z, .L212
1017:                              m = i2c_message_queue[i2c_queue_idx];
001DE4  BFD00A     MOV.B i2c_queue_idx, WREG
001DE6  FB8000     ZE W0, W0
001DE8  400080     ADD W0, W0, W1
001DEA  24AEC0     MOV #0x4AEC, W0
001DEC  408000     ADD W1, W0, W0
001DEE  780010     MOV [W0], W0
001DF0  8881F0     MOV W0, m
1018:              #ifdef __DEBUG__
1019:                              uart_wait();
1020:                              sprintf(print_buffer, "Fetched message from queue: %x on bus %x.", m->address, m->i2c_bus);
1021:                              uart_print(print_buffer, strlen(print_buffer));
1022:              #endif
1023:                          }
1024:                      }
1025:                  }
1026:              }
001DF2  FA8000     ULNK
001DF4  060000     RETURN
1027:              
1028:              
1029:              void init_i2c1_slave(i2c_config_t* config){
001DF6  FA0002     LNK #0x2
001DF8  780F00     MOV W0, [W14]
1030:                  _SI2C1IF = 0;
001DFA  A90802     BCLR IFS1, #0
1031:                  _SI2C1IE = 0;
001DFC  A90822     BCLR IEC1, #0
1032:                  
1033:                  I2C1CONbits.I2CEN = 0; // disable I2C1 module
001DFE  A9E207     BCLR 0x207, #7
1034:                  I2C1CONbits.I2CSIDL = 0; // continue operation in idle mode
001E00  A9A207     BCLR 0x207, #5
1035:                  I2C1CONbits.IPMIEN = 0; // do not acknowledge all addresses
001E02  A96207     BCLR 0x207, #3
1036:                  I2C1CONbits.A10M = 0; // 7-bit address mode
001E04  A94207     BCLR 0x207, #2
1037:                  I2C1CONbits.DISSLW = 0; // enable slew rate control
001E06  A92207     BCLR 0x207, #1
1038:                  I2C1CONbits.SMEN = 0; // disable SMBus input thresholds
001E08  A90207     BCLR 0x207, #0
1039:                  I2C1CONbits.GCEN = 0; // general call address is disabled
001E0A  A9E206     BCLR I2C1CON, #7
1040:                  
1041:                  
1042:                  #if defined( I2C_CLOCK_STRETCHING )
1043:                  I2C1CONbits.STREN = 1;  // enable clock stretch
1044:                  I2C1CONbits.SCLREL = 1; // release clock 
1045:                  #endif
1046:              
1047:                  I2C1ADD = config->i2c_address;         // 7-bit I2C slave address must be initialised here.
001E0C  78001E     MOV [W14], W0
001E0E  780010     MOV [W0], W0
001E10  881050     MOV W0, I2C1ADD
1048:                  I2C1MSK = 0; // bit match required for all positions
001E12  EF220C     CLR I2C1MSK
1049:                  
1050:                  // init callbacks
1051:                  i2c_slave_mw_sr_callback = config->mw_sr_cb;
001E14  78001E     MOV [W14], W0
001E16  900020     MOV [W0+4], W0
001E18  888190     MOV W0, i2c_slave_mw_sr_callback
1052:                  i2c_slave_mr_sw_callback = config->mr_sw_cb;
001E1A  78001E     MOV [W14], W0
001E1C  900030     MOV [W0+6], W0
001E1E  8881A0     MOV W0, i2c_slave_mr_sw_callback
1053:                  
1054:                  // save pin configuration
1055:                  i2c1_scl_pin = config->scl_pin;
001E20  2100E0     MOV #0x100E, W0
001E22  78009E     MOV [W14], W1
001E24  900241     MOV [W1+8], W4
001E26  9002D1     MOV [W1+10], W5
001E28  900361     MOV [W1+12], W6
001E2A  9003F1     MOV [W1+14], W7
001E2C  BE9804     MOV.D W4, [W0++]
001E2E  BE9006     MOV.D W6, [W0--]
1056:                  i2c1_sda_pin = config->sda_pin;
001E30  2101E0     MOV #0x101E, W0
001E32  78009E     MOV [W14], W1
001E34  900A01     MOV [W1+16], W4
001E36  900A91     MOV [W1+18], W5
001E38  900B21     MOV [W1+20], W6
001E3A  900BB1     MOV [W1+22], W7
001E3C  BE9804     MOV.D W4, [W0++]
001E3E  BE9006     MOV.D W6, [W0--]
1057:                  
1058:                  I2C1CONbits.I2CEN = 1; // enable I2C1 module
001E40  A8E207     BSET 0x207, #7
1059:                  
1060:                  // configure internal data variables
1061:                  i2c_slave_mr_sw_message = NULL;
001E42  EF3038     CLR i2c_slave_mr_sw_message
1062:                  init_i2c_message(&i2c_slave_mw_sr_message, 0, i2c_slave_mw_sr_data, 0, NULL, 0, NULL, NULL, 0, I2C1_BUS, NULL);
001E44  EB0000     CLR W0
001E46  781F80     MOV W0, [W15++]
001E48  EB0000     CLR W0
001E4A  781F80     MOV W0, [W15++]
001E4C  EB4000     CLR.B W0
001E4E  781F80     MOV W0, [W15++]
001E50  EB0380     CLR W7
001E52  EB0300     CLR W6
001E54  EB4280     CLR.B W5
001E56  EB0200     CLR W4
001E58  EB4180     CLR.B W3
001E5A  24B442     MOV #0x4B44, W2
001E5C  EB4080     CLR.B W1
001E5E  24B2C0     MOV #0x4B2C, W0
001E60  070198     RCALL init_i2c_message
001E62  5787E6     SUB W15, #0x6, W15
1063:                  n_slave_write_transfers = 0;
001E64  EF703A     CLR.B n_slave_write_transfers
1064:                  
1065:                  // clear interrupt flag
1066:                  _SI2C1IF = 0;
001E66  A90802     BCLR IFS1, #0
1067:                  // enable interrupt
1068:                  _SI2C1IE = 1;
001E68  A80822     BSET IEC1, #0
1069:                  
1070:              }
001E6A  FA8000     ULNK
001E6C  060000     RETURN
1071:              
1072:              void init_i2c2_slave(i2c_config_t* config){
001E6E  FA0002     LNK #0x2
001E70  780F00     MOV W0, [W14]
1073:                  _SI2C2IF = 0;
001E72  A92806     BCLR IFS3, #1
1074:                  _SI2C2IE = 0;
001E74  A92826     BCLR IEC3, #1
1075:                  
1076:                  I2C2CONbits.I2CEN = 0; // disable I2C2 module
001E76  A9E217     BCLR 0x217, #7
1077:                  I2C2CONbits.I2CSIDL = 0; // continue operation in idle mode
001E78  A9A217     BCLR 0x217, #5
1078:                  I2C2CONbits.IPMIEN = 0; // do not acknowledge all addresses
001E7A  A96217     BCLR 0x217, #3
1079:                  I2C2CONbits.A10M = 0; // 7-bit address mode
001E7C  A94217     BCLR 0x217, #2
1080:                  I2C2CONbits.DISSLW = 0; // enable slew rate control
001E7E  A92217     BCLR 0x217, #1
1081:                  I2C2CONbits.SMEN = 0; // disable SMBus input thresholds
001E80  A90217     BCLR 0x217, #0
1082:                  I2C2CONbits.GCEN = 0; // general call address is disabled
001E82  A9E216     BCLR I2C2CON, #7
1083:                  
1084:                  
1085:                  #if defined( I2C_CLOCK_STRETCHING )
1086:                  I2C2CONbits.STREN = 1;  // enable clock stretch
1087:                  I2C2CONbits.SCLREL = 1; // release clock 
1088:                  #endif
1089:              
1090:                  I2C2ADD = config->i2c_address;         // 7-bit I2C slave address must be initialised here.
001E84  78001E     MOV [W14], W0
001E86  780010     MOV [W0], W0
001E88  8810D0     MOV W0, I2C2ADD
1091:                  I2C2MSK = 0; // bit match required for all positions
001E8A  EF221C     CLR I2C2MSK
1092:                  
1093:                  // init callbacks
1094:                  i2c_slave_mw_sr_callback = config->mw_sr_cb;
001E8C  78001E     MOV [W14], W0
001E8E  900020     MOV [W0+4], W0
001E90  888190     MOV W0, i2c_slave_mw_sr_callback
1095:                  i2c_slave_mr_sw_callback = config->mr_sw_cb;
001E92  78001E     MOV [W14], W0
001E94  900030     MOV [W0+6], W0
001E96  8881A0     MOV W0, i2c_slave_mr_sw_callback
1096:                  
1097:                  // save pin configuration
1098:                  i2c2_scl_pin = config->scl_pin;
001E98  210160     MOV #0x1016, W0
001E9A  78009E     MOV [W14], W1
001E9C  900241     MOV [W1+8], W4
001E9E  9002D1     MOV [W1+10], W5
001EA0  900361     MOV [W1+12], W6
001EA2  9003F1     MOV [W1+14], W7
001EA4  BE9804     MOV.D W4, [W0++]
001EA6  BE9006     MOV.D W6, [W0--]
1099:                  i2c2_sda_pin = config->sda_pin;
001EA8  210260     MOV #0x1026, W0
001EAA  78009E     MOV [W14], W1
001EAC  900A01     MOV [W1+16], W4
001EAE  900A91     MOV [W1+18], W5
001EB0  900B21     MOV [W1+20], W6
001EB2  900BB1     MOV [W1+22], W7
001EB4  BE9804     MOV.D W4, [W0++]
001EB6  BE9006     MOV.D W6, [W0--]
1100:                  
1101:                  I2C2CONbits.I2CEN = 1; // enable I2C2 module
001EB8  A8E217     BSET 0x217, #7
1102:                  
1103:                  // configure internal data variables
1104:                  i2c_slave_mr_sw_message = NULL;
001EBA  EF3038     CLR i2c_slave_mr_sw_message
1105:                  init_i2c_message(&i2c_slave_mw_sr_message, 0, i2c_slave_mw_sr_data, 0, NULL, 0, NULL, NULL, 0, I2C2_BUS, NULL);
001EBC  EB0000     CLR W0
001EBE  781F80     MOV W0, [W15++]
001EC0  200010     MOV #0x1, W0
001EC2  781F80     MOV W0, [W15++]
001EC4  EB4000     CLR.B W0
001EC6  781F80     MOV W0, [W15++]
001EC8  EB0380     CLR W7
001ECA  EB0300     CLR W6
001ECC  EB4280     CLR.B W5
001ECE  EB0200     CLR W4
001ED0  EB4180     CLR.B W3
001ED2  24B442     MOV #0x4B44, W2
001ED4  EB4080     CLR.B W1
001ED6  24B2C0     MOV #0x4B2C, W0
001ED8  07015C     RCALL init_i2c_message
001EDA  5787E6     SUB W15, #0x6, W15
1106:                  n_slave_write_transfers = 0;
001EDC  EF703A     CLR.B n_slave_write_transfers
1107:                  
1108:                  // clear interrupt flag
1109:                  _SI2C2IF = 0;
001EDE  A92806     BCLR IFS3, #1
1110:                  // enable interrupt
1111:                  _SI2C2IE = 1;
001EE0  A82826     BSET IEC3, #1
1112:                  
1113:              }
001EE2  FA8000     ULNK
001EE4  060000     RETURN
1114:              
1115:              void init_i2c1(i2c_config_t* config){
001EE6  FA0002     LNK #0x2
001EE8  780F00     MOV W0, [W14]
1116:                  switch(config->status){
001EEA  78001E     MOV [W14], W0
001EEC  900010     MOV [W0+2], W0
001EEE  500FE1     SUB W0, #0x1, [W15]
001EF0  360003     BRA LEU, .L231
001EF2  500FE3     SUB W0, #0x3, [W15]
001EF4  3E000D     BRA GTU, .L235
001EF6  370006     BRA .L234
1117:                      case I2C_STATUS_SLAVE_OFF:
1118:                      case I2C_STATUS_SLAVE_ON:
1119:                          init_i2c1_slave(config);
001EF8  78001E     MOV [W14], W0
001EFA  07FF7D     RCALL init_i2c1_slave
1120:                          config->status = I2C_STATUS_SLAVE_ON;
001EFC  78001E     MOV [W14], W0
001EFE  200011     MOV #0x1, W1
001F00  980011     MOV W1, [W0+2]
1121:                          break;
001F02  370007     BRA .L229
1122:                      case I2C_STATUS_MASTER_OFF:
1123:                      case I2C_STATUS_MASTER_ON:
1124:                          init_i2c1_master(config);
001F04  78001E     MOV [W14], W0
001F06  07FA72     RCALL init_i2c1_master
1125:                          config->status = I2C_STATUS_MASTER_ON;
001F08  78001E     MOV [W14], W0
001F0A  200031     MOV #0x3, W1
001F0C  980011     MOV W1, [W0+2]
1126:                          break;
001F0E  370001     BRA .L229
1127:                      default:
1128:                          break;
001F10  000000     NOP
1129:                  }
1130:                  
1131:                  
1132:              }
001F12  FA8000     ULNK
001F14  060000     RETURN
1133:              
1134:              void init_i2c2(i2c_config_t* config){
001F16  FA0002     LNK #0x2
001F18  780F00     MOV W0, [W14]
1135:                  switch(config->status){
001F1A  78001E     MOV [W14], W0
001F1C  900010     MOV [W0+2], W0
001F1E  500FE1     SUB W0, #0x1, [W15]
001F20  360003     BRA LEU, .L238
001F22  500FE3     SUB W0, #0x3, [W15]
001F24  3E000D     BRA GTU, .L242
001F26  370006     BRA .L241
1136:                      case I2C_STATUS_SLAVE_OFF:
1137:                      case I2C_STATUS_SLAVE_ON:
1138:                          init_i2c2_slave(config);
001F28  78001E     MOV [W14], W0
001F2A  07FFA1     RCALL init_i2c2_slave
1139:                          config->status = I2C_STATUS_SLAVE_ON;
001F2C  78001E     MOV [W14], W0
001F2E  200011     MOV #0x1, W1
001F30  980011     MOV W1, [W0+2]
1140:                          break;
001F32  370007     BRA .L236
1141:                      case I2C_STATUS_MASTER_OFF:
1142:                      case I2C_STATUS_MASTER_ON:
1143:                          init_i2c2_master(config);
001F34  78001E     MOV [W14], W0
001F36  070007     RCALL init_i2c2_master
1144:                          config->status = I2C_STATUS_MASTER_ON;
001F38  78001E     MOV [W14], W0
001F3A  200031     MOV #0x3, W1
001F3C  980011     MOV W1, [W0+2]
1145:                          break;
001F3E  370001     BRA .L236
1146:                      default:
1147:                          break;
001F40  000000     NOP
1148:                  }
1149:                  
1150:                  
1151:              }
001F42  FA8000     ULNK
001F44  060000     RETURN
1152:              
1153:              void init_i2c2_master(i2c_config_t* config) {
001F46  FA0004     LNK #0x4
001F48  980710     MOV W0, [W14+2]
1154:                  uint16_t frequency;
1155:                  
1156:                  i2c_reset_callback_init();
001F4A  07FA21     RCALL i2c_reset_callback_init
1157:                  
1158:              #ifdef __LOG__
1159:                  uart_wait();
1160:                  sprintf(print_buffer, "Initialised I2C module 2.");
1161:                  uart_print(print_buffer, strlen(print_buffer));
1162:              #endif
1163:                  
1164:                  transfer_done = 1;
001F4C  B3C010     MOV.B #0x1, W0
001F4E  B7F004     MOV.B WREG, transfer_done
1165:                  i2c_transfer = 0;
001F50  EF7005     CLR.B i2c_transfer
1166:                  
1167:                  I2C2CONbits.A10M = 0; // 7-bit slave address
001F52  A94217     BCLR 0x217, #2
1168:                  I2C2CONbits.SCLREL = 1; // release clock
001F54  A88217     BSET 0x217, #4
1169:                  
1170:                  frequency = FCY/(2*FREQUENCY_SCL) - DELAY_I2C*(FCY/2) - 2;
001F56  2013E0     MOV #0x13E, W0
001F58  780F00     MOV W0, [W14]
1171:                  if(frequency>0x1FF){
001F5A  201FF0     MOV #0x1FF, W0
001F5C  78009E     MOV [W14], W1
001F5E  508F80     SUB W1, W0, [W15]
001F60  360002     BRA LEU, .L244
1172:                      frequency = 0x1FF; // max allowed value for this register
001F62  201FF0     MOV #0x1FF, W0
001F64  780F00     MOV W0, [W14]
1173:                  }
1174:                  I2C2BRG = frequency;
001F66  78009E     MOV [W14], W1
001F68  8810A1     MOV W1, I2C2BRG
1175:                  
1176:                  I2C2ADD = 0x0; // no slave address, this is I2C master
001F6A  EF221A     CLR I2C2ADD
1177:                  I2C2MSK = 0x0; // disable address masking for this bit position
001F6C  EF221C     CLR I2C2MSK
1178:                  
1179:                  I2C2CONbits.I2CEN = 1; // enable I2C module and configure pins as serial port pins
001F6E  A8E217     BSET 0x217, #7
1180:                  _MI2C2IE = 1; // enable I2C interrupt
001F70  A84826     BSET IEC3, #2
1181:                  _MI2C2IF = 0; // clear I2C interrupt flag
001F72  A94806     BCLR IFS3, #2
1182:                  
1183:                  i2c2_bus_status = I2C_BUS_ENABLED;
001F74  200010     MOV #0x1, W0
001F76  888040     MOV W0, i2c2_bus_status
1184:                  
1185:                  T2CONbits.TON = 0;
001F78  A9E111     BCLR 0x111, #7
1186:                  T2CONbits.TCS = 0; // use internal instruction cycle as clock source
001F7A  A92110     BCLR T2CON, #1
1187:                  T2CONbits.TGATE = 0; // disable gated timer
001F7C  A9C110     BCLR T2CON, #6
1188:                  T2CONbits.TCKPS = 0b11; // prescaler 1:256
001F7E  800881     MOV T2CON, W1
001F80  200300     MOV #0x30, W0
001F82  700001     IOR W0, W1, W0
001F84  880880     MOV W0, T2CON
1189:                  TMR2 = 0; // clear timer register
001F86  EF2106     CLR TMR2
1190:                  PR2 = I2C_TIMER_PERIOD - 1; // set period of ADC_SAMPLE_FREQUENCY
001F88  EB8000     SETM W0
001F8A  880860     MOV W0, PR2
1191:                  _T2IF = 0; // clear interrupt flag
001F8C  A9E800     BCLR IFS0, #7
1192:                  _T2IE = 1; // enable interrupt
001F8E  A8E820     BSET IEC0, #7
1193:              }
001F90  FA8000     ULNK
001F92  060000     RETURN
1194:              
1195:              void process_i2c_slave_auto(void){
001F94  FA0002     LNK #0x2
1196:                  uint8_t dummy_read;
1197:              
1198:                  // check for repeated start
1199:                  if((i2c1_state != I2C_SLAVE_STATE_IDLE) && (I2C1STATbits.S == 1) && (I2C1STATbits.D_A == 0)){
001F96  808170     MOV i2c1_state, W0
001F98  E00000     CP0 W0
001F9A  320046     BRA Z, .L246
001F9C  801040     MOV I2C1STAT, W0
001F9E  600068     AND W0, #0x8, W0
001FA0  E00000     CP0 W0
001FA2  320042     BRA Z, .L246
001FA4  801041     MOV I2C1STAT, W1
001FA6  200200     MOV #0x20, W0
001FA8  608000     AND W1, W0, W0
001FAA  E00000     CP0 W0
001FAC  3A003D     BRA NZ, .L246
1200:                      
1201:                      n_slave_write_transfers = 0;
001FAE  EF703A     CLR.B n_slave_write_transfers
1202:                      
1203:                      switch(i2c1_state){
001FB0  808170     MOV i2c1_state, W0
001FB2  500FE1     SUB W0, #0x1, [W15]
001FB4  320003     BRA Z, .L248
001FB6  500FE2     SUB W0, #0x2, [W15]
001FB8  320017     BRA Z, .L249
1204:                          case I2C_SLAVE_STATE_M_READ_S_WRITE:
1205:                              i2c_slave_mr_sw_callback(i2c_slave_mr_sw_message);
001FBC  8081A1     MOV i2c_slave_mr_sw_callback, W1
001FBE  8081C0     MOV i2c_slave_mr_sw_message, W0
001FC0  010001     CALL W1
1206:                              if(I2C1STATbits.R_W == 0){
001FC2  801040     MOV I2C1STAT, W0
001FC4  600064     AND W0, #0x4, W0
001FC6  E00000     CP0 W0
001FC8  3A000C     BRA NZ, .L250
1207:                                  i2c1_state = I2C_SLAVE_STATE_M_WRITE_S_READ;
001FCA  200020     MOV #0x2, W0
001FCC  888170     MOV W0, i2c1_state
1208:                                  
1209:                                  i2c_slave_mw_sr_message.address = I2C1RCV;
001FCE  801000     MOV I2C1RCV, W0
001FD0  784080     MOV.B W0, W1
001FD2  24B2C0     MOV #0x4B2C, W0
001FD4  784801     MOV.B W1, [W0]
1210:                                  i2c_slave_mw_sr_message.error = I2C_NO_ERROR;
001FD6  EB0000     CLR W0
001FD8  8A59C0     MOV W0, 0x4B38
1211:                                  i2c_slave_mw_sr_message.data_length = 0;
001FDA  24B300     MOV #0x4B30, W0
001FDC  EB4080     CLR.B W1
001FDE  784801     MOV.B W1, [W0]
001FE0  370002     BRA .L251
1212:                              } else {
1213:                                  i2c1_state = I2C_SLAVE_STATE_WAIT_FOR_STOP;
001FE2  200030     MOV #0x3, W0
001FE4  888170     MOV W0, i2c1_state
1214:                              }
1215:                              
1216:                              
1217:                              break;
001FE6  37001F     BRA .L252
1218:                          case I2C_SLAVE_STATE_M_WRITE_S_READ:
1219:                              // check if overflow occurred
1220:                              if(I2C1STATbits.I2COV == 1){
001FE8  801041     MOV I2C1STAT, W1
001FEA  200400     MOV #0x40, W0
001FEC  608000     AND W1, W0, W0
001FEE  E00000     CP0 W0
001FF0  320003     BRA Z, .L253
1221:                                  i2c_slave_mw_sr_message.error = I2C_MISSED_DATA;
001FF2  200070     MOV #0x7, W0
001FF4  8A59C0     MOV W0, 0x4B38
1222:                                  I2C1STATbits.I2COV = 0;
001FF6  A9C208     BCLR I2C1STAT, #6
1223:                              }
1224:                              i2c_slave_mw_sr_callback(&i2c_slave_mw_sr_message);
001FF8  808191     MOV i2c_slave_mw_sr_callback, W1
001FFA  24B2C0     MOV #0x4B2C, W0
001FFC  010001     CALL W1
1225:                              
1226:                              if(I2C1STATbits.R_W == 1){
001FFE  801040     MOV I2C1STAT, W0
002000  600064     AND W0, #0x4, W0
002002  E00000     CP0 W0
002004  32000D     BRA Z, .L254
1227:                                  i2c1_state = I2C_SLAVE_STATE_M_READ_S_WRITE;
002006  200010     MOV #0x1, W0
002008  888170     MOV W0, i2c1_state
1228:                                  
1229:                                  // read address    
1230:                                  dummy_read = I2C1RCV;
00200A  801000     MOV I2C1RCV, W0
00200C  784F00     MOV.B W0, [W14]
1231:                                  
1232:                                  // transfer first byte
1233:                                  I2C1TRN = i2c_slave_mr_sw_message->data[0];
00200E  8081C0     MOV i2c_slave_mr_sw_message, W0
002010  900010     MOV [W0+2], W0
002012  784010     MOV.B [W0], W0
002014  FB8000     ZE W0, W0
002016  881010     MOV W0, I2C1TRN
1234:                                  n_slave_write_transfers++;  
002018  BFD03A     MOV.B n_slave_write_transfers, WREG
00201A  E84000     INC.B W0, W0
00201C  B7F03A     MOV.B WREG, n_slave_write_transfers
00201E  370002     BRA .L255
1235:                              } else {
1236:                                  i2c1_state = I2C_SLAVE_STATE_WAIT_FOR_STOP;
002020  200030     MOV #0x3, W0
002022  888170     MOV W0, i2c1_state
1237:                              }
1238:                              break;
002024  000000     NOP
1239:                          default:
1240:                              break;
001FBA  370035     BRA .L252
1241:                      }
1242:                  } else {
002026  3700AB     BRA .L256
1243:                      // check if this is a stop condition
1244:                      if((stop_detected == 1) && (i2c1_state != I2C_SLAVE_STATE_WAIT_FOR_STOP) && (i2c1_state != I2C_SLAVE_STATE_IDLE)){
002028  BFD03C     MOV.B stop_detected, WREG
00202A  504FE1     SUB.B W0, #0x1, [W15]
00202C  3A0016     BRA NZ, .L257
00202E  808170     MOV i2c1_state, W0
002030  500FE3     SUB W0, #0x3, [W15]
002032  320013     BRA Z, .L257
002034  808170     MOV i2c1_state, W0
002036  E00000     CP0 W0
002038  320010     BRA Z, .L257
1245:              
1246:                          switch(i2c1_state){
00203A  808170     MOV i2c1_state, W0
00203C  500FE1     SUB W0, #0x1, [W15]
00203E  320003     BRA Z, .L259
002040  500FE2     SUB W0, #0x2, [W15]
002042  320005     BRA Z, .L260
1247:                              case I2C_SLAVE_STATE_M_READ_S_WRITE:
1248:                                  i2c_slave_mr_sw_callback(i2c_slave_mr_sw_message);
002046  8081A1     MOV i2c_slave_mr_sw_callback, W1
002048  8081C0     MOV i2c_slave_mr_sw_message, W0
00204A  010001     CALL W1
1249:                                  break;
00204C  370004     BRA .L261
1250:                              case I2C_SLAVE_STATE_M_WRITE_S_READ:
1251:                                  i2c_slave_mw_sr_callback(&i2c_slave_mw_sr_message);
00204E  808191     MOV i2c_slave_mw_sr_callback, W1
002050  24B2C0     MOV #0x4B2C, W0
002052  010001     CALL W1
1252:                                  break;
002054  000000     NOP
1253:                              default:
1254:                                  break;
002044  370008     BRA .L261
1255:                          }
1256:                          i2c1_state = I2C_SLAVE_STATE_WAIT_FOR_STOP;
002056  200030     MOV #0x3, W0
002058  888170     MOV W0, i2c1_state
1257:                      }
1258:              
1259:                      // perform actual I/O
1260:                      switch(i2c1_state){
00205A  808170     MOV i2c1_state, W0
00205C  500FE1     SUB W0, #0x1, [W15]
00205E  320037     BRA Z, .L264
002060  500FE1     SUB W0, #0x1, [W15]
002062  390005     BRA NC, .L263
002064  500FE2     SUB W0, #0x2, [W15]
002066  32005E     BRA Z, .L265
002068  500FE3     SUB W0, #0x3, [W15]
00206A  320071     BRA Z, .L266
1261:                          case I2C_SLAVE_STATE_IDLE:
1262:                              // only perform action if this is indeed an address
1263:                              if((I2C1STATbits.D_A == 0) && (I2C1STATbits.S == 1)){
00206E  801041     MOV I2C1STAT, W1
002070  200200     MOV #0x20, W0
002072  608000     AND W1, W0, W0
002074  E00000     CP0 W0
002076  3A007E     BRA NZ, .L281
002078  801040     MOV I2C1STAT, W0
00207A  600068     AND W0, #0x8, W0
00207C  E00000     CP0 W0
00207E  32007C     BRA Z, .L282
1264:              
1265:                                  n_slave_write_transfers = 0;
002080  EF703A     CLR.B n_slave_write_transfers
1266:              
1267:                                  // check is master wants to read/write
1268:                                  if(I2C1STATbits.R_W == 1){
002082  801040     MOV I2C1STAT, W0
002084  600064     AND W0, #0x4, W0
002086  E00000     CP0 W0
002088  320016     BRA Z, .L268
1269:                                      // update next state only if we have data to transmit
1270:                                      if(i2c_slave_mr_sw_message != NULL){
00208A  8081C0     MOV i2c_slave_mr_sw_message, W0
00208C  E00000     CP0 W0
00208E  320010     BRA Z, .L269
1271:                                          i2c1_state = I2C_SLAVE_STATE_M_READ_S_WRITE;
002090  200010     MOV #0x1, W0
002092  888170     MOV W0, i2c1_state
1272:                                          i2c_slave_mr_sw_message->status = I2C_MESSAGE_TRANSFERRING;
002094  8081C0     MOV i2c_slave_mr_sw_message, W0
002096  200031     MOV #0x3, W1
002098  980051     MOV W1, [W0+10]
1273:              
1274:                                          // transfer first byte
1275:                                          I2C1TRN = i2c_slave_mr_sw_message->data[0];
00209A  8081C0     MOV i2c_slave_mr_sw_message, W0
00209C  900010     MOV [W0+2], W0
00209E  784010     MOV.B [W0], W0
0020A0  FB8000     ZE W0, W0
0020A2  881010     MOV W0, I2C1TRN
1276:                                          n_slave_write_transfers++;
0020A4  BFD03A     MOV.B n_slave_write_transfers, WREG
0020A6  E84000     INC.B W0, W0
0020A8  B7F03A     MOV.B WREG, n_slave_write_transfers
1277:              
1278:                                          // read address
1279:                                          dummy_read = I2C1RCV;
0020AA  801000     MOV I2C1RCV, W0
0020AC  784F00     MOV.B W0, [W14]
1280:                                      } else {
1281:                                          i2c1_state = I2C_SLAVE_STATE_WAIT_FOR_STOP;
0020B0  200030     MOV #0x3, W0
0020B2  888170     MOV W0, i2c1_state
1282:                                      }
1283:                                  } else {
1284:                                      i2c1_state = I2C_SLAVE_STATE_M_WRITE_S_READ;
0020B6  200020     MOV #0x2, W0
0020B8  888170     MOV W0, i2c1_state
1285:              
1286:                                      // configure message
1287:                                      i2c_slave_mw_sr_message.address = I2C1RCV;
0020BA  801000     MOV I2C1RCV, W0
0020BC  784080     MOV.B W0, W1
0020BE  24B2C0     MOV #0x4B2C, W0
0020C0  784801     MOV.B W1, [W0]
1288:                                      i2c_slave_mw_sr_message.error = I2C_NO_ERROR;
0020C2  EB0000     CLR W0
0020C4  8A59C0     MOV W0, 0x4B38
1289:                                      i2c_slave_mw_sr_message.data_length = 0;
0020C6  24B300     MOV #0x4B30, W0
0020C8  EB4080     CLR.B W1
0020CA  784801     MOV.B W1, [W0]
1290:                                  }
1291:                              }
1292:                              break;
0020AE  370067     BRA .L256
0020B4  370064     BRA .L256
0020CC  370058     BRA .L256
002174  000000     NOP
002176  370003     BRA .L256
002178  000000     NOP
00217A  370001     BRA .L256
1293:                          case I2C_SLAVE_STATE_M_READ_S_WRITE:
1294:              
1295:                              if(I2C1STATbits.ACKSTAT == 0){
0020CE  801041     MOV I2C1STAT, W1
0020D0  280000     MOV #0x8000, W0
0020D2  608000     AND W1, W0, W0
0020D4  E00000     CP0 W0
0020D6  3A0014     BRA NZ, .L270
1296:                                  // master expects more data
1297:                                  if(n_slave_write_transfers < i2c_slave_mr_sw_message->data_length){
0020D8  8081C0     MOV i2c_slave_mr_sw_message, W0
0020DA  9040C0     MOV.B [W0+4], W1
0020DC  BFD03A     MOV.B n_slave_write_transfers, WREG
0020DE  50CF80     SUB.B W1, W0, [W15]
0020E0  36000C     BRA LEU, .L271
1298:                                      // send data
1299:                                      I2C1TRN = i2c_slave_mr_sw_message->data[n_slave_write_transfers];
0020E2  8081C0     MOV i2c_slave_mr_sw_message, W0
0020E4  900090     MOV [W0+2], W1
0020E6  BFD03A     MOV.B n_slave_write_transfers, WREG
0020E8  FB8000     ZE W0, W0
0020EA  408000     ADD W1, W0, W0
0020EC  784010     MOV.B [W0], W0
0020EE  FB8000     ZE W0, W0
0020F0  881010     MOV W0, I2C1TRN
1300:                                      n_slave_write_transfers++;
0020F2  BFD03A     MOV.B n_slave_write_transfers, WREG
0020F4  E84000     INC.B W0, W0
0020F6  B7F03A     MOV.B WREG, n_slave_write_transfers
1301:              
1302:                                  } else {
1303:                                      i2c1_state = I2C_SLAVE_STATE_WAIT_FOR_STOP;
0020FA  200030     MOV #0x3, W0
0020FC  888170     MOV W0, i2c1_state
1304:                                  }
1305:                              } else {
1306:                                  // master does not request data
1307:                                  if(n_slave_write_transfers == i2c_slave_mr_sw_message->data_length){
002100  8081C0     MOV i2c_slave_mr_sw_message, W0
002102  9040C0     MOV.B [W0+4], W1
002104  BFD03A     MOV.B n_slave_write_transfers, WREG
002106  50CF80     SUB.B W1, W0, [W15]
002108  3A0004     BRA NZ, .L273
1308:                                      i2c_slave_mr_sw_message->status = I2C_MESSAGE_HANDLED;
00210A  8081C0     MOV i2c_slave_mr_sw_message, W0
00210C  EB0080     CLR W1
00210E  980051     MOV W1, [W0+10]
002110  370003     BRA .L274
1309:                                  } else {
1310:                                      i2c_slave_mr_sw_message->status = I2C_MESSAGE_CANCELED;
002112  8081C0     MOV i2c_slave_mr_sw_message, W0
002114  200041     MOV #0x4, W1
002116  980051     MOV W1, [W0+10]
1311:                                  }
1312:                                  i2c_slave_mr_sw_callback(i2c_slave_mr_sw_message);
002118  8081A1     MOV i2c_slave_mr_sw_callback, W1
00211A  8081C0     MOV i2c_slave_mr_sw_message, W0
00211C  010001     CALL W1
1313:                                  i2c1_state = I2C_SLAVE_STATE_WAIT_FOR_STOP;
00211E  200030     MOV #0x3, W0
002120  888170     MOV W0, i2c1_state
1314:                              }
1315:                              break;
0020F8  370042     BRA .L256
0020FE  37003F     BRA .L256
002122  37002D     BRA .L256
1316:                          case I2C_SLAVE_STATE_M_WRITE_S_READ:
1317:                              // fill buffer as long as there is space
1318:                              // indicate overflow if not enough space
1319:                              // send NACK if overflow
1320:                              if(i2c_slave_mw_sr_message.data_length < I2C_W_MESSAGE_BUFFER_LENGTH){
002124  24B300     MOV #0x4B30, W0
002126  784010     MOV.B [W0], W0
002128  504FFF     SUB.B W0, #0x1F, [W15]
00212A  3E000E     BRA GTU, .L275
1321:                                  i2c_slave_mw_sr_message.data[i2c_slave_mw_sr_message.data_length] = I2C1RCV;
00212C  825971     MOV 0x4B2E, W1
00212E  24B300     MOV #0x4B30, W0
002130  784010     MOV.B [W0], W0
002132  FB8000     ZE W0, W0
002134  408000     ADD W1, W0, W0
002136  801001     MOV I2C1RCV, W1
002138  784081     MOV.B W1, W1
00213A  784801     MOV.B W1, [W0]
1322:                                  i2c_slave_mw_sr_message.data_length++;
00213C  24B300     MOV #0x4B30, W0
00213E  784010     MOV.B [W0], W0
002140  E84080     INC.B W0, W1
002142  24B300     MOV #0x4B30, W0
002144  784801     MOV.B W1, [W0]
1323:                              } else {
1324:                                  i2c_slave_mw_sr_message.error = I2C_BUFFER_FULL;
002148  200060     MOV #0x6, W0
00214A  8A59C0     MOV W0, 0x4B38
1325:                              }
1326:              
1327:                              break;
002146  37001B     BRA .L256
00214C  370018     BRA .L256
1328:                          case I2C_SLAVE_STATE_WAIT_FOR_STOP:
1329:              
1330:                              if(stop_detected == 1){
00214E  BFD03C     MOV.B stop_detected, WREG
002150  504FE1     SUB.B W0, #0x1, [W15]
002152  3A0014     BRA NZ, .L283
1331:                                  // read last received byte
1332:                                  if(I2C1STATbits.RBF == 1){
002154  801040     MOV I2C1STAT, W0
002156  600062     AND W0, #0x2, W0
002158  E00000     CP0 W0
00215A  320002     BRA Z, .L278, .LBE3
1333:                                      uint8_t temp;
1334:                                      temp = I2C1RCV;
00215C  801000     MOV I2C1RCV, W0
00215E  984710     MOV.B W0, [W14+1]
1335:                                  }
1336:                                  // clear overflow condition
1337:                                  if(I2C1STATbits.I2COV == 1){
002160  801041     MOV I2C1STAT, W1
002162  200400     MOV #0x40, W0
002164  608000     AND W1, W0, W0
002166  E00000     CP0 W0
002168  320001     BRA Z, .L279
1338:                                      I2C1STATbits.I2COV = 0;
00216A  A9C208     BCLR I2C1STAT, #6
1339:                                  }
1340:              
1341:                                  // go back to idle state
1342:                                  i2c1_state = I2C_SLAVE_STATE_IDLE;
00216C  EF302E     CLR i2c1_state
1343:              
1344:                                  // clear stop bit flag
1345:                                  stop_detected = 0;
00216E  EF703C     CLR.B stop_detected
1346:              
1347:                                  n_slave_write_transfers = 0;
002170  EF703A     CLR.B n_slave_write_transfers
1348:                              }
1349:                              break;
002172  370005     BRA .L256
00217C  000000     NOP
1350:                          default:
1351:                              break;
00206C  370088     BRA .L256
1352:                      }
1353:                  }
1354:                  
1355:                  if(I2C1CONbits.SCLREL == 0){
00217E  801031     MOV I2C1CON, W1
002180  210000     MOV #0x1000, W0
002182  608000     AND W1, W0, W0
002184  E00000     CP0 W0
002186  3A0003     BRA NZ, .L245
1356:                      // we must wait for at least 1 micro second between writing 
1357:                      // I2C1TRN and setting SCLREL
1358:                      __asm__ volatile ("repeat #63");
002188  09003F     REPEAT #0x3F
1359:                      __asm__ volatile ("nop");
00218A  000000     NOP
1360:                      I2C1CONbits.SCLREL = 1;
00218C  A88207     BSET 0x207, #4
1361:                  }
1362:              }
00218E  FA8000     ULNK
002190  060000     RETURN
1363:              
1364:              // TODO: add support for clock stretching
1365:              void __attribute__ ( (interrupt, no_auto_psv) ) _SI2C1Interrupt( void ) {
0006D2  781F80     MOV W0, [W15++]
0006D4  FA0000     LNK #0x0
1366:                  i2c_slave_continue = 1;
0006D6  B3C010     MOV.B #0x1, W0
0006D8  B7F03B     MOV.B WREG, i2c_slave_continue
1367:              
1368:                  _SI2C1IF = 0;               //clear I2C1 Slave interrupt flag
0006DA  A90802     BCLR IFS1, #0
1369:              }
0006DC  FA8000     ULNK
0006DE  78004F     MOV [--W15], W0
0006E0  064000     RETFIE
1370:              
1371:              void init_i2c_message(i2c_message_t* m, uint8_t address, uint8_t* data,
1372:                  uint8_t data_length, void (*controller)(i2c_message_t* m),
1373:                  int8_t n_attempts, void (*callback)(i2c_message_t* m), 
1374:                  uint8_t* processor_data, uint8_t processor_data_length,  i2c_bus_t i2c_bus,
1375:                  i2c_message_t* connected_message){
002192  FA0010     LNK #0x10
002194  780F00     MOV W0, [W14]
002196  984721     MOV.B W1, [W14+2]
002198  980722     MOV W2, [W14+4]
00219A  984763     MOV.B W3, [W14+6]
00219C  980744     MOV W4, [W14+8]
00219E  984F25     MOV.B W5, [W14+10]
0021A0  980766     MOV W6, [W14+12]
0021A2  980777     MOV W7, [W14+14]
1376:                  m->address = address;
0021A4  78001E     MOV [W14], W0
0021A6  9040AE     MOV.B [W14+2], W1
0021A8  784801     MOV.B W1, [W0]
1377:                  m->data = data;
0021AA  78001E     MOV [W14], W0
0021AC  9000AE     MOV [W14+4], W1
0021AE  980011     MOV W1, [W0+2]
1378:                  m->data_length = data_length;
0021B0  78001E     MOV [W14], W0
0021B2  9040EE     MOV.B [W14+6], W1
0021B4  984041     MOV.B W1, [W0+4]
1379:                  m->controller = controller;
0021B6  78001E     MOV [W14], W0
0021B8  9000CE     MOV [W14+8], W1
0021BA  980031     MOV W1, [W0+6]
1380:                  m->status = I2C_MESSAGE_HANDLED;
0021BC  78001E     MOV [W14], W0
0021BE  EB0080     CLR W1
0021C0  980051     MOV W1, [W0+10]
1381:                  m->error = I2C_NO_ERROR;
0021C2  78001E     MOV [W14], W0
0021C4  EB0080     CLR W1
0021C6  980061     MOV W1, [W0+12]
1382:                  m->processor_data = processor_data;
0021C8  78001E     MOV [W14], W0
0021CA  9000FE     MOV [W14+14], W1
0021CC  980801     MOV W1, [W0+16]
1383:                  m->callback = callback;
0021CE  78001E     MOV [W14], W0
0021D0  9000EE     MOV [W14+12], W1
0021D2  980071     MOV W1, [W0+14]
1384:                  m->processor_data_length = processor_data_length;
0021D4  78001E     MOV [W14], W0
0021D6  97F88E     MOV.B [W14-8], W1
0021D8  985021     MOV.B W1, [W0+18]
1385:                  m->i2c_bus = i2c_bus;
0021DA  78001E     MOV [W14], W0
0021DC  97B8BE     MOV [W14-10], W1
0021DE  980821     MOV W1, [W0+20]
1386:                  m->connected_message = connected_message;
0021E0  78001E     MOV [W14], W0
0021E2  97B8AE     MOV [W14-12], W1
0021E4  980831     MOV W1, [W0+22]
1387:                  reset_i2c_message(m, n_attempts);
0021E6  90482E     MOV.B [W14+10], W0
0021E8  784080     MOV.B W0, W1
0021EA  78001E     MOV [W14], W0
0021EC  070019     RCALL reset_i2c_message
1388:              }
0021EE  FA8000     ULNK
0021F0  060000     RETURN
1389:              
1390:              void init_connected_i2c_message(i2c_message_t* sm,
1391:                      i2c_message_t* mm,
1392:                      uint8_t* data,
1393:                      uint8_t data_length){
0021F2  FA0008     LNK #0x8
0021F4  780F00     MOV W0, [W14]
0021F6  980711     MOV W1, [W14+2]
0021F8  980722     MOV W2, [W14+4]
0021FA  984763     MOV.B W3, [W14+6]
1394:                  sm->address = mm->address | 0b1;
0021FC  90001E     MOV [W14+2], W0
0021FE  784010     MOV.B [W0], W0
002200  784080     MOV.B W0, W1
002202  A00401     BSET.B W1, #0
002204  78001E     MOV [W14], W0
002206  784801     MOV.B W1, [W0]
1395:                  sm->data = data;
002208  78001E     MOV [W14], W0
00220A  9000AE     MOV [W14+4], W1
00220C  980011     MOV W1, [W0+2]
1396:                  sm->data_length = data_length;
00220E  78001E     MOV [W14], W0
002210  9040EE     MOV.B [W14+6], W1
002212  984041     MOV.B W1, [W0+4]
1397:                  sm->i2c_bus = mm->i2c_bus;
002214  90001E     MOV [W14+2], W0
002216  9008A0     MOV [W0+20], W1
002218  78001E     MOV [W14], W0
00221A  980821     MOV W1, [W0+20]
1398:              }
00221C  FA8000     ULNK
00221E  060000     RETURN
1399:              
1400:              void reset_i2c_message(i2c_message_t* m, uint8_t n_attempts){
002220  FA0004     LNK #0x4
002222  780F00     MOV W0, [W14]
002224  984721     MOV.B W1, [W14+2]
1401:                  m->n_attempts = n_attempts;
002226  9040AE     MOV.B [W14+2], W1
002228  78001E     MOV [W14], W0
00222A  984801     MOV.B W1, [W0+8]
1402:                  m->status = I2C_MESSAGE_HANDLED;
00222C  78001E     MOV [W14], W0
00222E  EB0080     CLR W1
002230  980051     MOV W1, [W0+10]
1403:                  m->error = I2C_NO_ERROR;
002232  78001E     MOV [W14], W0
002234  EB0080     CLR W1
002236  980061     MOV W1, [W0+12]
1404:              }
002238  FA8000     ULNK
00223A  060000     RETURN
1405:              
1406:              void set_i2c_read_message(i2c_message_t* m){
00223C  FA0002     LNK #0x2
00223E  780F00     MOV W0, [W14]
1407:                  i2c_slave_mr_sw_message = m;
002240  78009E     MOV [W14], W1
002242  8881C1     MOV W1, i2c_slave_mr_sw_message
1408:                  n_slave_write_transfers = 0;
002244  EF703A     CLR.B n_slave_write_transfers
1409:              }
002246  FA8000     ULNK
002248  060000     RETURN
1410:              
1411:              void empty_i2c_queue(void){
00224A  FA0000     LNK #0x0
1412:                  while(n_i2c_queued_messages > 0){
00224C  370001     BRA .L290
002250  BFD00C     MOV.B n_i2c_queued_messages, WREG
002252  E00400     CP0.B W0
002254  3AFFFC     BRA NZ, .L291
1413:                      process_i2c_queue();
00224E  07FD64     RCALL process_i2c_queue
1414:                  }
1415:              }
002256  FA8000     ULNK
002258  060000     RETURN
---  /home/opieters/PhD/gloxinia/src/lib/fir_compressed.s  ----------------------------------------------
                                                  1:     ; include common definitions
                                                  2:     	.nolist
                                                  3:     	.include	"../lib/dspcommon.inc"
                                                  4:     	.list
                                                  5:     
                                                  6:     	.section .dspExtensions, code
                                                  7:     	
                                                  8:     
                                                  9:     
                                                  10:    	
                                                  11:    /*******************************************************************************
                                                  12:      FIR API
                                                  13:    
                                                  14:      Company:
                                                  15:        Microchip Technology Inc.
                                                  16:    
                                                  17:      File Name:
                                                  18:        fir.s
                                                  19:    
                                                  20:      Summary:
                                                  21:        This file has FIR routine
                                                  22:    
                                                  23:      Description:
                                                  24:        This file consists of FIR function which applies an FIR filter to a sequence
                                                  25:     of source samples and  places the result in a sequence of destination samples.
                                                  26:    *******************************************************************************/
                                                  27:    
                                                  28:    /*******************************************************************************
                                                  29:    Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
                                                  30:    
                                                  31:    Microchip licenses to you the right to use, modify, copy and distribute
                                                  32:    Software only when embedded on a Microchip microcontroller or digital signal
                                                  33:    controller that is integrated into your product or third party product
                                                  34:    (pursuant to the sublicense terms in the accompanying license agreement).
                                                  35:    
                                                  36:    You should refer to the license agreement accompanying this Software for
                                                  37:    additional information regarding your rights and obligations.
                                                  38:    
                                                  39:    SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
                                                  40:    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
                                                  41:    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
                                                  42:    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
                                                  43:    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
                                                  44:    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
                                                  45:    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
                                                  46:    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
                                                  47:    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
                                                  48:    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
                                                  49:    *******************************************************************************/
                                                  50:    
                                                  51:    /*****************************************************************************
                                                  52:    // *****************************************************************************
                                                  53:    // Section: Included Files
                                                  54:    // *****************************************************************************
                                                  55:    // *****************************************************************************/
                                                  56:    
                                                  57:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  58:    
                                                  59:     #.section .libdsp, code
                                                  60:    
                                                  61:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  62:    ;
                                                  63:    ; _FIR: FIR block filtering.
                                                  64:    ;
                                                  65:    ; Operation:
                                                  66:    ; y[n] = sum_(m=0:M-1){h[m]*x[n-m]}, 0 <= n < N.
                                                  67:    ;
                                                  68:    ; x[n] defined for 0 <= n < N,
                                                  69:    ; y[n] defined for 0 <= n < N,
                                                  70:    ; h[m] defined for 0 <= m < M as an increasing circular buffer,
                                                  71:    ; NOTE: delay defined for 0 <= m < M as an increasing circular buffer.
                                                  72:    ;
                                                  73:    ; Input:
                                                  74:    ; w0 = number of samples to generate (numSamps, N)
                                                  75:    ; w1 = ptr to output samples (dstSamps, y)
                                                  76:    ; w2 = ptr to input samples (srcSamps, x)
                                                  77:    ; w3 = filter structure (FIRStruct, h)
                                                  78:    ; w4 = decimation factor
                                                  79:    ; w5 = configure DSP engine for signed/unsigned operations (0 = signed, 1 = unsigned)
                                                  80:    ;
                                                  81:    ; Return:
                                                  82:    ; w0 = ptr to output samples (dstSamps, y)
                                                  83:    ;
                                                  84:    ; System resources usage:
                                                  85:    ; {w0..w6} used, not restored
                                                  86:    ; {w8,w10} saved, used, restored
                                                  87:    ;  AccuA  used, not restored
                                                  88:    ;  CORCON  saved, used, restored
                                                  89:    ;  PSVPAG  saved, used, restored (if coeffs in P memory)
                                                  90:    ;  MODCON  saved, used, restored
                                                  91:    ;  XMODSRT saved, used, restored
                                                  92:    ;  XMODEND saved, used, restored
                                                  93:    ;  YMODSRT saved, used, restored
                                                  94:    ;  YMODEND saved, used, restored
                                                  95:    ;
                                                  96:    ; DO and REPEAT instruction usage.
                                                  97:    ; 1 DO instructions
                                                  98:    ; 1 REPEAT intructions
                                                  99:    ;
                                                  100:   ; Program words (24-bit instructions):
                                                  101:   ; 56
                                                  102:   ;
                                                  103:   ; Cycles (including C-function call and return overheads):
                                                  104:   ; 53 + N*(5+M), or
                                                  105:   ; 56 + N*(9+M) if coefficients in P memory.
                                                  106:   ;............................................................................
                                                  107:   
                                                  108:    .global _fir_compressed ; export
                                                  109:   _fir_compressed:
                                                  110:   
                                                  111:   ;............................................................................
                                                  112:   
                                                  113:    ; Save working registers.
00427E  781F88     MOV W8, [W15++]                114:    push w8    ; w8 to TOS
                                                  115:    ;push w9
004280  781F8A     MOV W10, [W15++]               116:    push w10    ; w10 to TOS
                                                  117:   
                                                  118:   ;............................................................................
                                                  119:   
                                                  120:    ; Prepare CORCON for fractional computation.
004282  F80044     PUSH CORCON                    121:    push CORCON
                                                  122:    ;mov.b w5, w9
                                                  123:    ;cp0.b w5
                                                  124:    ;bra z, _signed_setup
                                                  125:    ;fractsetup_unsigned w8
                                                  126:    ;bra _check_psv_access
                                                  127:    ;_signed_setup:
004284  200F08     MOV #0xF0, W8                  128:    fractsetup w8
                                                  129:    
                                                  130:   
                                                  131:   ;............................................................................
                                                  132:   
                                                  133:    ; Prepare CORCON and PSVPAG for possible access of data
                                                  134:    ; located in program memory, using the PSV.
                                                  135:    _check_psv_access:
004288  F80034     PUSH DSWPAG                    136:    push PSVPAG
                                                  137:   
00428A  900533     MOV [W3+6], W10                138:    mov [w3+oCoeffsPage],w10  ; w10= coefficients page
00428C  2FF008     MOV #0xFF00, W8                139:    mov #COEFFS_IN_DATA,w8  ; w8 = COEFFS_IN_DATA
00428E  E1400A     CP W8, W10                     140:    cp w8,w10    ; w8 - w10
004290  320004     BRA Z, 0x429A                  141:    bra z,_noPSVfir   ; if w10 = COEFFS_IN_DATA
                                                  142:         ; no PSV management
                                                  143:         ; else
004292  800228     MOV CORCON, W8                 144:    psvaccess w8   ; enable PSV bit in CORCON
004298  8801AA     MOV W10, DSWPAG                145:    mov w10,PSVPAG   ; load PSVPAG with program
                                                  146:         ; space page offset
                                                  147:   _noPSVfir:
                                                  148:   
                                                  149:   ;............................................................................
                                                  150:   
                                                  151:    ; Prepare core registers for modulo addressing.
00429A  F80046     PUSH MODCON                    152:    push MODCON
00429C  F80048     PUSH XMODSRT                   153:    push XMODSRT
00429E  F8004A     PUSH XMODEND                   154:    push XMODEND
0042A0  F8004C     PUSH YMODSRT                   155:    push YMODSRT
0042A2  F8004E     PUSH YMODEND                   156:    push YMODEND
                                                  157:   
                                                  158:   ;............................................................................
                                                  159:   
                                                  160:    ; Setup registers for modulo addressing.
0042A4  2C0A8A     MOV #0xC0A8, W10               161:    mov #0xC0A8,w10   ; XWM = w8, YWM = w10
                                                  162:         ; set XMODEND and YMODEND bits
0042A6  900453     MOV [W3+10], W8                163:    mov [w3+oDelayEnd],w8  ; w8 -> last byte of d[M-1] 
0042A8  88023A     MOV W10, MODCON                164:    mov w10,MODCON   ; enable X,Y modulo addressing
                                                  165:    ; do NOT use an indirect read operation to ANY w register after modifying MODCON
                                                  166:    
0042AA  880258     MOV W8, XMODEND                167:    mov w8,XMODEND   ; init'ed to coeffs end address
0042AC  900523     MOV [W3+4], W10                168:    mov [w3+oCoeffsEnd],w10  ; w10-> last byte of h[M-1]
0042AE  88027A     MOV W10, YMODEND               169:    mov w10,YMODEND   ; init'ed to delay end address
0042B0  900443     MOV [W3+8], W8                 170:    mov [w3+oDelayBase],w8  ; w8 -> d[0]
0042B2  880248     MOV W8, XMODSRT                171:    mov w8,XMODSRT   ; init'ed to coeffs base address
                                                  172:         ; (increasing buffer,
                                                  173:         ;  2^n aligned)
0042B4  900513     MOV [W3+2], W10                174:    mov [w3+oCoeffsBase],w10  ; w10 -> h[0]
0042B6  88026A     MOV W10, YMODSRT               175:    mov w10,YMODSRT   ; init'ed to delay base address
                                                  176:         ; (increasing buffer,
                                                  177:         ;  2^n aligned)
                                                  178:   ; DO NOT read X/Y register indirectly immediately after modifying XMODi, YMODi
                                                  179:   
                                                  180:   ;............................................................................
                                                  181:   
0042B8  781F81     MOV W1, [W15++]                182:    push w1    ; save return value (y)
                                                  183:   
                                                  184:   ;............................................................................
                                                  185:   
                                                  186:    ; Perpare to all filter.
0042BA  E90384     DEC W4, W7                     187:    dec w4, w7
0042BC  900463     MOV [W3+12], W8                188:    mov [w3+oDelay],w8   ; w10 points at oldest delay entry
                                                  189:         ; sample d[m], 0 <= m < M
0042BE  900203     MOV [W3+0], W4                 190:    mov [w3+oNumCoeffs],w4  ; w4 = M
0042C0  520262     SUB W4, #0x2, W4               191:    sub w4,#2,w4   ; W4 = M-2
0042C2  E90000     DEC W0, W0                     192:    dec w0,w0    ; w0 = N-1
                                                  193:   
                                                  194:   
                                                  195:   ;............................................................................
                                                  196:   
                                                  197:    ; Perform filtering of all samples.
0042C4  088000     DO W0, 0x42D4                  198:    do w0,_endFilterfir  ; { ; do (N-1)+1 times
                                                  199:   
                                                  200:    ; Prepare to filter sample.
0042C8  098007     REPEAT W7                      201:    repeat w7
0042CA  781C32     MOV [W2++], [W8++]             202:    mov [w2++],[w8++]
                                                  203:   ;.ifdef YMEM_ERRATA
                                                  204:   ;	nop
                                                  205:   ;.endif
                                                  206:    
                                                  207:   	;do w7, _copy_x
                                                  208:   	;mov [w2++],[w8++]
                                                  209:   	;nop
                                                  210:   	;nop
                                                  211:   	;_copy_x:
                                                  212:   	;nop
                                                  213:   
0042CC  C32446     CLR A, [W8]+=2, W6, [W10]+=2, W5214:    clr a,[w8]+=2,w6,[w10]+=2,w5 ; a  = 0
                                                  215:         ; w5 = h[0]
                                                  216:         ; w8-> h[1]
                                                  217:         ; w6 = d[oldest]
                                                  218:         ; w10->d[oldest+1]
                                                  219:   
                                                  220:    ; Filter each sample.
                                                  221:    ; (Perform all but two last MACs.)
0042CE  098004     REPEAT W4                      222:    repeat w4   ; { ; do (M-2)+1 times
0042D0  C42446     MAC W5*W6, A, [W8]+=2, W6, [W10]+=2, W5223:    mac w5*w6,a,[w8]+=2,w6,[w10]+=2,w5 ; a += h[m]*d[current]
                                                  224:         ; w5 = h[m]
                                                  225:         ; w8-> h[m+1]
                                                  226:         ; w6 = d[oldest+m]
                                                  227:         ; w10->d[oldest+m+1]
                                                  228:   ; }
                                                  229:    ; (Perform second last MAC.)
                                                  230:    
                                                  231:    ;mac w5*w6,a,[w8]+=2,w5,[w10],w6 ; a += h[M-2]*d[current]
                                                  232:         ; w5 = h[M-1]
                                                  233:         ; w8-> h[0]
                                                  234:         ; w6 = d[next]
                                                  235:         ; w10->d[next]
                                                  236:    ; (Perform last MAC.)
                                                  237:    
0042D2  C40112     MAC W5*W6, A                   238:    mac w5*w6,a    ; a += h[M-1]*d[current]
                                                  239:    
                                                  240:    ;cp0.b w9
                                                  241:    ;bra z, _endFilterfir
                                                  242:    ;sftac a, #1
                                                  243:   
                                                  244:   
                                                  245:   _endFilterfir:
                                                  246:    ; Save filtered result.
0042D4  CD0031     SAC.R A, [W1++]                247:    sac.r a,[w1++]   ; y[n] =
                                                  248:         ;   sum_{m=0:M-1}(h[m]*x[n-m])
                                                  249:         ; w1-> y[n+1]
                                                  250:   ; }
                                                  251:   
                                                  252:   ;............................................................................
                                                  253:   
                                                  254:    ; Update delay pointer.
0042D6  9801E8     MOV W8, [W3+12]                255:    mov w8,[w3+oDelay]   ; note that the delay pointer
                                                  256:         ; may wrap several times around
                                                  257:         ; d[m], 0 <= m < M, depending
                                                  258:         ; on the value of N
                                                  259:         
                                                  260:   
                                                  261:   ;............................................................................
                                                  262:   
0042D8  78004F     MOV [--W15], W0                263:    pop w0    ; restore return value
                                                  264:   
                                                  265:   ;............................................................................
                                                  266:   
                                                  267:    ; Restore core registers for modulo addressing.
0042DA  F9004E     POP YMODEND                    268:    pop YMODEND
0042DC  F9004C     POP YMODSRT                    269:    pop YMODSRT
0042DE  F9004A     POP XMODEND                    270:    pop XMODEND
0042E0  F90048     POP XMODSRT                    271:    pop XMODSRT
0042E2  F90046     POP MODCON                     272:    pop MODCON
                                                  273:   
                                                  274:   ;............................................................................
                                                  275:   
                                                  276:    ; Restore PSVPAG and CORCON.
0042E4  F90034     POP DSWPAG                     277:    pop PSVPAG
0042E6  F90044     POP CORCON                     278:    pop CORCON
                                                  279:   
                                                  280:   ;............................................................................
                                                  281:   
                                                  282:    ; Restore working registers.
0042E8  78054F     MOV [--W15], W10               283:    pop w10    ; w10 from TOS
                                                  284:    ;pop w9
0042EA  78044F     MOV [--W15], W8                285:    pop w8    ; w8 from TOS
                                                  286:   
                                                  287:   ;............................................................................
                                                  288:   
0042EC  060000     RETURN                         289:    return 
                                                  290:   
                                                  291:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  292:    
                                                  293:    
                                                  294:    
                                                  295:    .global _covert_uint_to_fract ; export
                                                  296:   _covert_uint_to_fract:
0042EE  E90000     DEC W0, W0                     297:       dec w0, w0
0042F0  280003     MOV #0x8000, W3                298:       mov #0x8000, w3
0042F2  098000     REPEAT W0                      299:       repeat w0
0042F4  419931     ADD W3, [W1++], [W2++]         300:       add w3, [w1++], [w2++]
0042F6  060000     RETURN                         301:       return
                                                  302:       
                                                  303:   .global _copy_adc_data
                                                  304:       ; w0 = total number of coefficients to copy
                                                  305:       ; w1 = pointer to dst
                                                  306:       ; w2 = pointer to src
                                                  307:   _copy_adc_data:
                                                  308:       ;lsr w0, #3, w0  
0042F8  E90000     DEC W0, W0                     309:       dec w0, w0
0042FA  F80032     PUSH DSRPAG                    310:       push DSRPAG
0042FC  200013     MOV #0x1, W3                   311:       mov #0x0001, w3
0042FE  880193     MOV W3, DSRPAG                 312:       mov w3, DSRPAG
004300  200083     MOV #0x8, W3                   313:       mov #0x0008, w3
004302  088000     DO W0, 0x430C                  314:       do w0, _final_copy
004306  781892     MOV [W2], [W1++]               315:       mov [w2], [w1++]
004308  000000     NOP                            316:       nop
00430A  000000     NOP                            317:       nop
                                                  318:   _final_copy:
00430C  410103     ADD W2, W3, W2                 319:       add w2, w3, w2
00430E  F90032     POP DSRPAG                     320:       pop DSRPAG
004310  060000     RETURN                         321:       return
                                                  322:       
                                                  323:       
---  /home/opieters/PhD/gloxinia/src/lib/adc.c  ---------------------------------------------------------
1:                 #include <adc.h>
2:                 #include <utilities.h>
3:                 #include <device_configuration.h>
4:                 
5:                 #include <spi.h>
6:                 
7:                 #ifdef ENABLE_DEBUG
8:                 #include <uart.h>
9:                 #include <stdio.h>
10:                #include <string.h>
11:                static char print_buffer[64];
12:                #endif
13:                
14:                unsigned int adc_tx_buffer[ADC_BUFFER_LENGTH] __attribute__((space(dma), eds));
15:                
16:                unsigned int adc_rx_buffer_a[ADC_BUFFER_LENGTH]__attribute__((space(dma), eds, address(0xD9C0)));
17:                unsigned int adc_rx_buffer_b[ADC_BUFFER_LENGTH] __attribute__((space(dma), eds, address(0xD830)));
18:                
19:                void (*rx_callback)(void) = rx_callback_dummy;
20:                
21:                void rx_callback_dummy(void){
002CBA  FA0000     LNK #0x0
22:                    
23:                }
002CBC  FA8000     ULNK
002CBE  060000     RETURN
24:                
25:                uint16_t adc_parse_cfr_write(adc_config_t* config){
002CC0  FA0004     LNK #0x4
002CC2  980710     MOV W0, [W14+2]
26:                    uint16_t word = 0xE000;
002CC4  2E0000     MOV #0xE000, W0
002CC6  780F00     MOV W0, [W14]
27:                
28:                    word |= (config->channel_select << 11) 
002CC8  90001E     MOV [W14+2], W0
002CCA  780010     MOV [W0], W0
002CCC  DD00CB     SL W0, #11, W1
002D24  700F1E     IOR W0, [W14], [W14]
29:                            | (config->conversion_clock_source << 10) 
002CCE  90001E     MOV [W14+2], W0
002CD0  900010     MOV [W0+2], W0
002CD2  DD004A     SL W0, #10, W0
002CD4  700081     IOR W0, W1, W1
30:                            | (config->trigger_select << 9) 
002CD6  90001E     MOV [W14+2], W0
002CD8  900020     MOV [W0+4], W0
002CDA  DD0049     SL W0, #9, W0
002CDC  700081     IOR W0, W1, W1
31:                            | (config->auto_trigger_rate << 8)
002CDE  90001E     MOV [W14+2], W0
002CE0  900030     MOV [W0+6], W0
002CE2  DD0048     SL W0, #8, W0
002CE4  700081     IOR W0, W1, W1
32:                            | (config->pin10_polarity << 7)
002CE6  90001E     MOV [W14+2], W0
002CE8  900040     MOV [W0+8], W0
002CEA  DD0047     SL W0, #7, W0
002CEC  700081     IOR W0, W1, W1
33:                            | (config->pin10_output << 6)
002CEE  90001E     MOV [W14+2], W0
002CF0  900050     MOV [W0+10], W0
002CF2  DD0046     SL W0, #6, W0
002CF4  700081     IOR W0, W1, W1
34:                            | (config->pin10_io << 5)
002CF6  90001E     MOV [W14+2], W0
002CF8  900060     MOV [W0+12], W0
002CFA  DD0045     SL W0, #5, W0
002CFC  700081     IOR W0, W1, W1
35:                            | (config->auto_nap << 4)
002CFE  90001E     MOV [W14+2], W0
002D00  900070     MOV [W0+14], W0
002D02  DD0044     SL W0, #4, W0
002D04  700081     IOR W0, W1, W1
36:                            | (config->nap_powerdown << 3)
002D06  90001E     MOV [W14+2], W0
002D08  900800     MOV [W0+16], W0
002D0A  DD0043     SL W0, #3, W0
002D0C  700081     IOR W0, W1, W1
37:                            | (config->deep_powerdown << 2)
002D0E  90001E     MOV [W14+2], W0
002D10  900810     MOV [W0+18], W0
002D12  DD0042     SL W0, #2, W0
002D14  700081     IOR W0, W1, W1
38:                            | (config->tag_output << 1)
002D16  90001E     MOV [W14+2], W0
002D18  900820     MOV [W0+20], W0
002D1A  400000     ADD W0, W0, W0
002D1C  700081     IOR W0, W1, W1
39:                            | (config->sw_reset);
002D1E  90001E     MOV [W14+2], W0
002D20  900830     MOV [W0+22], W0
002D22  700001     IOR W0, W1, W0
40:                
41:                    return word;
002D26  78001E     MOV [W14], W0
42:                }
002D28  FA8000     ULNK
002D2A  060000     RETURN
43:                
44:                void init_adc(adc_config_t* config){
002D2C  FA0024     LNK #0x24
002D2E  981710     MOV W0, [W14+34]
45:                    uint16_t i, eds_read;
46:                    spi_message_t m;
47:                    uint16_t write_data[2];
48:                    uint16_t read_data[2];
49:                    read_data[0] = 0x0;
002D30  EB0000     CLR W0
002D32  980F70     MOV W0, [W14+30]
50:                    void (*send_spi_message) (spi_message_t* m);
51:                    
52:                #ifdef HW_C_BURCHELLII_REV1
53:                    // configure CONV signal pin
54:                    _TRISE7 = 0;          // configure RE7 (RP87) as output
55:                    _RP87R = _RPOUT_OC15;  // connect RP87 to UART2 TX
56:                    _TRISD2 = 0;      
57:                    _RP66R = _RPOUT_OC15; 
58:                
59:                #elif defined(HW_C_SYLVATICA_REV1)
60:                #else
61:                    //TODO
62:                //#error "Hardware configuration not supported."
63:                #endif
64:                    
65:                    // configure nCS pin as output and set pin high
66:                    // TODO
67:                    //CLEAR_BIT(config->cs_pin.tris_r, config->cs_pin.n);
68:                    //SET_BIT(config->cs_pin.lat_r, config->cs_pin.n);
69:                    
70:                    // configure reset pin and set high)
71:                    CLEAR_BIT(config->rst_pin.tris_r, config->rst_pin.n);
002D34  90101E     MOV [W14+34], W0
002D36  901120     MOV [W0+36], W2
002D38  90101E     MOV [W14+34], W0
002D3A  901020     MOV [W0+36], W0
002D3C  780190     MOV [W0], W3
002D3E  90101E     MOV [W14+34], W0
002D40  906800     MOV.B [W0+40], W0
002D42  FB8200     ZE W0, W4
002D44  200010     MOV #0x1, W0
002D46  200001     MOV #0x0, W1
002D48  780284     MOV W4, W5
002D4A  E90285     DEC W5, W5
002D4C  330003     BRA N, .LE96
002D4E  400000     ADD W0, W0, W0
002D50  488081     ADDC W1, W1, W1
002D52  37FFFB     BRA .LB96
002D54  780000     MOV W0, W0
002D56  EA8000     COM W0, W0
002D58  618000     AND W3, W0, W0
002D5A  780900     MOV W0, [W2]
72:                    SET_BIT(config->rst_pin.lat_r, config->rst_pin.n);
002D5C  90101E     MOV [W14+34], W0
002D5E  901130     MOV [W0+38], W2
002D60  90101E     MOV [W14+34], W0
002D62  901030     MOV [W0+38], W0
002D64  780190     MOV [W0], W3
002D66  90101E     MOV [W14+34], W0
002D68  906800     MOV.B [W0+40], W0
002D6A  FB8200     ZE W0, W4
002D6C  200010     MOV #0x1, W0
002D6E  200001     MOV #0x0, W1
002D70  780284     MOV W4, W5
002D72  E90285     DEC W5, W5
002D74  330003     BRA N, .LE111
002D76  400000     ADD W0, W0, W0
002D78  488081     ADDC W1, W1, W1
002D7A  37FFFB     BRA .LB111
002D7C  780000     MOV W0, W0
002D7E  700003     IOR W0, W3, W0
002D80  780900     MOV W0, [W2]
73:                    
74:                    // hardware reset of ADC
75:                    delay_us(100);
002D82  200640     MOV #0x64, W0
002D84  070A01     RCALL delay_us
76:                    CLEAR_BIT(config->rst_pin.lat_r, config->rst_pin.n);
002D86  90101E     MOV [W14+34], W0
002D88  901130     MOV [W0+38], W2
002D8A  90101E     MOV [W14+34], W0
002D8C  901030     MOV [W0+38], W0
002D8E  780190     MOV [W0], W3
002D90  90101E     MOV [W14+34], W0
002D92  906800     MOV.B [W0+40], W0
002D94  FB8200     ZE W0, W4
002D96  200010     MOV #0x1, W0
002D98  200001     MOV #0x0, W1
002D9A  780284     MOV W4, W5
002D9C  E90285     DEC W5, W5
002D9E  330003     BRA N, .LE127
002DA0  400000     ADD W0, W0, W0
002DA2  488081     ADDC W1, W1, W1
002DA4  37FFFB     BRA .LB127
002DA6  780000     MOV W0, W0
002DA8  EA8000     COM W0, W0
002DAA  618000     AND W3, W0, W0
002DAC  780900     MOV W0, [W2]
77:                    delay_us(100);
002DAE  200640     MOV #0x64, W0
002DB0  0709EB     RCALL delay_us
78:                    SET_BIT(config->rst_pin.lat_r, config->rst_pin.n);
002DB2  90101E     MOV [W14+34], W0
002DB4  901130     MOV [W0+38], W2
002DB6  90101E     MOV [W14+34], W0
002DB8  901030     MOV [W0+38], W0
002DBA  780190     MOV [W0], W3
002DBC  90101E     MOV [W14+34], W0
002DBE  906800     MOV.B [W0+40], W0
002DC0  FB8200     ZE W0, W4
002DC2  200010     MOV #0x1, W0
002DC4  200001     MOV #0x0, W1
002DC6  780284     MOV W4, W5
002DC8  E90285     DEC W5, W5
002DCA  330003     BRA N, .LE144
002DCC  400000     ADD W0, W0, W0
002DCE  488081     ADDC W1, W1, W1
002DD0  37FFFB     BRA .LB144
002DD2  780000     MOV W0, W0
002DD4  700003     IOR W0, W3, W0
002DD6  780900     MOV W0, [W2]
79:                    
80:                    // configure DMA2 to write data over SPI
81:                    _DMA2IF = 0;
002DD8  A90803     BCLR 0x803, #0
82:                    _DMA2IE = 0;
002DDA  A90823     BCLR 0x823, #0
83:                    
84:                    DMA2CONbits.SIZE = 0; // word data transfer
002DDC  A9CB21     BCLR 0xB21, #6
85:                    DMA2CONbits.HALF = 0; // interrupt when all data is transfered
002DDE  A98B21     BCLR 0xB21, #4
86:                    DMA2CONbits.NULLW = 0; // normal operation
002DE0  A96B21     BCLR 0xB21, #3
87:                    DMA2CONbits.DIR = 1; // read from RAM to peripheral
002DE2  A8AB21     BSET 0xB21, #5
88:                    DMA2CONbits.AMODE = 0; // register indirect with post increment
002DE4  805901     MOV DMA2CON, W1
002DE6  2FFCF0     MOV #0xFFCF, W0
002DE8  608000     AND W1, W0, W0
002DEA  885900     MOV W0, DMA2CON
89:                    DMA2CONbits.MODE = 0; // continuous ping-pong mode
002DEC  805901     MOV DMA2CON, W1
002DEE  2FFFC0     MOV #0xFFFC, W0
002DF0  608000     AND W1, W0, W0
002DF2  885900     MOV W0, DMA2CON
90:                    
91:                    DMA2REQbits.IRQSEL = 0b00000001; // select input compare 1 as trigger source
002DF4  B3C010     MOV.B #0x1, W0
002DF6  B7EB22     MOV.B WREG, DMA2REQ
92:                    
93:                    DMA2STAL = __builtin_dmaoffset(adc_tx_buffer);
002DF8  2DB500     MOV #0xDB50, W0
002DFA  885920     MOV W0, DMA2STAL
94:                    DMA2STAH = __builtin_dmapage(adc_tx_buffer);
002DFC  200000     MOV #0x0, W0
002DFE  885930     MOV W0, DMA2STAH
95:                    
96:                    switch(config->spi_module){
002E00  90101E     MOV [W14+34], W0
002E02  901000     MOV [W0+32], W0
002E04  500FE1     SUB W0, #0x1, [W15]
002E06  320008     BRA Z, .L6
002E08  500FE1     SUB W0, #0x1, [W15]
002E0A  390003     BRA NC, .L5
002E0C  500FE2     SUB W0, #0x2, [W15]
002E0E  320007     BRA Z, .L7
002E10  370009     BRA .L24
97:                        case SPI_MODULE_SELECTOR_1:
98:                            DMA2PAD = (volatile unsigned int) &SPI1BUF; // peripheral address
002E12  202480     MOV #0x248, W0
002E14  885960     MOV W0, DMA2PAD
99:                            break;
002E16  370009     BRA .L8
100:                       case SPI_MODULE_SELECTOR_2:
101:                           DMA2PAD = (volatile unsigned int) &SPI2BUF; // peripheral address
002E18  202680     MOV #0x268, W0
002E1A  885960     MOV W0, DMA2PAD
102:                           break;
002E1C  370006     BRA .L8
103:                       case SPI_MODULE_SELECTOR_3:
104:                           DMA2PAD = (volatile unsigned int) &SPI3BUF; // peripheral address
002E1E  202A80     MOV #0x2A8, W0
002E20  885960     MOV W0, DMA2PAD
105:                           break;
002E22  370003     BRA .L8
106:                       default:
107:                           DMA2PAD = (volatile unsigned int) &SPI1BUF; // peripheral address
002E24  202480     MOV #0x248, W0
002E26  885960     MOV W0, DMA2PAD
108:                           break;
002E28  000000     NOP
109:                   }
110:                   
111:                   
112:                   
113:                   DMA2CNT = ADC_BUFFER_LENGTH-1;
002E2A  200C70     MOV #0xC7, W0
002E2C  885970     MOV W0, DMA2CNT
114:                  
115:                   _DMA2IE = 0;
002E2E  A90823     BCLR 0x823, #0
116:                   
117:                   // configure DMA3 to read data over SPI
118:                   _DMA3IF = 0;
002E30  A98804     BCLR IFS2, #4
119:                   _DMA3IE = 0;
002E32  A98824     BCLR IEC2, #4
120:                   
121:                   DMA3CONbits.SIZE = 0; // word data transfer
002E34  A9CB31     BCLR 0xB31, #6
122:                   DMA3CONbits.HALF = 0; // interrupt when all data is transfered
002E36  A98B31     BCLR 0xB31, #4
123:                   DMA3CONbits.NULLW = 0; // normal operation
002E38  A96B31     BCLR 0xB31, #3
124:                   DMA3CONbits.DIR = 0; // read from peripheral to RAM
002E3A  A9AB31     BCLR 0xB31, #5
125:                   DMA3CONbits.AMODE = 0; // register indirect with post increment
002E3C  805981     MOV DMA3CON, W1
002E3E  2FFCF0     MOV #0xFFCF, W0
002E40  608000     AND W1, W0, W0
002E42  885980     MOV W0, DMA3CON
126:                   DMA3CONbits.MODE = 2; // continuous ping-pong mode
002E44  805981     MOV DMA3CON, W1
002E46  2FFFC0     MOV #0xFFFC, W0
002E48  608000     AND W1, W0, W0
002E4A  A01000     BSET W0, #1
002E4C  885980     MOV W0, DMA3CON
127:                   
128:                   switch(config->spi_module){
002E4E  90101E     MOV [W14+34], W0
002E50  901000     MOV [W0+32], W0
002E52  500FE1     SUB W0, #0x1, [W15]
002E54  32000A     BRA Z, .L11
002E56  500FE1     SUB W0, #0x1, [W15]
002E58  390003     BRA NC, .L10
002E5A  500FE2     SUB W0, #0x2, [W15]
002E5C  32000B     BRA Z, .L12
002E5E  37000F     BRA .L25
129:                       case SPI_MODULE_SELECTOR_1:
130:                           DMA3REQbits.IRQSEL = 0b00001010; // select SPI1 transfer done as trigger source
002E60  B3C0A0     MOV.B #0xA, W0
002E62  B7EB32     MOV.B WREG, DMA3REQ
131:                           DMA3PAD = (volatile unsigned int) &SPI1BUF; // peripheral address
002E64  202480     MOV #0x248, W0
002E66  8859E0     MOV W0, DMA3PAD
132:                           break;
002E68  37000F     BRA .L13
133:                       case SPI_MODULE_SELECTOR_2:
134:                           DMA3REQbits.IRQSEL = 0b00100001; // select SPI2 transfer done as trigger source
002E6A  B3C210     MOV.B #0x21, W0
002E6C  B7EB32     MOV.B WREG, DMA3REQ
135:                           DMA3PAD = (volatile unsigned int) &SPI2BUF; // peripheral address
002E6E  202680     MOV #0x268, W0
002E70  8859E0     MOV W0, DMA3PAD
136:                           break;
002E72  37000A     BRA .L13
137:                       case SPI_MODULE_SELECTOR_3:
138:                           DMA3REQbits.IRQSEL = 0b01011011; // select SPI3 transfer done as trigger source
002E74  B3C5B0     MOV.B #0x5B, W0
002E76  B7EB32     MOV.B WREG, DMA3REQ
139:                           DMA3PAD = (volatile unsigned int) &SPI3BUF; // peripheral address
002E78  202A80     MOV #0x2A8, W0
002E7A  8859E0     MOV W0, DMA3PAD
140:                           break;
002E7C  370005     BRA .L13
141:                       default:
142:                           DMA3REQbits.IRQSEL = 0b00001010; // select SPI1 transfer done as trigger source
002E7E  B3C0A0     MOV.B #0xA, W0
002E80  B7EB32     MOV.B WREG, DMA3REQ
143:                           DMA3PAD = (volatile unsigned int) &SPI1BUF; // peripheral address
002E82  202480     MOV #0x248, W0
002E84  8859E0     MOV W0, DMA3PAD
144:                           break;
002E86  000000     NOP
145:                   }
146:                   
147:                   // TODO: nakijken!
148:                   DMA3STAL = __builtin_dmaoffset(adc_rx_buffer_a); // buffer A
002E88  2D9C00     MOV #0xD9C0, W0
002E8A  8859A0     MOV W0, DMA3STAL
149:                   DMA3STAH = __builtin_dmapage(adc_rx_buffer_a); // buffer A
002E8C  200000     MOV #0x0, W0
002E8E  8859B0     MOV W0, DMA3STAH
150:                   DMA3STBL = __builtin_dmaoffset(adc_rx_buffer_b); // buffer B
002E90  2D8300     MOV #0xD830, W0
002E92  8859C0     MOV W0, DMA3STBL
151:                   DMA3STBH = __builtin_dmapage(adc_rx_buffer_b);
002E94  200000     MOV #0x0, W0
002E96  8859D0     MOV W0, DMA3STBH
152:                   
153:                   DMA3CNT = ADC_BUFFER_LENGTH-1;
002E98  200C70     MOV #0xC7, W0
002E9A  8859F0     MOV W0, DMA3CNT
154:                   
155:                   _DMA3IE = 1;
002E9C  A88824     BSET IEC2, #4
156:                   
157:                   // update callback
158:                   rx_callback = config->rx_callback;
002E9E  90101E     MOV [W14+34], W0
002EA0  901850     MOV [W0+58], W0
002EA2  888390     MOV W0, 0x1072
159:                   
160:                   // fill buffers with zeros
161:                   eds_read = DSRPAG;
002EA4  800191     MOV DSRPAG, W1
002EA6  980721     MOV W1, [W14+4]
162:                   DSRPAG = __builtin_edspage(adc_rx_buffer_a);
002EA8  200010     MOV #0x1, W0
002EAA  880190     MOV W0, DSRPAG
163:                   for(i = 0; i < ADC_BUFFER_LENGTH; i++){
002EAC  EB0000     CLR W0
002EAE  780F00     MOV W0, [W14]
002EB0  370013     BRA .L14
002ED6  E80F1E     INC [W14], [W14]
002ED8  200C70     MOV #0xC7, W0
002EDA  78009E     MOV [W14], W1
002EDC  508F80     SUB W1, W0, [W15]
002EDE  36FFE9     BRA LEU, .L15
164:                       adc_tx_buffer[i] = 0xD000;
002EB2  78001E     MOV [W14], W0
002EB4  400080     ADD W0, W0, W1
002EB6  2DB500     MOV #0xDB50, W0
002EB8  408000     ADD W1, W0, W0
002EBA  2D0001     MOV #0xD000, W1
002EBC  780801     MOV W1, [W0]
165:                       
166:                       adc_rx_buffer_a[i] = 0;
002EBE  78001E     MOV [W14], W0
002EC0  400080     ADD W0, W0, W1
002EC2  2D9C00     MOV #0xD9C0, W0
002EC4  408000     ADD W1, W0, W0
002EC6  EB0080     CLR W1
002EC8  780801     MOV W1, [W0]
167:                       adc_rx_buffer_b[i] = 0;
002ECA  78001E     MOV [W14], W0
002ECC  400080     ADD W0, W0, W1
002ECE  2D8300     MOV #0xD830, W0
002ED0  408000     ADD W1, W0, W0
002ED2  EB0080     CLR W1
002ED4  780801     MOV W1, [W0]
168:                   }
169:                   DSRPAG = eds_read;
002EE0  90012E     MOV [W14+4], W2
002EE2  880192     MOV W2, DSRPAG
170:                   
171:                   // configure input capture module 1 to detect nEOC edge and start
172:                   // SPI data transfer
173:                   
174:                   _IC1IF = 0;
002EE4  A92800     BCLR IFS0, #1
175:                   _IC1IE = 0;
002EE6  A92820     BCLR IEC0, #1
176:                   
177:                   IC1CON1bits.ICSIDL = 0; // continue operation in CPU idle mode
002EE8  A9A141     BCLR 0x141, #5
178:                   IC1CON1bits.ICTSEL = 0b111; // peripheral clock is clock source
002EEA  800A01     MOV IC1CON1, W1
002EEC  21C000     MOV #0x1C00, W0
002EEE  700001     IOR W0, W1, W0
002EF0  880A00     MOV W0, IC1CON1
179:                   IC1CON1bits.ICI = 0b00; // interrupt after every match
002EF2  800A01     MOV IC1CON1, W1
002EF4  2FF9F0     MOV #0xFF9F, W0
002EF6  608000     AND W1, W0, W0
002EF8  880A00     MOV W0, IC1CON1
180:                   IC1CON1bits.ICM = 0b011; // capture every edge
002EFA  800A01     MOV IC1CON1, W1
002EFC  2FFF80     MOV #0xFFF8, W0
002EFE  608000     AND W1, W0, W0
002F00  B30030     IOR #0x3, W0
002F02  880A00     MOV W0, IC1CON1
181:                   
182:                   IC1CON2bits.IC32 = 0; // disable cascade mode
002F04  A90143     BCLR 0x143, #0
183:                   IC1CON2bits.TRIGSTAT = 0; // no trigger has occurred
002F06  A9C142     BCLR IC1CON2, #6
184:                   IC1CON2bits.ICTRIG = 1; // trigger mode
002F08  A8E142     BSET IC1CON2, #7
185:                   IC1CON2bits.SYNCSEL = 0; // no sync or trigger source
002F0A  800A11     MOV IC1CON2, W1
002F0C  2FFE00     MOV #0xFFE0, W0
002F0E  608000     AND W1, W0, W0
002F10  880A10     MOV W0, IC1CON2
186:                   IC1CON2 = 0;
002F12  EF2142     CLR IC1CON2
187:                   _IC1IE = 0;
002F14  A92820     BCLR IEC0, #1
188:                   
189:                   // update the configuration and prepare for conversion
190:                   config->status = ADC_STATUS_IDLE;
002F16  90101E     MOV [W14+34], W0
002F18  200011     MOV #0x1, W1
002F1A  980851     MOV W1, [W0+26]
191:                   
192:                   init_spi_message(&m, write_data, read_data, 1, &config->cs_pin);
002F1C  90101E     MOV [W14+34], W0
002F1E  2002A3     MOV #0x2A, W3
002F20  418180     ADD W3, W0, W3
002F22  47017E     ADD W14, #0x1E, W2
002F24  4700FA     ADD W14, #0x1A, W1
002F26  47006A     ADD W14, #0xA, W0
002F28  780203     MOV W3, W4
002F2A  B3C013     MOV.B #0x1, W3
002F2C  07FEA0     RCALL init_spi_message
193:                   
194:                   switch(config->spi_module){
002F2E  90101E     MOV [W14+34], W0
002F30  901000     MOV [W0+32], W0
002F32  500FE1     SUB W0, #0x1, [W15]
002F34  320008     BRA Z, .L18
002F36  500FE1     SUB W0, #0x1, [W15]
002F38  390003     BRA NC, .L17
002F3A  500FE2     SUB W0, #0x2, [W15]
002F3C  320007     BRA Z, .L19
002F3E  370009     BRA .L26
195:                       case SPI_MODULE_SELECTOR_1:
196:                           send_spi_message = send_spi1_message;
002F40  223220     MOV #0x2322, W0
002F42  980710     MOV W0, [W14+2]
197:                           break;
002F44  370009     BRA .L20
198:                       case SPI_MODULE_SELECTOR_2:
199:                           send_spi_message = send_spi2_message;
002F46  224140     MOV #0x2414, W0
002F48  980710     MOV W0, [W14+2]
200:                           break;
002F4A  370006     BRA .L20
201:                       case SPI_MODULE_SELECTOR_3:
202:                           send_spi_message = send_spi3_message;
002F4C  225380     MOV #0x2538, W0
002F4E  980710     MOV W0, [W14+2]
203:                           break;
002F50  370003     BRA .L20
204:                       default:
205:                           send_spi_message = send_spi1_message;
002F52  223220     MOV #0x2322, W0
002F54  980710     MOV W0, [W14+2]
206:                           break;
002F56  000000     NOP
207:                   }
208:                       
209:                   // disable sampling
210:                   OC15CON1bits.OCM = 0b000;
002F58  804C61     MOV OC15CON1, W1
002F5A  2FFF80     MOV #0xFFF8, W0
002F5C  608000     AND W1, W0, W0
002F5E  884C60     MOV W0, OC15CON1
211:                   
212:                   // wake ADC
213:                   m.status = SPI_TRANSFER_PENDING;
002F60  EB0000     CLR W0
002F62  980F40     MOV W0, [W14+24]
214:                   write_data[0] = 0xB000;
002F64  2B0000     MOV #0xB000, W0
002F66  980F50     MOV W0, [W14+26]
215:                   send_spi_message(&m);
002F68  47006A     ADD W14, #0xA, W0
002F6A  90009E     MOV [W14+2], W1
002F6C  010001     CALL W1
216:                   
217:                   if(config->channel_select == ADC_CHANNEL_SELECT_MODE_AUTO){
002F6E  90101E     MOV [W14+34], W0
002F70  780010     MOV [W0], W0
002F72  500FE1     SUB W0, #0x1, [W15]
002F74  3A000E     BRA NZ, .L21
218:                       config->channel_select = ADC_CHANNEL_SELECT_MODE_MANUAL;
002F76  90101E     MOV [W14+34], W0
002F78  EB0080     CLR W1
002F7A  780801     MOV W1, [W0]
219:                       write_data[0] = adc_parse_cfr_write(config);
002F7C  90101E     MOV [W14+34], W0
002F7E  07FEA0     RCALL adc_parse_cfr_write
002F80  980F50     MOV W0, [W14+26]
220:                       m.status = SPI_TRANSFER_PENDING;
002F82  EB0000     CLR W0
002F84  980F40     MOV W0, [W14+24]
221:                       send_spi_message(&m);
002F86  47006A     ADD W14, #0xA, W0
002F88  90009E     MOV [W14+2], W1
002F8A  010001     CALL W1
222:                       
223:                       config->channel_select = ADC_CHANNEL_SELECT_MODE_AUTO;
002F8C  90101E     MOV [W14+34], W0
002F8E  200011     MOV #0x1, W1
002F90  780801     MOV W1, [W0]
224:                   }
225:                   
226:                   // update ADC channel
227:                   write_data[0] = config->channel << 12;
002F92  90101E     MOV [W14+34], W0
002F94  900840     MOV [W0+24], W0
002F96  DD004C     SL W0, #12, W0
002F98  980F50     MOV W0, [W14+26]
228:                   m.status = SPI_TRANSFER_PENDING;
002F9A  EB0000     CLR W0
002F9C  980F40     MOV W0, [W14+24]
229:                   send_spi_message(&m);
002F9E  47006A     ADD W14, #0xA, W0
002FA0  90009E     MOV [W14+2], W1
002FA2  010001     CALL W1
230:                   
231:                   write_data[0] = 0xD000;
002FA4  2D0000     MOV #0xD000, W0
002FA6  980F50     MOV W0, [W14+26]
232:                   m.status = SPI_TRANSFER_PENDING;
002FA8  EB0000     CLR W0
002FAA  980F40     MOV W0, [W14+24]
233:                   send_spi_message(&m);
002FAC  47006A     ADD W14, #0xA, W0
002FAE  90009E     MOV [W14+2], W1
002FB0  010001     CALL W1
234:                   
235:                   // update status config
236:                   write_data[0] = adc_parse_cfr_write(config);
002FB2  90101E     MOV [W14+34], W0
002FB4  07FE85     RCALL adc_parse_cfr_write
002FB6  980F50     MOV W0, [W14+26]
237:                   
238:               #ifdef ENABLE_DEBUG
239:                   sprintf(print_buffer, "ADC config set: %04x.", m.write_data[0]);
002FB8  90005E     MOV [W14+10], W0
002FBA  780010     MOV [W0], W0
002FBC  781F80     MOV W0, [W15++]
002FBE  292840     MOV #0x9284, W0
002FC0  781F80     MOV W0, [W15++]
002FC2  221A00     MOV #0x21A0, W0
002FC4  07EBCC     RCALL __sprintf_cdnopuxX
002FC6  5787E4     SUB W15, #0x4, W15
240:                   uart_print(print_buffer, strlen(print_buffer));
002FC8  221A00     MOV #0x21A0, W0
002FCA  07EBBC     RCALL _strlen
002FCC  780080     MOV W0, W1
002FCE  221A00     MOV #0x21A0, W0
002FD0  070757     RCALL uart_print
241:               #endif
242:                   
243:                   m.status = SPI_TRANSFER_PENDING;
002FD2  EB0000     CLR W0
002FD4  980F40     MOV W0, [W14+24]
244:                   send_spi_message(&m);
002FD6  47006A     ADD W14, #0xA, W0
002FD8  90009E     MOV [W14+2], W1
002FDA  010001     CALL W1
245:                   
246:                   write_data[0] = ADC_READ_CFR << 12;
002FDC  2C0000     MOV #0xC000, W0
002FDE  980F50     MOV W0, [W14+26]
247:                   m.status = SPI_TRANSFER_PENDING;
002FE0  EB0000     CLR W0
002FE2  980F40     MOV W0, [W14+24]
248:                   send_spi_message(&m);
002FE4  47006A     ADD W14, #0xA, W0
002FE6  90009E     MOV [W14+2], W1
002FE8  010001     CALL W1
249:                       
250:               #ifdef ENABLE_DEBUG
251:                       sprintf(print_buffer, "ADC response: %04x.", m.read_data[0]);
002FEA  90006E     MOV [W14+12], W0
002FEC  780010     MOV [W0], W0
002FEE  781F80     MOV W0, [W15++]
002FF0  2929A0     MOV #0x929A, W0
002FF2  781F80     MOV W0, [W15++]
002FF4  221A00     MOV #0x21A0, W0
002FF6  07EBB3     RCALL __sprintf_cdnopuxX
002FF8  5787E4     SUB W15, #0x4, W15
252:                       uart_print(print_buffer, strlen(print_buffer));
002FFA  221A00     MOV #0x21A0, W0
002FFC  07EBA3     RCALL _strlen
002FFE  780080     MOV W0, W1
003000  221A00     MOV #0x21A0, W0
003002  07073E     RCALL uart_print
253:               #endif
254:                   
255:                   //while(1){
256:                       CLEAR_BIT(config->conv_pin.lat_r, config->conv_pin.n);
003004  90101E     MOV [W14+34], W0
003006  901930     MOV [W0+54], W2
003008  90101E     MOV [W14+34], W0
00300A  901830     MOV [W0+54], W0
00300C  780190     MOV [W0], W3
00300E  90101E     MOV [W14+34], W0
003010  907800     MOV.B [W0+56], W0
003012  FB8200     ZE W0, W4
003014  200010     MOV #0x1, W0
003016  200001     MOV #0x0, W1
003018  780284     MOV W4, W5
00301A  E90285     DEC W5, W5
00301C  330003     BRA N, .LE498
00301E  400000     ADD W0, W0, W0
003020  488081     ADDC W1, W1, W1
003022  37FFFB     BRA .LB498
003024  780000     MOV W0, W0
003026  EA8000     COM W0, W0
003028  618000     AND W3, W0, W0
00302A  780900     MOV W0, [W2]
257:                       delay_us(10);
00302C  2000A0     MOV #0xA, W0
00302E  0708AC     RCALL delay_us
258:                       SET_BIT(config->conv_pin.lat_r, config->conv_pin.n);
003030  90101E     MOV [W14+34], W0
003032  901930     MOV [W0+54], W2
003034  90101E     MOV [W14+34], W0
003036  901830     MOV [W0+54], W0
003038  780190     MOV [W0], W3
00303A  90101E     MOV [W14+34], W0
00303C  907800     MOV.B [W0+56], W0
00303E  FB8200     ZE W0, W4
003040  200010     MOV #0x1, W0
003042  200001     MOV #0x0, W1
003044  780284     MOV W4, W5
003046  E90285     DEC W5, W5
003048  330003     BRA N, .LE515
00304A  400000     ADD W0, W0, W0
00304C  488081     ADDC W1, W1, W1
00304E  37FFFB     BRA .LB515
003050  780000     MOV W0, W0
003052  700003     IOR W0, W3, W0
003054  780900     MOV W0, [W2]
259:                       delay_us(10);
003056  2000A0     MOV #0xA, W0
003058  070897     RCALL delay_us
260:                       write_data[0] = 0xD000;
00305A  2D0000     MOV #0xD000, W0
00305C  980F50     MOV W0, [W14+26]
261:                       write_data[1] = 0x0000;
00305E  EB0000     CLR W0
003060  980F60     MOV W0, [W14+28]
262:                       init_spi_message(&m, write_data, read_data, 2, &config->cs_pin);
003062  90101E     MOV [W14+34], W0
003064  2002A3     MOV #0x2A, W3
003066  418180     ADD W3, W0, W3
003068  47017E     ADD W14, #0x1E, W2
00306A  4700FA     ADD W14, #0x1A, W1
00306C  47006A     ADD W14, #0xA, W0
00306E  780203     MOV W3, W4
003070  B3C023     MOV.B #0x2, W3
003072  07FDFD     RCALL init_spi_message
263:                       send_spi_message(&m);
003074  47006A     ADD W14, #0xA, W0
003076  90009E     MOV [W14+2], W1
003078  010001     CALL W1
264:                   
265:               #ifdef ENABLE_DEBUG
266:                       sprintf(print_buffer, "ADC read: %04x, %04x", m.read_data[0], m.read_data[1]);
00307A  90006E     MOV [W14+12], W0
00307C  E88000     INC2 W0, W0
00307E  780090     MOV [W0], W1
003080  90006E     MOV [W14+12], W0
003082  780010     MOV [W0], W0
003084  781F81     MOV W1, [W15++]
003086  781F80     MOV W0, [W15++]
003088  292AE0     MOV #0x92AE, W0
00308A  781F80     MOV W0, [W15++]
00308C  221A00     MOV #0x21A0, W0
00308E  07EB67     RCALL __sprintf_cdnopuxX
003090  5787E6     SUB W15, #0x6, W15
267:                       uart_print(print_buffer, strlen(print_buffer));
003092  221A00     MOV #0x21A0, W0
003094  07EB57     RCALL _strlen
003096  780080     MOV W0, W1
003098  221A00     MOV #0x21A0, W0
00309A  0706F2     RCALL uart_print
268:               #endif
269:                   
270:                       delay_ms(10);
00309C  2000A0     MOV #0xA, W0
00309E  070884     RCALL delay_ms
271:                  // }
272:                   
273:                   
274:                   if(config->deep_powerdown == ADC_DEEP_POWERDOWN_ENABLE){
0030A0  90101E     MOV [W14+34], W0
0030A2  900810     MOV [W0+18], W0
0030A4  E00000     CP0 W0
0030A6  3A0003     BRA NZ, .L22
275:                       config->status = ADC_STATUS_OFF;
0030A8  90101E     MOV [W14+34], W0
0030AA  200021     MOV #0x2, W1
0030AC  980851     MOV W1, [W0+26]
276:                   }
277:                   
278:                   // configure OC15 module to generate nCONVST signal to trigger sampling
279:                   // minimum pulse width = 40ns (or 3 clock cycli) and there must be 1500ns 
280:                   // (96 cycli) between conversions
281:                   
282:                   OC15CON1bits.OCM = 0b000;          // Disable Output Compare Module
0030AE  804C61     MOV OC15CON1, W1
0030B0  2FFF80     MOV #0xFFF8, W0
0030B2  608000     AND W1, W0, W0
0030B4  884C60     MOV W0, OC15CON1
283:                   OC15R = 4;   // Write the duty cycle for the PWM pulse
0030B6  200040     MOV #0x4, W0
0030B8  884C90     MOV W0, OC15R
284:                   OC15RS = (FCY / config->sample_frequency) -1;   // Write the PWM frequency
0030BA  90101E     MOV [W14+34], W0
0030BC  9008F0     MOV [W0+30], W1
0030BE  900860     MOV [W0+28], W0
0030C0  BE0100     MOV.D W0, W2
0030C2  290000     MOV #0x9000, W0
0030C4  203D01     MOV #0x3D0, W1
0030C6  07EB27     RCALL ___udivsi3
0030C8  780000     MOV W0, W0
0030CA  E90000     DEC W0, W0
0030CC  884C80     MOV W0, OC15RS
285:                   OC15CON1bits.OCTSEL = 0b111;       // Select peripheral clock as output compare time base
0030CE  804C61     MOV OC15CON1, W1
0030D0  21C000     MOV #0x1C00, W0
0030D2  700001     IOR W0, W1, W0
0030D4  884C60     MOV W0, OC15CON1
286:                   OC15CON2bits.SYNCSEL=0b11111;      // no sync or trigger source
0030D6  804C70     MOV OC15CON2, W0
0030D8  B301F0     IOR #0x1F, W0
0030DA  884C70     MOV W0, OC15CON2
287:                   OC15TMR = 0;                       // clear timer value
0030DC  EF2994     CLR OC15TMR
288:                   
289:                   OC15CON2bits.OCINV = 1; // invert output
0030DE  A8898F     BSET 0x98F, #4
290:                   
291:                   _OC15IF = 0;              // clear the OC15 interrupt flag
0030E0  A94811     BCLR 0x811, #2
292:                   _OC15IE = 0;              // disable OC155 interrupt
0030E2  A94831     BCLR 0x831, #2
293:                   
294:                   // configure the CS pin    
295:                   OC16CON1bits.OCM = 0b000; // Disable Output Compare Module
0030E4  804CB1     MOV OC16CON1, W1
0030E6  2FFF80     MOV #0xFFF8, W0
0030E8  608000     AND W1, W0, W0
0030EA  884CB0     MOV W0, OC16CON1
296:                   OC16R = (FCY / config->sample_frequency) - 10;   // Write the duty cycle for the PWM pulse
0030EC  90101E     MOV [W14+34], W0
0030EE  9008F0     MOV [W0+30], W1
0030F0  900860     MOV [W0+28], W0
0030F2  BE0100     MOV.D W0, W2
0030F4  290000     MOV #0x9000, W0
0030F6  203D01     MOV #0x3D0, W1
0030F8  07EB0E     RCALL ___udivsi3
0030FA  780000     MOV W0, W0
0030FC  50006A     SUB W0, #0xA, W0
0030FE  884CE0     MOV W0, OC16R
297:                   OC16RS = (FCY / config->sample_frequency) - 1;   // frequency
003100  90101E     MOV [W14+34], W0
003102  9008F0     MOV [W0+30], W1
003104  900860     MOV [W0+28], W0
003106  BE0100     MOV.D W0, W2
003108  290000     MOV #0x9000, W0
00310A  203D01     MOV #0x3D0, W1
00310C  07EB04     RCALL ___udivsi3
00310E  780000     MOV W0, W0
003110  E90000     DEC W0, W0
003112  884CD0     MOV W0, OC16RS
298:                   OC16CON1bits.OCSIDL = 0; // continue operation in CPU idle mode
003114  A9A997     BCLR 0x997, #5
299:                   OC16CON1bits.OCTSEL = 0b111; // user peripheral clock as clock source
003116  804CB1     MOV OC16CON1, W1
003118  21C000     MOV #0x1C00, W0
00311A  700001     IOR W0, W1, W0
00311C  884CB0     MOV W0, OC16CON1
300:                   OC16CON2bits.SYNCSEL = 0b11111; // no sync or trigger source
00311E  804CC0     MOV OC16CON2, W0
003120  B301F0     IOR #0x1F, W0
003122  884CC0     MOV W0, OC16CON2
301:                   OC16TMR = 0;
003124  EF299E     CLR OC16TMR
302:                   
303:                   OC16CON2bits.OCINV = 1; // invert output
003126  A88999     BSET 0x999, #4
304:                   
305:                   _OC16IF = 0;              // clear the OC1 interrupt flag
003128  A98811     BCLR 0x811, #4
306:                   _OC16IE = 0;              // disable OC1 interrupt
00312A  A98831     BCLR 0x831, #4
307:                   
308:                   // increase sample frequency if it is automated
309:                   if(config->trigger_select == ADC_TRIGGER_SELECT_AUTO){
00312C  90101E     MOV [W14+34], W0
00312E  900020     MOV [W0+4], W0
003130  E00000     CP0 W0
003132  3A0027     BRA NZ, .L23, .LBE2
310:                       
311:                       // increase sample frequency for auto trigger system
312:                       uint32_t sample_frequency = config->sample_frequency;
003134  90101E     MOV [W14+34], W0
003136  900960     MOV [W0+28], W2
003138  9009F0     MOV [W0+30], W3
00313A  980732     MOV W2, [W14+6]
00313C  980743     MOV W3, [W14+8]
313:                       sample_frequency = sample_frequency * (N_ADC_CHANNELS - config->channel);
00313E  90101E     MOV [W14+34], W0
003140  900840     MOV [W0+24], W0
003142  100068     SUBR W0, #0x8, W0
003144  EB0080     CLR W1
003146  90014E     MOV [W14+8], W2
003148  B99180     MULW.SS W2, W0, W2
00314A  9001BE     MOV [W14+6], W3
00314C  B99A81     MULW.SS W3, W1, W4
00314E  780184     MOV W4, W3
003150  410103     ADD W2, W3, W2
003152  9001BE     MOV [W14+6], W3
003154  B81800     MUL.UU W3, W0, W0
003156  410101     ADD W2, W1, W2
003158  780082     MOV W2, W1
00315A  980730     MOV W0, [W14+6]
00315C  980741     MOV W1, [W14+8]
00315E  980730     MOV W0, [W14+6]
003160  980741     MOV W1, [W14+8]
314:                       
315:                       OC15R = (FCY / sample_frequency)/2-1;   // Write the duty cycle for the PWM pulse
003162  90013E     MOV [W14+6], W2
003164  9001CE     MOV [W14+8], W3
003166  248000     MOV #0x4800, W0
003168  201E81     MOV #0x1E8, W1
00316A  07EAD5     RCALL ___udivsi3
00316C  780000     MOV W0, W0
00316E  E90000     DEC W0, W0
003170  884C90     MOV W0, OC15R
316:                       OC15RS = (FCY / sample_frequency) -1;   // Write the PWM frequency
003172  90013E     MOV [W14+6], W2
003174  9001CE     MOV [W14+8], W3
003176  290000     MOV #0x9000, W0
003178  203D01     MOV #0x3D0, W1
00317A  07EACD     RCALL ___udivsi3
00317C  780000     MOV W0, W0
00317E  E90000     DEC W0, W0
003180  884C80     MOV W0, OC15RS
317:                   }
318:                   
319:                   // restart sampling if it was activated
320:                   // configure ADC
321:               
322:                   // read status
323:                   write_data[0] = ADC_READ_CFR << 12;
003182  2C0000     MOV #0xC000, W0
003184  980F50     MOV W0, [W14+26]
324:                   m.status = SPI_TRANSFER_PENDING;
003186  EB0000     CLR W0
003188  980F40     MOV W0, [W14+24]
325:                   send_spi_message(&m);
00318A  47006A     ADD W14, #0xA, W0
00318C  90009E     MOV [W14+2], W1
00318E  010001     CALL W1
326:                       
327:               #ifdef ENABLE_DEBUG
328:                       sprintf(print_buffer, "ADC response: %04x.", m.read_data[0]);
003190  90006E     MOV [W14+12], W0
003192  780010     MOV [W0], W0
003194  781F80     MOV W0, [W15++]
003196  2929A0     MOV #0x929A, W0
003198  781F80     MOV W0, [W15++]
00319A  221A00     MOV #0x21A0, W0
00319C  07EAE0     RCALL __sprintf_cdnopuxX
00319E  5787E4     SUB W15, #0x4, W15
329:                       uart_print(print_buffer, strlen(print_buffer));
0031A0  221A00     MOV #0x21A0, W0
0031A2  07EAD0     RCALL _strlen
0031A4  780080     MOV W0, W1
0031A6  221A00     MOV #0x21A0, W0
0031A8  07066B     RCALL uart_print
330:               #endif
331:               
332:               
333:               }
0031AA  FA8000     ULNK
0031AC  060000     RETURN
334:               
335:               void __attribute__((__interrupt__, no_auto_psv)) _OC15Interrupt(void) {    
0004D8  FA0000     LNK #0x0
336:                   _OC15IF = 0;
0004DA  A94811     BCLR 0x811, #2
337:               }
0004DC  FA8000     ULNK
0004DE  064000     RETFIE
338:               
339:               void __attribute__((__interrupt__, no_auto_psv)) _OC16Interrupt(void) {    
0004E0  FA0000     LNK #0x0
340:                   _OC16IF = 0;
0004E2  A98811     BCLR 0x811, #4
341:               }
0004E4  FA8000     ULNK
0004E6  064000     RETFIE
342:               
343:               void __attribute__((__interrupt__, no_auto_psv)) _IC1Interrupt(void) {    
0004E8  FA0000     LNK #0x0
344:                   _IC1IF = 0;
0004EA  A92800     BCLR IFS0, #1
345:               }
0004EC  FA8000     ULNK
0004EE  064000     RETFIE
346:               
347:               void update_adc(adc_config_t* config){
0031AE  FA0002     LNK #0x2
0031B0  780F00     MOV W0, [W14]
348:                   // restart sampling if it was activated
349:                   if(config->status == ADC_STATUS_ON){
0031B2  78001E     MOV [W14], W0
0031B4  900850     MOV [W0+26], W0
0031B6  E00000     CP0 W0
0031B8  3A001D     BRA NZ, .L31
350:                       // update SPI transfer mode
351:                       switch(config->spi_module){
0031BA  78001E     MOV [W14], W0
0031BC  901000     MOV [W0+32], W0
0031BE  500FE1     SUB W0, #0x1, [W15]
0031C0  320007     BRA Z, .L34
0031C2  500FE1     SUB W0, #0x1, [W15]
0031C4  390003     BRA NC, .L33
0031C6  500FE2     SUB W0, #0x2, [W15]
0031C8  320005     BRA Z, .L35
0031CA  370006     BRA .L38
352:                           case SPI_MODULE_SELECTOR_1:
353:                               adc_spi1_init();
0031CC  070048     RCALL adc_spi1_init
354:                               break;
0031CE  370006     BRA .L36
355:                           case SPI_MODULE_SELECTOR_2:
356:                               adc_spi2_init();
0031D0  070066     RCALL adc_spi2_init
357:                               break;
0031D2  370004     BRA .L36
358:                           case SPI_MODULE_SELECTOR_3:
359:                               adc_spi3_init();
0031D4  070070     RCALL adc_spi3_init
360:                               break;
0031D6  370002     BRA .L36
361:                           default:
362:                               adc_spi1_init();
0031D8  070042     RCALL adc_spi1_init
363:                               break;
0031DA  000000     NOP
364:                       }
365:                       
366:                       
367:                       // start SPI transfers
368:                       DMA3CONbits.CHEN = 1; // enable DMA channel
0031DC  A8EB31     BSET 0xB31, #7
369:                       DMA2CONbits.CHEN = 1; // enable DMA channel
0031DE  A8EB21     BSET 0xB21, #7
370:                       
371:                       // TODO: make the number of instructions this takes compiler independent
372:                       // OK for now (4 cycles) -> >20ns
373:                       OC15CON1bits.OCM = 0b110;          // Select the Output Compare mode: EDGE-ALIGNED PWM MODE
0031E0  804C61     MOV OC15CON1, W1
0031E2  2FFF80     MOV #0xFFF8, W0
0031E4  608000     AND W1, W0, W0
0031E6  B30060     IOR #0x6, W0
0031E8  884C60     MOV W0, OC15CON1
374:                       OC16CON1bits.OCM = 0b110;          // Select the Output Compare mode: EDGE-ALIGNED PWM MODE
0031EA  804CB1     MOV OC16CON1, W1
0031EC  2FFF80     MOV #0xFFF8, W0
0031EE  608000     AND W1, W0, W0
0031F0  B30060     IOR #0x6, W0
0031F2  884CB0     MOV W0, OC16CON1
375:                   }
376:                   if(config->status == ADC_STATUS_OFF){
0031F4  78001E     MOV [W14], W0
0031F6  900850     MOV [W0+26], W0
0031F8  500FE2     SUB W0, #0x2, [W15]
0031FA  3A0019     BRA NZ, .L30
377:                       OC15CON1bits.OCM = 0b000;          // disable OC1 module
0031FC  804C61     MOV OC15CON1, W1
0031FE  2FFF80     MOV #0xFFF8, W0
003200  608000     AND W1, W0, W0
003202  884C60     MOV W0, OC15CON1
378:                   
379:                       // disable DMA transfer registers
380:                       DMA3CONbits.CHEN = 0; // enable DMA channel
003204  A9EB31     BCLR 0xB31, #7
381:                       DMA2CONbits.CHEN = 0; // enable DMA channel
003206  A9EB21     BCLR 0xB21, #7
382:                       
383:                       SET_BIT(config->cs_pin.lat_r, config->cs_pin.n);
003208  78001E     MOV [W14], W0
00320A  901170     MOV [W0+46], W2
00320C  78001E     MOV [W14], W0
00320E  901070     MOV [W0+46], W0
003210  780190     MOV [W0], W3
003212  78001E     MOV [W14], W0
003214  907000     MOV.B [W0+48], W0
003216  FB8200     ZE W0, W4
003218  200010     MOV #0x1, W0
00321A  200001     MOV #0x0, W1
00321C  780284     MOV W4, W5
00321E  E90285     DEC W5, W5
003220  330003     BRA N, .LE809
003222  400000     ADD W0, W0, W0
003224  488081     ADDC W1, W1, W1
003226  37FFFB     BRA .LB809
003228  780000     MOV W0, W0
00322A  700003     IOR W0, W3, W0
00322C  780900     MOV W0, [W2]
384:                   }
385:               }
00322E  FA8000     ULNK
003230  060000     RETURN
386:               
387:               void adc_start(adc_config_t* config){
003232  FA0002     LNK #0x2
003234  780F00     MOV W0, [W14]
388:                   // reset DMA transfer lengths (just in case)
389:                   DMA3CNT = ADC_BUFFER_LENGTH-1;
003236  200C70     MOV #0xC7, W0
003238  8859F0     MOV W0, DMA3CNT
390:                   DMA2CNT = ADC_BUFFER_LENGTH-1;
00323A  200C70     MOV #0xC7, W0
00323C  885970     MOV W0, DMA2CNT
391:                   
392:                   config->status = ADC_STATUS_ON;
00323E  78001E     MOV [W14], W0
003240  EB0080     CLR W1
003242  980851     MOV W1, [W0+26]
393:                   
394:                   update_adc(config);
003244  78001E     MOV [W14], W0
003246  07FFB3     RCALL update_adc
395:               }
003248  FA8000     ULNK
00324A  060000     RETURN
396:               
397:               void adc_stop(adc_config_t* config){    
00324C  FA0002     LNK #0x2
00324E  780F00     MOV W0, [W14]
398:                   config->status = ADC_STATUS_OFF;
003250  78001E     MOV [W14], W0
003252  200021     MOV #0x2, W1
003254  980851     MOV W1, [W0+26]
399:                   
400:                   update_adc(config);
003256  78001E     MOV [W14], W0
003258  07FFAA     RCALL update_adc
401:               }
00325A  FA8000     ULNK
00325C  060000     RETURN
402:               
403:               void __attribute__((__interrupt__, no_auto_psv)) _DMA3Interrupt(void) {  
0004F0  F80036     PUSH RCOUNT
0004F2  BE9F80     MOV.D W0, [W15++]
0004F4  BE9F82     MOV.D W2, [W15++]
0004F6  BE9F84     MOV.D W4, [W15++]
0004F8  BE9F86     MOV.D W6, [W15++]
0004FA  FA0000     LNK #0x0
404:                   rx_callback();
0004FC  808390     MOV 0x1072, W0
0004FE  010000     CALL W0
405:                   _DMA3IF = 0;
000500  A98804     BCLR IFS2, #4
406:               }
000502  FA8000     ULNK
000504  BE034F     MOV.D [--W15], W6
000506  BE024F     MOV.D [--W15], W4
000508  BE014F     MOV.D [--W15], W2
00050A  BE004F     MOV.D [--W15], W0
00050C  F90036     POP RCOUNT
00050E  064000     RETFIE
407:               
408:               void __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){
000510  FA0000     LNK #0x0
409:                   _DMA2IF = 0;
000512  A90803     BCLR 0x803, #0
410:               }
000514  FA8000     ULNK
000516  064000     RETFIE
411:               
412:               void adc_spi1_init(void){
00325E  FA0000     LNK #0x0
413:                   SPI1STATbits.SPIEN = 0;
003260  A9E241     BCLR 0x241, #7
414:                   
415:                   SPI1CON1bits.MODE16 = 1;  // communication is word-wide (16 bits)
003262  A84243     BSET 0x243, #2
416:                   SPI1CON1bits.MSTEN = 1;   // Master mode enabled
003264  A8A242     BSET SPI1CON1, #5
417:                   SPI1CON1bits.DISSCK = 0;  // internal serial clock enabled
003266  A98243     BCLR 0x243, #4
418:                   SPI1CON1bits.DISSDO = 0;  // SDO1 pin is controlled by module
003268  A96243     BCLR 0x243, #3
419:                   SPI1CON2bits.FRMEN = 1;
00326A  A8E245     BSET 0x245, #7
420:                   SPI1CON2bits.SPIFSD = 0;
00326C  A9C245     BCLR 0x245, #6
421:                   SPI1CON2bits.FRMPOL = 1;
00326E  A8A245     BSET 0x245, #5
422:                   SPI1CON2bits.FRMDLY = 0;
003270  A92244     BCLR SPI1CON2, #1
423:               
424:                   SPI1CON1bits.CKP = 0;     // idle state for clock is low level
003272  A9C242     BCLR SPI1CON1, #6
425:                   SPI1CON1bits.CKE = 1;     // data is shifted out on idle to active transition
003274  A80243     BSET 0x243, #0
426:                   SPI1CON1bits.SSEN = 1;    // slave select pin is controlled by module
003276  A8E242     BSET SPI1CON1, #7
427:                   SPI1CON1bits.PPRE = 0b01;
003278  801211     MOV SPI1CON1, W1
00327A  2FFFC0     MOV #0xFFFC, W0
00327C  608000     AND W1, W0, W0
00327E  A00000     BSET W0, #0
003280  881210     MOV W0, SPI1CON1
428:                   delay_ms(100);
003282  200640     MOV #0x64, W0
003284  070791     RCALL delay_ms
429:                   SPI1CON1bits.SPRE = 0b111; //0b111;
003286  801210     MOV SPI1CON1, W0
003288  B301C0     IOR #0x1C, W0
00328A  881210     MOV W0, SPI1CON1
430:                   SPI1CON1bits.SMP = 1;     // sample in the middle of data output time (falling edge)
00328C  A82243     BSET 0x243, #1
431:                   
432:                   SPI1STATbits.SPIBEC = 0;  // buffer Length = 1 Word
00328E  801201     MOV SPI1STAT, W1
003290  2F8FF0     MOV #0xF8FF, W0
003292  608000     AND W1, W0, W0
003294  881200     MOV W0, SPI1STAT
433:                   SPI1STATbits.SPIROV = 0;  // no Receive Overflow has occurred
003296  A9C240     BCLR SPI1STAT, #6
434:               
435:                   SPI1STATbits.SPIEN = 1;
003298  A8E241     BSET 0x241, #7
436:               }
00329A  FA8000     ULNK
00329C  060000     RETURN
437:               
438:               void adc_spi2_init(void){
00329E  FA0000     LNK #0x0
439:                   SPI2STATbits.SPIEN = 0;
0032A0  A9E261     BCLR 0x261, #7
440:                   
441:                   SPI2CON2bits.FRMEN = 1;
0032A2  A8E265     BSET 0x265, #7
442:                   SPI2CON2bits.SPIFSD = 0;
0032A4  A9C265     BCLR 0x265, #6
443:                   SPI2CON2bits.FRMPOL = 1;
0032A6  A8A265     BSET 0x265, #5
444:                   SPI2CON2bits.FRMDLY = 0;
0032A8  A92264     BCLR SPI2CON2, #1
445:               
446:                   SPI2CON1bits.CKP = 0;     // idle state for clock is low level
0032AA  A9C262     BCLR SPI2CON1, #6
447:                   SPI2CON1bits.CKE = 1;     // data is shifted out on idle to active transition
0032AC  A80263     BSET 0x263, #0
448:                   SPI2CON1bits.SMP = 1;     // sample in the middle of data output time (falling edge)
0032AE  A82263     BSET 0x263, #1
449:               
450:                   SPI2STATbits.SPIEN = 1;
0032B0  A8E261     BSET 0x261, #7
451:               }
0032B2  FA8000     ULNK
0032B4  060000     RETURN
452:               
453:               void adc_spi3_init(void){
0032B6  FA0000     LNK #0x0
454:                   SPI3STATbits.SPIEN = 0;
0032B8  A9E2A1     BCLR 0x2A1, #7
455:                   
456:                   SPI3CON1bits.MODE16 = 1;  // communication is word-wide (16 bits)
0032BA  A842A3     BSET 0x2A3, #2
457:                   SPI3CON1bits.MSTEN = 1;   // Master mode enabled
0032BC  A8A2A2     BSET SPI3CON1, #5
458:                   SPI3CON1bits.DISSCK = 0;  // internal serial clock enabled
0032BE  A982A3     BCLR 0x2A3, #4
459:                   SPI3CON1bits.DISSDO = 0;  // SDO3 pin is controlled by module
0032C0  A962A3     BCLR 0x2A3, #3
460:                   SPI3CON2bits.FRMEN = 0;   // enable framed mode
0032C2  A9E2A5     BCLR 0x2A5, #7
461:                   SPI3CON2bits.SPIFSD = 0;  // MCU outputs sync pulse
0032C4  A9C2A5     BCLR 0x2A5, #6
462:                   SPI3CON2bits.FRMPOL = 1;  // sync pulse is active high
0032C6  A8A2A5     BSET 0x2A5, #5
463:                   SPI3CON2bits.FRMDLY = 0;  // sync pulse emitted before first clock bit
0032C8  A922A4     BCLR SPI3CON2, #1
464:               
465:                   SPI3CON1bits.CKP = 0;     // idle state for clock is low level
0032CA  A9C2A2     BCLR SPI3CON1, #6
466:                   SPI3CON1bits.CKE = 0;     // data is shifted out on idle to active transition (not used in framed mode)
0032CC  A902A3     BCLR 0x2A3, #0
467:                   SPI3CON1bits.SSEN = 0;    // slave select pin is controlled by module
0032CE  A9E2A2     BCLR SPI3CON1, #7
468:                   SPI3CON1bits.PPRE = 0b00;
0032D0  801511     MOV SPI3CON1, W1
0032D2  2FFFC0     MOV #0xFFFC, W0
0032D4  608000     AND W1, W0, W0
0032D6  881510     MOV W0, SPI3CON1
469:                   delay_ms(100);
0032D8  200640     MOV #0x64, W0
0032DA  070766     RCALL delay_ms
470:                   SPI3CON1bits.SPRE = 0b110; //0b111;
0032DC  801511     MOV SPI3CON1, W1
0032DE  2FFE30     MOV #0xFFE3, W0
0032E0  608000     AND W1, W0, W0
0032E2  B30180     IOR #0x18, W0
0032E4  881510     MOV W0, SPI3CON1
471:                   SPI3CON1bits.SMP = 0;     // sample in the middle of data output time (falling edge)
0032E6  A922A3     BCLR 0x2A3, #1
472:                   
473:                   SPI3STATbits.SPIBEC = 0;  // buffer Length = 1 Word
0032E8  801501     MOV SPI3STAT, W1
0032EA  2F8FF0     MOV #0xF8FF, W0
0032EC  608000     AND W1, W0, W0
0032EE  881500     MOV W0, SPI3STAT
474:                   SPI3STATbits.SPIROV = 0;  // no Receive Overflow has occurred
0032F0  A9C2A0     BCLR SPI3STAT, #6
475:               
476:                   SPI3STATbits.SPIEN = 1;
0032F2  A8E2A1     BSET 0x2A1, #7
477:               }
0032F4  FA8000     ULNK
0032F6  060000     RETURN
